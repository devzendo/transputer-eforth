Microsoft (R) Macro Assembler Version 6.15.8803		    04/17/18 18:43:46
InMos Transputer 32-bit eForth				     Page 1 - 1


				TITLE InMos Transputer 32-bit eForth

				;PAGE 60,132	;60 lines per page, 132 characters per line ( was 62,132 )
				.386		; allow 32-bit equ values

				;===============================================================
				;
				;	eForth 1.0 by Bill Muench and C. H. Ting, 1990
				;	Much of the code is derived from the following sources:
				;		8086 figForth by Thomas Newman, 1981 and Joe smith, 1983
				;		aFORTH by John Rible
				;		bFORTH by Bill Muench
				;
				;	The goal of this implementation is to provide a simple eForth Model
				;	which can be ported easily to many 8, 16, 24 and 32 bit CPU's.
				;	The following attributes make it suitable for CPU's of the '90:
				;
				;		small machine dependent kernel and portable high level code
				;		source code in the MASM format
				;		direct threaded code
				;		separated code and name dictionaries
				;		simple vectored terminal and file interface to host computer
				;		aligned with the proposed ANS Forth Standard
				;		easy upgrade path to optimize for specific CPU
				;
				;	You are invited to implement this Model on your favorite CPU and
				;	contribute it to the eForth Library for public use. You may use
				;	a portable implementation to advertise more sophisticated and
				;	optimized version for commercial purposes. However, you are
				;	expected to implement the Model faithfully. The eForth Working
				;	Group reserves the right to reject implementation which deviates
				;	significantly from this Model.
				;
				;	As the ANS Forth Standard is still evolving, this Model will
				;	change accordingly. Implementations must state clearly the
				;	version number of the Model being tracked.
				;
				;	Representing the eForth Working Group in the Silicon Valley FIG Chapter.
				;	Send contributions to:
				;
				;		Dr. C. H. Ting
				;		156 14th Avenue
				;		San Mateo, CA 94402
				;		(415) 571-7639
				;
				;	32-bit Implementation for InMos Transputer by:
				;		Bob Barr
				;		c/o Mass Memory Technology
				;		4113A Scotts Valley Drive
				;		Scotts Valley, CA  95066
				;		(408) 438-1887
				;
				;===============================================================

				;; Version control

 = 0001				VER		EQU	01H			;major release version
 = 0001				EXT		EQU	01H			;minor extension

				;; Constants

 = 0040				COMPO		EQU	040H			;lexicon compile only bit
 = 0080				IMEDD		EQU	080H			;lexicon immediate bit
 = 7F1F				MASKK		EQU	07F1FH			;lexicon bit mask

 = 0004				CELLL		EQU	4			;size of a cell
 = 000A				BASEE		EQU	10			;default radix
 = 0008				VOCSS		EQU	8			;depth of vocabulary stack

 = 0008				BKSPP		EQU	8			;backspace
 = 000A				LF		EQU	10			;line feed
 = 000D				CRR		EQU	13			;carriage return
 = 001B				ERRESC		EQU	27			;error escape
 = 0027				TIC		EQU	39			;tick

 = 0000				CALLL		EQU	0h	; was 0E890H NOP CALL opcodes

				;; Memory allocation	0//code>--//--<name//up>--<sp//tib>--rp//em

 = 4001FF7C			EM		EQU	04001FF7cH		;top of memory
 = 40000000			COLDD		EQU	040000000H		;cold start vector

 = 0100				US		EQU	64*CELLL		;user area size in cells
 = 0100				RTS		EQU	64*CELLL		;return stack/TIB size

 = 4001FF5C			RPP		EQU	EM-8*CELLL		;start of return stack (RP0)
 = 4001FE5C			TIBB		EQU	RPP-RTS 		;terminal input buffer (TIB)
 = 4001FE3C			SPP		EQU	TIBB-8*CELLL		;start of data stack (SP0)
 = 4001FB7C			UPP		EQU	EM-256*CELLL		;start of user area (UP0)
 = 4001FB5C			NAMEE		EQU	UPP-8*CELLL		;name dictionary
 = 40000100			CODEE		EQU	COLDD+US		;code dictionary

				;; Initialize assembly variables

 = 0000				_LINK	= 0					;force a null link
 = 4001FB5C			_NAME	= NAMEE 				;initialize name pointer
 = 40000100			_CODE	= CODEE 				;initialize code pointer
 = 0010				_USER	= 4*CELLL				;first user variable offset

				;; Define assembly macros


				;	Compile a code definition header.

				$CODE	MACRO	LEX,NAME,LABEL
					ALIGN	4				
;force to cell boundary
				LABEL:						;;assembly label
					_CODE	= $				;;save code pointer
					_LEN	= (LEX AND 01FH)/CELLL		;;string cell count, round down
					_NAME	= _NAME-((_LEN+3)*CELLL)	;;new header on cell boundary
				ORG	_NAME					
;set name pointer
					DD	 _CODE,_LINK			;;token pointer and link
					_LINK	= $				;;link points to a name string
					DB	LEX,NAME			;;name string
				ORG	_CODE					
;restore code pointer
					ENDM

				;	Compile a colon definition header.

				$COLON	MACRO	LEX,NAME,LABEL
					$CODE	LEX,NAME,LABEL
					align	4
					db	048h		;; ldc x	point to dd DOLST
					db	021h,0fbh	;; ldpi 	make prg rel -> absolute
					db	025h,0fah	;; dupx 	second copy
					db	084h		;; adcx 4	point past the 'dd DOLST'
					db	0f0h		;; rev		put incremented pointer under
					db	030h		;; ldnl 0	fetch the pointer
					db	0f6h		;; gcall	jump to it
					db	0,0,0
					dd	DOLST
					ENDM

				;	Compile a user variable header.

				$USER	MACRO	LEX,NAME,LABEL
					$CODE	LEX,NAME,LABEL
					align	4
					db	048h		;; ldc 8	point to dd DOLST
					db	021h,0fbh	;; ldpi 	make prg rel -> absolute
					db	025h,0fah	;; dupx 	second copy
					db	084h		;; adcx 4	point past the 'dd DOLST'
					db	0f0h		;; rev		put incremented pointer under
					db	030h		;; ldnl 0	fetch the pointer
					db	0f6h		;; gcall	jump to it
					db	0,0,0
					dd	DOLST
					DD	DOUSE,_USER			;;followed by doUSER and offset
					_USER	= _USER+CELLL			
;update user area offset
					ENDM

				;	Compile an inline string.

				D$	MACRO	FUNCT,STRNG
					DD	FUNCT				;;function
					_LEN	= $				;;save address of count byte
					DB	0,STRNG 			;;count byte and string
					_CODE	= $				;;save code pointer
				ORG	_LEN					;;point to count byte
					DB	_CODE-_LEN-1			;;set count
				ORG	_CODE					
;restore code pointer
					ALIGN	4
					ENDM


				; Transputer assembly code macros and defines

 = 25FB2148			entry1	equ	025fb2148h	; for direct threading
 = 30F084FA			entry2	equ	030f084fah
 = 00F6				entry3	equ	0000000f6h


 = 28000000			uartbase	equ	28000000h

 = 0000				mr1a	equ	00h
 = 0000				mr2a	equ	00h
 = 0001				csra	equ	01h
 = 0002				cra	equ	02h
 = 0004				ustat	equ	04h		; byte offset for status reg
 = 000C				dataout equ	0ch		; byte offset for data out reg
 = 000C				datain	equ	0ch		; byte offset for data in  reg
 = 0001				charin	equ	01h		; status bit for char ready


				; local register allocation
 = 0001				uread	equ	01h		; loc reg containing read routine addr
 = 0002				uart	equ	02h		; loc reg containimg uart base address

				; Forth pointers
 = 0004				w	equ	04h
 = 0005				spx	equ	05h
 = 0006				ip	equ	06h
 = 0007				rp	equ	07h

 = 000F				scratch equ	0fh



				prfx	macro	val,modif,cnt	; prefix instruction
					db	020h or (val modif cnt and 00fh)
					endm

				ldc	macro	val		; load constant opcode
					db	040h or (val and 00fh)
					endm

				adcx	macro	val		; add constant opcode
					db	080h or (val and 00fh)
					endm

				ldl	macro	val		; load local opcode
					db	070h or (val and 00fh)
					endm

				ldnl	macro	val		; load non-local opcode
					db	030h or (val and 00fh)
					endm

				jzx	macro	val		; jump if zero
					db	0a0h or (val and 00fh)
					endm

				stl	macro	val		; store local opcode
					db	0d0h or (val and 00fh)
					endm

				stnl	macro	val		; store non-local opcode
					db	0e0h or (val and 00fh)
					endm

				eqc	macro	val		; compare constant opcode
					db	0c0h or (val and 00fh)
					endm

				andx	macro			; bitwise and opcode
					db	024h,0f6h
					endm

				orx	macro			; bitwise or  opcode
					db	024h,0fbh
					endm

				xorx	macro			; bitwise xor opcode
					db	023h,0f3h
					endm

				notx	macro			; bitwise not opcode
					db	023h,0f2h
					endm

				dupx	macro			; duplicate A reg value
					db	025h,0fah
					endm

				move	macro			; transputer block move
					db	024h,0fah
					endm


				; maintain popx and pushx lengths at 6 bytes to avoid problems with
				;	relative branches in the assembly code words that use them
				popx	macro			; pop tos to reg A		bytes
					ldl	spx		;; fetch sp			  1
					dupx			;; extra copy for fetch 	  2
					adcx	4		;; bump up 1 level		  1
					stl	spx		;; save it			  1
					ldnl	0		;; get previous tos		  1
					endm

				pushx	macro			; push reg A to tos		bytes
					ldl	spx		;; sp				  1
					db	060h,08ch	;; adc -4			  2
					stl	spx		;;				  1
					ldl	spx		;;				  1
					stnl	0		;; (sp) = n			  1
					endm

				rev	macro
					db	0f0h
					endm

				gcall	macro			; general call opcode
					db	0f6h
					endm

				celldn	macro			; bump A value down by 1 cell
					db	060h,08ch
					endm

				lb	macro			; load byte opcode
					db	0f1h
					endm

				sb	macro			; store byte opcode
					db	023h,0fbh
					endm

				mint	macro			; generate minimum integer opcode
					db	024h,0f2h
					endm

				uwait	macro			; kill a little time during uart init
					db	023h,0ffh
					db	023h,0ffh	; 2 wcnt operations (slow no-ops)
					endm

				;
				;	Assemble inline indirect threaded code ending.
				;		Maintain at same number of bytes in length. Relative branches
				;		in code rely on a 11 byte expansion.
				$NEXT	MACRO				;;			bytes
					ldl	ip			;; get ip		  1
					dupx				;;			  2
					adcx	4			;; bump it one cell	  1
					stl	ip			;; and save it back	  1
					ldnl	0			;; get orig (ip)	  1
					dupx				;; it points to cfa	  2
					stl	w			;; save it		  1
					ldnl	0			;; get the code address   1
					gcall				;; and jump to it	  1
					ENDM

				;; Main entry points and COLD start data

 00000000			MAIN	SEGMENT USE32
				ASSUME	CS:MAIN

				ORG	COLDD					;beginning of cold boot

 40000000			ORIG:
					mint			; most negative integer 	( $8000.0000 )
 40000000  24 F2	     1		db	024h,0f2h
					prfx	2
 40000002  22		     1		db	020h or (2   and 00fh)
					prfx	0
 40000003  20		     1		db	020h or (0   and 00fh)
					adcx	0		; $8000.0200
 40000004  80		     1		db	080h or (0 and 00fh)
 40000005  23 FC			db	023h,0fch	; gajw - set workspace pointer
					mint			; most neg
 40000007  24 F2	     1		db	024h,0f2h
					stl	0		; keep it handy
 40000009  D0		     1		db	0d0h or (0 and 00fh)
					ldl	0
 4000000A  70		     1		db	070h or (0 and 00fh)
 4000000B  21 FC			db	021h,0fch	; clear lo-priority queue	( stlf )
					ldl	0
 4000000D  70		     1		db	070h or (0 and 00fh)
 4000000E  21 F8			db	021h,0f8h	; clear hi-priority queue	( sthf )
 40000010  25 F7			db	025h,0f7h	; clear halt-on-error flag	( clrhalterr )
 40000012  22 F9			db	022h,0f9h	; clear the error flag		( testerr )
 40000014  2B F2			db	02bh,0f2h	; clear debug break		( clrj0break )
 40000016  27 FA			db	027h,0fah	; disable hi-pri timer
 40000018  27 FB			db	027h,0fbh	; disable lo-pri timer
				;
				; initialize link and event channels off
				;
					ldl	0
 4000001A  70		     1		db	070h or (0 and 00fh)
					ldl	0
 4000001B  70		     1		db	070h or (0 and 00fh)
					stnl	0
 4000001C  E0		     1		db	0e0h or (0 and 00fh)
					ldl	0
 4000001D  70		     1		db	070h or (0 and 00fh)
					ldl	0
 4000001E  70		     1		db	070h or (0 and 00fh)
					stnl	1
 4000001F  E1		     1		db	0e0h or (1 and 00fh)
					ldl	0
 40000020  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000021  70		     1		db	070h or (0 and 00fh)
					stnl	2
 40000022  E2		     1		db	0e0h or (2 and 00fh)
					ldl	0
 40000023  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000024  70		     1		db	070h or (0 and 00fh)
					stnl	3
 40000025  E3		     1		db	0e0h or (3 and 00fh)
					ldl	0
 40000026  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000027  70		     1		db	070h or (0 and 00fh)
					stnl	4
 40000028  E4		     1		db	0e0h or (4 and 00fh)
					ldl	0
 40000029  70		     1		db	070h or (0 and 00fh)
					ldl	0
 4000002A  70		     1		db	070h or (0 and 00fh)
					stnl	5
 4000002B  E5		     1		db	0e0h or (5 and 00fh)
					ldl	0
 4000002C  70		     1		db	070h or (0 and 00fh)
					ldl	0
 4000002D  70		     1		db	070h or (0 and 00fh)
					stnl	6
 4000002E  E6		     1		db	0e0h or (6 and 00fh)
					ldl	0
 4000002F  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000030  70		     1		db	070h or (0 and 00fh)
					stnl	7
 40000031  E7		     1		db	0e0h or (7 and 00fh)
					ldl	0
 40000032  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000033  70		     1		db	070h or (0 and 00fh)
					stnl	8
 40000034  E8		     1		db	0e0h or (8 and 00fh)
					ldl	0
 40000035  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000036  70		     1		db	070h or (0 and 00fh)
					stnl	9
 40000037  E9		     1		db	0e0h or (9 and 00fh)
					ldl	0
 40000038  70		     1		db	070h or (0 and 00fh)
					ldl	0
 40000039  70		     1		db	070h or (0 and 00fh)
					stnl	10
 4000003A  EA		     1		db	0e0h or (10 and 00fh)

				;	make a pointer to the uart read code in ROM
 = urdcode			temp1	equ	urdcode
					if1		; leave space during pass 1 of assembly
 4000003B  00 00 00 00 00		db	0,0,0,0,0,0,0,0
	   00 00 00
					else		; generate code during pass 2 (label now known)
					prfx	temp1 shr 28
					prfx	temp1 shr 24
					prfx	temp1 shr 20
					prfx	temp1 shr 16
					prfx	temp1 shr 12
					prfx	temp1 shr  8
					prfx	temp1 shr  4
					ldc	temp1
					endif
				;
				; copy the uart read routine to Transputer internal RAM for execution
					mint			;			mint	urd>	--
 40000043  24 F2	     1		db	024h,0f2h
					prfx	0fh
 40000045  2F		     1		db	020h or (0fh   and 00fh)
					prfx	0fh
 40000046  2F		     1		db	020h or (0fh   and 00fh)
					ldc	0		; dest is 80000ff0	ff0	mint	urd>
 40000047  40		     1		db	040h or (0 and 00fh)
					orx			;			dest	urd>	--
 40000048  24 FB	     1		db	024h,0fbh
					dupx			;			dest	dest	urd>
 4000004A  25 FA	     1		db	025h,0fah
					stl	uread		; set local pointer	dest	urd>	--
 4000004C  D1		     1		db	0d0h or (uread and 00fh)
					ldc	15		; move 15 bytes 	15	dest	urd>
 4000004D  4F		     1		db	040h or (15 and 00fh)
					move			; do the move
 4000004E  24 FA	     1		db	024h,0fah

				;	set the UART base address
					prfx	uartbase shr 28
 40000050  22		     1		db	020h or (uartbase shr 28 and 00fh)
					prfx	uartbase shr 24
 40000051  28		     1		db	020h or (uartbase shr 24 and 00fh)
					prfx	uartbase shr 20
 40000052  20		     1		db	020h or (uartbase shr 20 and 00fh)
					prfx	uartbase shr 16
 40000053  20		     1		db	020h or (uartbase shr 16 and 00fh)
					prfx	uartbase shr 12
 40000054  20		     1		db	020h or (uartbase shr 12 and 00fh)
					prfx	uartbase shr  8
 40000055  20		     1		db	020h or (uartbase shr 8 and 00fh)
					prfx	uartbase shr  4
 40000056  20		     1		db	020h or (uartbase shr 4 and 00fh)
					ldc	uartbase
 40000057  40		     1		db	040h or (uartbase and 00fh)
					stl	uart
 40000058  D2		     1		db	0d0h or (uart and 00fh)

				;	set initial return stack pointer
					prfx	RPP shr 28
 40000059  24		     1		db	020h or (RPP shr 28 and 00fh)
					prfx	RPP shr 24
 4000005A  20		     1		db	020h or (RPP shr 24 and 00fh)
					prfx	RPP shr 20
 4000005B  20		     1		db	020h or (RPP shr 20 and 00fh)
					prfx	RPP shr 16
 4000005C  21		     1		db	020h or (RPP shr 16 and 00fh)
					prfx	RPP shr 12
 4000005D  2F		     1		db	020h or (RPP shr 12 and 00fh)
					prfx	RPP shr  8
 4000005E  2F		     1		db	020h or (RPP shr 8 and 00fh)
					prfx	RPP shr  4
 4000005F  25		     1		db	020h or (RPP shr 4 and 00fh)
					ldc	RPP
 40000060  4C		     1		db	040h or (RPP and 00fh)
					stl	rp
 40000061  D7		     1		db	0d0h or (rp and 00fh)

				;	set initial data stack pointer
					prfx	SPP shr 28
 40000062  24		     1		db	020h or (SPP shr 28 and 00fh)
					prfx	SPP shr 24
 40000063  20		     1		db	020h or (SPP shr 24 and 00fh)
					prfx	SPP shr 20
 40000064  20		     1		db	020h or (SPP shr 20 and 00fh)
					prfx	SPP shr 16
 40000065  21		     1		db	020h or (SPP shr 16 and 00fh)
					prfx	SPP shr 12
 40000066  2F		     1		db	020h or (SPP shr 12 and 00fh)
					prfx	SPP shr  8
 40000067  2E		     1		db	020h or (SPP shr 8 and 00fh)
					prfx	SPP shr  4
 40000068  23		     1		db	020h or (SPP shr 4 and 00fh)
					ldc	SPP
 40000069  4C		     1		db	040h or (SPP and 00fh)
					stl	spx
 4000006A  D5		     1		db	0d0h or (spx and 00fh)

				;	jump to cold start
				;	first make a pointer to the code
				.NOLIST
					if1
 4000006B  00 00 00 00 00		db	0,0,0,0,0,0,0,0 ; leave space during pass 1 of assembly
	   00 00 00
					else		; generate code during pass 2 (label now known)
					prfx	cold shr 28
					prfx	cold shr 24
					prfx	cold shr 20
					prfx	cold shr 16
					prfx	cold shr 12
					prfx	cold shr  8
					prfx	cold shr  4
					ldc	cold
					endif
				.LIST
					gcall			; jump to it
 40000073  F6		     1		db	0f6h


				; COLD start moves the following to USER variables.
				; MUST BE IN SAME ORDER AS USER VARIABLES.

				ALIGN  4					;align to cell boundary

 40000074  00000004 [		UZERO:		DD	4 DUP (0)		;reserved
	    00000000
	   ]
 40000084  4001FE3C				DD	SPP			;SP0
 40000088  4001FF5C				DD	RPP			;RP0
 4000008C  40000108 R				DD	QRX			;'?KEY
 40000090  40000140 R				DD	TXSTO			;'EMIT
 40000094  40001C60 R				DD	ACCEP			;'EXPECT
 40000098  40001BFC R				DD	KTAP			;'TAP
 4000009C  40000140 R				DD	TXSTO			;'ECHO
 400000A0  40001EC8 R				DD	DOTOK			;'PROMPT
 400000A4  0000000A				DD	BASEE			;BASE
 400000A8  00000000				DD	0			;tmp
 400000AC  00000000				DD	0			;SPAN
 400000B0  00000000				DD	0			;>IN
 400000B4  00000000				DD	0			;#TIB
 400000B8  4001FE5C				DD	TIBB			;TIB
 400000BC  00000000				DD	0			;CSP
 400000C0  40001E40 R				DD	INTER			;'EVAL
 400000C4  40001294 R				DD	NUMBQ			;'NUMBER
 400000C8  00000000				DD	0			;HLD
 400000CC  00000000				DD	0			;HANDLER
 400000D0  00000000				DD	0			;CONTEXT pointer
 400000D4  00000008 [				DD	VOCSS DUP (0)		;vocabulary stack
	    00000000
	   ]
 400000F4  00000000				DD	0			;CURRENT pointer
 400000F8  00000000				DD	0			;vocabulary link pointer
 400000FC  40002B70 R				DD	CTOP			;CP
 40000100  4001EF08				DD	NTOP			;NP
 40000104  4001EF0C				DD	LASTN			;LAST
 40000108			ULAST:

				ORG	CODEE					;start code dictionary

				;; Device dependent I/O

				;   BYE 	( -- )
				;		Exit eForth.
				; Since there is no O.S. to exit to, BYE is not implemented.
				; It could be implemented as shown to just restart eForth.
				;
				;		$CODE	3,'BYE',BYE
				;		db	027h,02fh,02fh,02fh	; ldc with restart address
				;		db	02fh,02fh,02fh,04eh	; .. of 7ffffffeh
				;		gcall				; jump to it
				;

				; UART read and wait routines - strange but necessary
				; ( addr rtn -- val rtn )

						$CODE	3,'URD',urdcode
			     1		ALIGN	4				
 40000100		     1	urdcode:						
 40000100 = 40000100	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FB50		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB50  40000100 R	     1		DD	 _CODE,_LINK			
	   00000000
 4001FB58 = 4001FB58	     1		_LINK	= $				
 4001FB58  03 55 52 44	     1		DB	3,'URD'			
			     1	ORG	_CODE					
						rev			;  tuck return addr under reg
 40000100  F0		     1		db	0f0h
						ldl  uart		;  get uart base address
 40000101  72		     1		db	070h or (uart and 00fh)
 40000102  25 F2				db	025h,0f2h	;  add to desired register   ( sum )
						ldnl  0 		;  read the uart
 40000104  30		     1		db	030h or (0 and 00fh)
						rev			;  put rtn back on top
 40000105  F0		     1		db	0f0h
						gcall			;  return to caller
 40000106  F6		     1		db	0f6h



				;   ?RX 	( -- c T | F )
				;		Return input character and true, or a false if no input.

						$CODE	3,'?RX',QRX
			     1		ALIGN	4				
 40000108		     1	QRX:						
 40000108 = 40000108	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FB44		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB44  40000108 R	     1		DD	 _CODE,_LINK			
	   4001FB58 R
 4001FB4C = 4001FB4C	     1		_LINK	= $				
 4001FB4C  03 3F 52 58	     1		DB	3,'?RX'			
			     1	ORG	_CODE					
						ldc	ustat			; status reg offset
 40000108  44		     1		db	040h or (ustat and 00fh)
						ldl	uread			; address of read code
 40000109  71		     1		db	070h or (uread and 00fh)
						gcall				; call it to get status
 4000010A  F6		     1		db	0f6h
						stl	scratch 		; toss return address
 4000010B  DF		     1		db	0d0h or (scratch and 00fh)
						ldc	charin			; check for char in bit
 4000010C  41		     1		db	040h or (charin and 00fh)
						andx
 4000010D  24 F6	     1		db	024h,0f6h
				; NOTE: the following relative branch is sensitive to the lengths of
				;		macros pushx and $next plus the code bytes between it
				;		and label rx1. Count carefully!!!!!
 = (rx1-from1)			dist	EQU	(rx1-from1)
						prfx	(dist shr 4)
 4000010F  21		     1		db	020h or ((dist shr 4) and 00fh)
						jzx	dist
 40000110  AD		     1		db	0a0h or (dist and 00fh)

				;		 db	 021h,0a8h		 ; jz to rx1, no char in

 40000111			from1:
						ldc	datain			; data in reg offset	    1
 40000111  4C		     1		db	040h or (datain and 00fh)
						ldl	uread			;			    1
 40000112  71		     1		db	070h or (uread and 00fh)
						gcall				; read the char 	    1
 40000113  F6		     1		db	0f6h
						stl	scratch 		; toss return address	    1
 40000114  DF		     1		db	0d0h or (scratch and 00fh)
						pushx				; char to tos		    6
			     1		ldl	spx		;; sp				  1
 40000115  75		     2		db	070h or (spx and 00fh)
 40000116  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 40000118  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 40000119  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 4000011A  E0		     2		db	0e0h or (0 and 00fh)
 4000011B  60 4F				db	060h,04fh		; ldc -1		    2
						pushx				; true on top of it	    6
			     1		ldl	spx		;; sp				  1
 4000011D  75		     2		db	070h or (spx and 00fh)
 4000011E  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 40000120  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 40000121  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 40000122  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT				;			    7
			     1		ldl	ip			;; get ip		  1
 40000123  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000124  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000126  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000127  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000128  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000129  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000012B  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000012C  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000012D  F6		     2		db	0f6h
 4000012E			rx1:
						ldc	0			; push a false
 4000012E  40		     1		db	040h or (0 and 00fh)
						pushx
			     1		ldl	spx		;; sp				  1
 4000012F  75		     2		db	070h or (spx and 00fh)
 40000130  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 40000132  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 40000133  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 40000134  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000135  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000136  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000138  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000139  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000013A  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000013B  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000013D  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000013E  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000013F  F6		     2		db	0f6h


				;   TX! 	( c -- )
				;		Send character c to the output device.

						$CODE	3,'TX!',TXSTO
			     1		ALIGN	4				
 40000140		     1	TXSTO:						
 40000140 = 40000140	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FB38		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB38  40000140 R	     1		DD	 _CODE,_LINK			
	   4001FB4C R
 4001FB40 = 4001FB40	     1		_LINK	= $				
 4001FB40  03 54 58 21	     1		DB	3,'TX!'			
			     1	ORG	_CODE					
						popx			; get the char
			     1		ldl	spx		;; fetch sp			  1
 40000140  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000141  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000143  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000144  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000145  30		     2		db	030h or (0 and 00fh)
						ldl	uart		; get uart base address
 40000146  72		     1		db	070h or (uart and 00fh)
						adcx	dataout
 40000147  8C		     1		db	080h or (dataout and 00fh)
						sb			; store the byte to write it
 40000148  23 FB	     1		db	023h,0fbh
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000014A  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 4000014B  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000014D  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000014E  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000014F  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000150  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000152  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000153  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000154  F6		     2		db	0f6h


				;   !IO 	( -- )
				;		Initialize the serial I/O devices.

						$CODE	3,'!IO',STOIO
			     1		ALIGN	4				
 40000158		     1	STOIO:						
 40000158 = 40000158	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FB2C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB2C  40000158 R	     1		DD	 _CODE,_LINK			
	   4001FB40 R
 4001FB34 = 4001FB34	     1		_LINK	= $				
 4001FB34  03 21 49 4F	     1		DB	3,'!IO'			
			     1	ORG	_CODE					
						prfx	1
 40000158  21		     1		db	020h or (1   and 00fh)
						ldc	0ah		; reset mode ptr,disable rx/tx
 40000159  4A		     1		db	040h or (0ah and 00fh)
						ldl	uart
 4000015A  72		     1		db	070h or (uart and 00fh)
						stnl	CRA		; write to CRA reg
 4000015B  E2		     1		db	0e0h or (CRA and 00fh)

						uwait			; kill time between writes
 4000015C  23 FF	     1		db	023h,0ffh
 4000015E  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	2
 40000160  22		     1		db	020h or (2   and 00fh)
						ldc	0ah		; reset receiver
 40000161  4A		     1		db	040h or (0ah and 00fh)
						ldl	uart
 40000162  72		     1		db	070h or (uart and 00fh)
						stnl	CRA
 40000163  E2		     1		db	0e0h or (CRA and 00fh)

						uwait			; kill time between writes
 40000164  23 FF	     1		db	023h,0ffh
 40000166  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	3
 40000168  23		     1		db	020h or (3   and 00fh)
						ldc	0ah		; reset transmitter
 40000169  4A		     1		db	040h or (0ah and 00fh)
						ldl	uart
 4000016A  72		     1		db	070h or (uart and 00fh)
						stnl	CRA
 4000016B  E2		     1		db	0e0h or (CRA and 00fh)

						uwait			; kill time between writes
 4000016C  23 FF	     1		db	023h,0ffh
 4000016E  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	4
 40000170  24		     1		db	020h or (4   and 00fh)
						ldc	0ah		; reset error ststus
 40000171  4A		     1		db	040h or (0ah and 00fh)
						ldl	uart
 40000172  72		     1		db	070h or (uart and 00fh)
						stnl	CRA
 40000173  E2		     1		db	0e0h or (CRA and 00fh)

						uwait			; kill time between writes
 40000174  23 FF	     1		db	023h,0ffh
 40000176  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	5
 40000178  25		     1		db	020h or (5   and 00fh)
						ldc	0ah		; reset break change
 40000179  4A		     1		db	040h or (0ah and 00fh)
						ldl	uart
 4000017A  72		     1		db	070h or (uart and 00fh)
						stnl	CRA
 4000017B  E2		     1		db	0e0h or (CRA and 00fh)

						uwait			; kill time between writes
 4000017C  23 FF	     1		db	023h,0ffh
 4000017E  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	1
 40000180  21		     1		db	020h or (1   and 00fh)
						ldc	03		; no parity,8 data bits to MR1A
 40000181  43		     1		db	040h or (03 and 00fh)
						ldl	uart
 40000182  72		     1		db	070h or (uart and 00fh)
						stnl	MR1A
 40000183  E0		     1		db	0e0h or (MR1A and 00fh)

						uwait			; kill time between writes
 40000184  23 FF	     1		db	023h,0ffh
 40000186  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						ldc	7		; normal mode, 1 stop bit to MR2A
 40000188  47		     1		db	040h or (7 and 00fh)
						ldl	uart
 40000189  72		     1		db	070h or (uart and 00fh)
						stnl	MR2A
 4000018A  E0		     1		db	0e0h or (MR2A and 00fh)

						uwait			; kill time between writes
 4000018B  23 FF	     1		db	023h,0ffh
 4000018D  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						prfx	0bh
 4000018F  2B		     1		db	020h or (0bh   and 00fh)
						ldc	0bh		; tx and rx clock to 9600 baud to CSRA
 40000190  4B		     1		db	040h or (0bh and 00fh)
						ldl	uart
 40000191  72		     1		db	070h or (uart and 00fh)
						stnl	CSRA
 40000192  E1		     1		db	0e0h or (CSRA and 00fh)

						uwait			; kill time between writes
 40000193  23 FF	     1		db	023h,0ffh
 40000195  23 FF	     1		db	023h,0ffh	; 2 wcnt operations (slow no-ops)

						ldc	5		; enable rx and tx to CRA
 40000197  45		     1		db	040h or (5 and 00fh)
						ldl	uart
 40000198  72		     1		db	070h or (uart and 00fh)
						stnl	CRA
 40000199  E2		     1		db	0e0h or (CRA and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000019A  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 4000019B  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000019D  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000019E  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000019F  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400001A0  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400001A2  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400001A3  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400001A4  F6		     2		db	0f6h



				;; The kernel

				;   doLIT	( -- w )
				;		Push an inline literal.

						$CODE	COMPO+5,'doLIT',DOLIT
			     1		ALIGN	4				
 400001A8		     1	DOLIT:						
 400001A8 = 400001A8	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (COMPO+5 AND 01FH)/CELLL		
 = 4001FB1C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB1C  400001A8 R	     1		DD	 _CODE,_LINK			
	   4001FB34 R
 4001FB24 = 4001FB24	     1		_LINK	= $				
 4001FB24  45 64 6F 4C 49    1		DB	COMPO+5,'doLIT'			
	   54
			     1	ORG	_CODE					
						ldl	ip			; get ip
 400001A8  76		     1		db	070h or (ip and 00fh)
						dupx				; dup it
 400001A9  25 FA	     1		db	025h,0fah
						adcx	4			; bump it up 1 cell
 400001AB  84		     1		db	080h or (4 and 00fh)
						stl	ip			; and save it
 400001AC  D6		     1		db	0d0h or (ip and 00fh)
						ldnl	0			; get (ip)
 400001AD  30		     1		db	030h or (0 and 00fh)
						pushx				; push it to tos
			     1		ldl	spx		;; sp				  1
 400001AE  75		     2		db	070h or (spx and 00fh)
 400001AF  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 400001B1  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 400001B2  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 400001B3  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400001B4  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400001B5  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400001B7  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400001B8  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400001B9  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400001BA  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400001BC  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400001BD  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400001BE  F6		     2		db	0f6h

				;   doLIST	( a -- )
				;		Process colon list.

						$CODE	COMPO+6,'doLIST',DOLST
			     1		ALIGN	4				
 400001C0		     1	DOLST:						
 400001C0 = 400001C0	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (COMPO+6 AND 01FH)/CELLL		
 = 4001FB0C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FB0C  400001C0 R	     1		DD	 _CODE,_LINK			
	   4001FB24 R
 4001FB14 = 4001FB14	     1		_LINK	= $				
 4001FB14  46 64 6F 4C 49    1		DB	COMPO+6,'doLIST'			
	   53 54
			     1	ORG	_CODE					
						stl	scratch 		; trash xputer rtn addr
 400001C0  DF		     1		db	0d0h or (scratch and 00fh)
						stl	scratch 		; save target address
 400001C1  DF		     1		db	0d0h or (scratch and 00fh)
						ldl	ip			; push ip onto return stack
 400001C2  76		     1		db	070h or (ip and 00fh)
						ldl	rp			; get rp
 400001C3  77		     1		db	070h or (rp and 00fh)
						celldn				; adjust down 1 cell
 400001C4  60 8C	     1		db	060h,08ch
						stnl	0			; and put ip there
 400001C6  E0		     1		db	0e0h or (0 and 00fh)
						ldl	scratch 		; get new list address
 400001C7  7F		     1		db	070h or (scratch and 00fh)
						stl	ip			; to ip
 400001C8  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400001C9  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400001CA  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400001CC  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400001CD  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400001CE  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400001CF  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400001D1  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400001D2  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400001D3  F6		     2		db	0f6h

				;   EXIT	( -- )
				;		Terminate a colon definition.

						$CODE	4,'EXIT',EXIT
			     1		ALIGN	4				
 400001D4		     1	EXIT:						
 400001D4 = 400001D4	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (4 AND 01FH)/CELLL		
 = 4001FAFC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FAFC  400001D4 R	     1		DD	 _CODE,_LINK			
	   4001FB14 R
 4001FB04 = 4001FB04	     1		_LINK	= $				
 4001FB04  04 45 58 49 54    1		DB	4,'EXIT'
			     1	ORG	_CODE
						ldl	rp			;
 400001D4  77		     1		db	070h or (rp and 00fh)
						ldnl	0			; get (rp)
 400001D5  30		     1		db	030h or (0 and 00fh)
						stl	ip			; into ip
 400001D6  D6		     1		db	0d0h or (ip and 00fh)
						ldl	rp			; adjust rp up
 400001D7  77		     1		db	070h or (rp and 00fh)
						adcx	4			; ..by 1 cell
 400001D8  84		     1		db	080h or (4 and 00fh)
						stl	rp			;
 400001D9  D7		     1		db	0d0h or (rp and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400001DA  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400001DB  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400001DD  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400001DE  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400001DF  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400001E0  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400001E2  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400001E3  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400001E4  F6		     2		db	0f6h

				;   EXECUTE	( ca -- )
				;		Execute the word at ca.

						$CODE	7,'EXECUTE',EXECU
			     1		ALIGN	4				
 400001E8		     1	EXECU:						
 400001E8 = 400001E8	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (7 AND 01FH)/CELLL		
 = 4001FAEC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FAEC  400001E8 R	     1		DD	 _CODE,_LINK			
	   4001FB04 R
 4001FAF4 = 4001FAF4	     1		_LINK	= $				
 4001FAF4  07 45 58 45 43    1		DB	7,'EXECUTE'			
	   55 54 45
			     1	ORG	_CODE					
						popx				; pop addr from stack
			     1		ldl	spx		;; fetch sp			  1
 400001E8  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 400001E9  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 400001EB  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 400001EC  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 400001ED  30		     2		db	030h or (0 and 00fh)
						gcall				; jump to it
 400001EE  F6		     1		db	0f6h

				;   next	( -- )
				;		Run time code for the single index loop.
				;		: next ( -- ) \ hilevel model
				;		  r> r> dup if 1 - >r @ >r exit then drop cell+ >r ;

						$CODE	COMPO+4,'next',DONXT
			     1		ALIGN	4				
 400001F0		     1	DONXT:						
 400001F0 = 400001F0	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (COMPO+4 AND 01FH)/CELLL		
 = 4001FADC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FADC  400001F0 R	     1		DD	 _CODE,_LINK			
	   4001FAF4 R
 4001FAE4 = 4001FAE4	     1		_LINK	= $				
 4001FAE4  44 6E 65 78 74    1		DB	COMPO+4,'next'			
			     1	ORG	_CODE					
						ldl	rp
 400001F0  77		     1		db	070h or (rp and 00fh)
						ldnl	0			; fetch the index
 400001F1  30		     1		db	030h or (0 and 00fh)
 400001F2  60 8F				db	060h,08fh		; adc -1
						dupx				; extra copy for test
 400001F4  25 FA	     1		db	025h,0fah
						ldl	rp
 400001F6  77		     1		db	070h or (rp and 00fh)
						stnl	0			; and back to (rp)
 400001F7  E0		     1		db	0e0h or (0 and 00fh)
						mint				; sign bit set? (decr below 0)
 400001F8  24 F2	     1		db	024h,0f2h
						andx
 400001FA  24 F6	     1		db	024h,0f6h
						eqc	0
 400001FC  C0		     1		db	0c0h or (0 and 00fh)

				; NOTE: The following relative branch is sensitive to the length of the
				;		macro $NEXT and the number of code bytes between it and
				;		label next1. Count carefully!!!!!
				;		JZ	NEXT1
 400001FD  AA					db	0aah			; if so, exit loop
										;			bytes
						ldl	ip			; else, continue loop	  1
 400001FE  76		     1		db	070h or (ip and 00fh)
						ldnl	0			; ip = (ip)		  1
 400001FF  30		     1		db	030h or (0 and 00fh)
						stl	ip			;			  1
 40000200  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT				;			  7
			     1		ldl	ip			;; get ip		  1
 40000201  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000202  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000204  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000205  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000206  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000207  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000209  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000020A  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000020B  F6		     2		db	0f6h

 4000020C			NEXT1:
						ldl	rp			; else, pop the index
 4000020C  77		     1		db	070h or (rp and 00fh)
						adcx	4
 4000020D  84		     1		db	080h or (4 and 00fh)
						stl	rp
 4000020E  D7		     1		db	0d0h or (rp and 00fh)
						ldl	ip
 4000020F  76		     1		db	070h or (ip and 00fh)
						adcx	4
 40000210  84		     1		db	080h or (4 and 00fh)
						stl	ip
 40000211  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000212  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000213  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000215  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000216  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000217  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000218  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000021A  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000021B  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000021C  F6		     2		db	0f6h

				;   ?branch	( f -- )
				;		Branch if flag is zero.

						$CODE	COMPO+7,'?branch',QBRAN
			     1		ALIGN	4				
 40000220		     1	QBRAN:						
 40000220 = 40000220	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (COMPO+7 AND 01FH)/CELLL		
 = 4001FACC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FACC  40000220 R	     1		DD	 _CODE,_LINK			
	   4001FAE4 R
 4001FAD4 = 4001FAD4	     1		_LINK	= $				
 4001FAD4  47 3F 62 72 61    1		DB	COMPO+7,'?branch'			
	   6E 63 68
			     1	ORG	_CODE					
						popx				; get flag
			     1		ldl	spx		;; fetch sp			  1
 40000220  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000221  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000223  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000224  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000225  30		     2		db	030h or (0 and 00fh)

				; NOTE: relative branch is sensitive to length of macro $NEXT
				;		JZ	BRAN1			;yes, so branch
 40000226  AA					db	0aah
										;else continue past	bytes
						ldl	ip			;point IP to next cell	  1
 40000227  76		     1		db	070h or (ip and 00fh)
						adcx	4			;(past the inline branch) 1
 40000228  84		     1		db	080h or (4 and 00fh)
						stl	ip			;			  1
 40000229  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT				;			  7
			     1		ldl	ip			;; get ip		  1
 4000022A  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 4000022B  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000022D  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000022E  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000022F  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000230  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000232  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000233  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000234  F6		     2		db	0f6h

 40000235			BRAN1:
						ldl	ip			; get ip
 40000235  76		     1		db	070h or (ip and 00fh)
						ldnl	0			; get (ip)  (the branch target)
 40000236  30		     1		db	030h or (0 and 00fh)
						stl	ip			; ip = (ip)
 40000237  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000238  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000239  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000023B  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000023C  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000023D  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000023E  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000240  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000241  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000242  F6		     2		db	0f6h

				;   branch	( -- )
				;		Branch to an inline address.

						$CODE	COMPO+6,'branch',BRAN
			     1		ALIGN	4				
 40000244		     1	BRAN:						
 40000244 = 40000244	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (COMPO+6 AND 01FH)/CELLL		
 = 4001FABC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FABC  40000244 R	     1		DD	 _CODE,_LINK			
	   4001FAD4 R
 4001FAC4 = 4001FAC4	     1		_LINK	= $				
 4001FAC4  46 62 72 61 6E    1		DB	COMPO+6,'branch'			
	   63 68
			     1	ORG	_CODE					
						ldl	ip			; get ip
 40000244  76		     1		db	070h or (ip and 00fh)
						ldnl	0			; get (ip)
 40000245  30		     1		db	030h or (0 and 00fh)
						stl	ip			; ip = (ip)
 40000246  D6		     1		db	0d0h or (ip and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000247  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000248  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000024A  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000024B  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000024C  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000024D  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000024F  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000250  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000251  F6		     2		db	0f6h

				;   !		( w a -- )
				;		Pop the data stack to memory.

						$CODE	1,'!',STORE
			     1		ALIGN	4				
 40000254		     1	STORE:						
 40000254 = 40000254	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (1 AND 01FH)/CELLL		
 = 4001FAB0		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FAB0  40000254 R	     1		DD	 _CODE,_LINK			
	   4001FAC4 R
 4001FAB8 = 4001FAB8	     1		_LINK	= $				
 4001FAB8  01 21	     1		DB	1,'!'			
			     1	ORG	_CODE					
						popx				; get the address
			     1		ldl	spx		;; fetch sp			  1
 40000254  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000255  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000257  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000258  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000259  30		     2		db	030h or (0 and 00fh)
						popx				; ..and the data
			     1		ldl	spx		;; fetch sp			  1
 4000025A  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 4000025B  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 4000025D  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 4000025E  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 4000025F  30		     2		db	030h or (0 and 00fh)
						rev
 40000260  F0		     1		db	0f0h
						ldnl	0			; store it
 40000261  30		     1		db	030h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000262  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000263  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000265  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000266  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000267  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000268  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000026A  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000026B  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000026C  F6		     2		db	0f6h

				;   @		( a -- w )
				;		Push memory location to the data stack.

						$CODE	1,'@',AT
			     1		ALIGN	4				
 40000270		     1	AT:						
 40000270 = 40000270	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (1 AND 01FH)/CELLL		
 = 4001FAA4		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FAA4  40000270 R	     1		DD	 _CODE,_LINK			
	   4001FAB8 R
 4001FAAC = 4001FAAC	     1		_LINK	= $				
 4001FAAC  01 40	     1		DB	1,'@'			
			     1	ORG	_CODE					
						ldl	spx			; get pointer to tos
 40000270  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get the addr
 40000271  30		     1		db	030h or (0 and 00fh)
						ldnl	0			; get (addr)
 40000272  30		     1		db	030h or (0 and 00fh)
						ldl	spx			; point to tos
 40000273  75		     1		db	070h or (spx and 00fh)
						stnl	0			; set data to tos
 40000274  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000275  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000276  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000278  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000279  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000027A  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000027B  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000027D  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000027E  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000027F  F6		     2		db	0f6h

				;   C!		( c b -- )
				;		Pop the data stack to byte memory.

						$CODE	2,'C!',CSTOR
			     1		ALIGN	4				
 40000280		     1	CSTOR:						
 40000280 = 40000280	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001FA98		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA98  40000280 R	     1		DD	 _CODE,_LINK			
	   4001FAAC R
 4001FAA0 = 4001FAA0	     1		_LINK	= $				
 4001FAA0  02 43 21	     1		DB	2,'C!'			
			     1	ORG	_CODE					
						popx				; get the addr
			     1		ldl	spx		;; fetch sp			  1
 40000280  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000281  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000283  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000284  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000285  30		     2		db	030h or (0 and 00fh)
						popx				; ..and the byte
			     1		ldl	spx		;; fetch sp			  1
 40000286  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000287  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000289  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 4000028A  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 4000028B  30		     2		db	030h or (0 and 00fh)
						rev
 4000028C  F0		     1		db	0f0h
						sb				; store it
 4000028D  23 FB	     1		db	023h,0fbh
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000028F  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000290  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000292  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000293  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000294  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000295  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000297  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000298  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000299  F6		     2		db	0f6h

				;   C@		( b -- c )
				;		Push byte memory location to the data stack.

						$CODE	2,'C@',CAT
			     1		ALIGN	4				
 4000029C		     1	CAT:						
 4000029C = 4000029C	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001FA8C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA8C  4000029C R	     1		DD	 _CODE,_LINK			
	   4001FAA0 R
 4001FA94 = 4001FA94	     1		_LINK	= $				
 4001FA94  02 43 40	     1		DB	2,'C@'			
			     1	ORG	_CODE					
						ldl	spx			; get the addr of tos
 4000029C  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get byte addr
 4000029D  30		     1		db	030h or (0 and 00fh)
						lb				; fetch the byte
 4000029E  F1		     1		db	0f1h
						ldl	spx			; point to tos
 4000029F  75		     1		db	070h or (spx and 00fh)
						stnl	0			; and put the byte at tos
 400002A0  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400002A1  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400002A2  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400002A4  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400002A5  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400002A6  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400002A7  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400002A9  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400002AA  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400002AB  F6		     2		db	0f6h

				;   RP@ 	( -- a )
				;		Push the current RP to the data stack.

						$CODE	3,'RP@',RPAT
			     1		ALIGN	4				
 400002AC		     1	RPAT:						
 400002AC = 400002AC	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FA80		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA80  400002AC R	     1		DD	 _CODE,_LINK			
	   4001FA94 R
 4001FA88 = 4001FA88	     1		_LINK	= $				
 4001FA88  03 52 50 40	     1		DB	3,'RP@'			
			     1	ORG	_CODE					
						ldl	rp			; get rp value
 400002AC  77		     1		db	070h or (rp and 00fh)
						pushx				; to tos
			     1		ldl	spx		;; sp				  1
 400002AD  75		     2		db	070h or (spx and 00fh)
 400002AE  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 400002B0  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 400002B1  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 400002B2  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400002B3  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400002B4  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400002B6  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400002B7  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400002B8  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400002B9  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400002BB  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400002BC  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400002BD  F6		     2		db	0f6h

				;   RP! 	( a -- )
				;		Set the return stack pointer.

						$CODE	COMPO+3,'RP!',RPSTO
			     1		ALIGN	4				
 400002C0		     1	RPSTO:						
 400002C0 = 400002C0	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001FA74		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA74  400002C0 R	     1		DD	 _CODE,_LINK			
	   4001FA88 R
 4001FA7C = 4001FA7C	     1		_LINK	= $				
 4001FA7C  43 52 50 21	     1		DB	COMPO+3,'RP!'			
			     1	ORG	_CODE					
						popx				; get the value
			     1		ldl	spx		;; fetch sp			  1
 400002C0  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 400002C1  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 400002C3  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 400002C4  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 400002C5  30		     2		db	030h or (0 and 00fh)
						stl	rp			; set to rp reg
 400002C6  D7		     1		db	0d0h or (rp and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400002C7  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400002C8  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400002CA  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400002CB  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400002CC  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400002CD  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400002CF  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400002D0  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400002D1  F6		     2		db	0f6h

				;   R>		( -- w )
				;		Pop the return stack to the data stack.

						$CODE	2,'R>',RFROM
			     1		ALIGN	4				
 400002D4		     1	RFROM:						
 400002D4 = 400002D4	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001FA68		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA68  400002D4 R	     1		DD	 _CODE,_LINK			
	   4001FA7C R
 4001FA70 = 4001FA70	     1		_LINK	= $				
 4001FA70  02 52 3E	     1		DB	2,'R>'			
			     1	ORG	_CODE					
						ldl	rp			; get current rp
 400002D4  77		     1		db	070h or (rp and 00fh)
						ldnl	0			; get current (rp)
 400002D5  30		     1		db	030h or (0 and 00fh)
						ldl	rp			; adjust rp up one cell
 400002D6  77		     1		db	070h or (rp and 00fh)
						adcx	4			;
 400002D7  84		     1		db	080h or (4 and 00fh)
						stl	rp			;
 400002D8  D7		     1		db	0d0h or (rp and 00fh)
						pushx				; return data in tos
			     1		ldl	spx		;; sp				  1
 400002D9  75		     2		db	070h or (spx and 00fh)
 400002DA  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 400002DC  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 400002DD  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 400002DE  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400002DF  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400002E0  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400002E2  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400002E3  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400002E4  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400002E5  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400002E7  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400002E8  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400002E9  F6		     2		db	0f6h

				;   R@		( -- w )
				;		Copy top of return stack to the data stack.

						$CODE	2,'R@',RAT
			     1		ALIGN	4				
 400002EC		     1	RAT:						
 400002EC = 400002EC	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001FA5C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA5C  400002EC R	     1		DD	 _CODE,_LINK			
	   4001FA70 R
 4001FA64 = 4001FA64	     1		_LINK	= $				
 4001FA64  02 52 40	     1		DB	2,'R@'			
			     1	ORG	_CODE					
						ldl	rp			; get rp
 400002EC  77		     1		db	070h or (rp and 00fh)
						ldnl	0			; get (rp)
 400002ED  30		     1		db	030h or (0 and 00fh)
						pushx				; to tos
			     1		ldl	spx		;; sp				  1
 400002EE  75		     2		db	070h or (spx and 00fh)
 400002EF  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 400002F1  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 400002F2  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 400002F3  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400002F4  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400002F5  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400002F7  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400002F8  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400002F9  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400002FA  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400002FC  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400002FD  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400002FE  F6		     2		db	0f6h

				;   >R		( w -- )
				;		Push the data stack to the return stack.

						$CODE	COMPO+2,'>R',TOR
			     1		ALIGN	4				
 40000300		     1	TOR:						
 40000300 = 40000300	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (COMPO+2 AND 01FH)/CELLL		
 = 4001FA50		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA50  40000300 R	     1		DD	 _CODE,_LINK			
	   4001FA64 R
 4001FA58 = 4001FA58	     1		_LINK	= $				
 4001FA58  42 3E 52	     1		DB	COMPO+2,'>R'			
			     1	ORG	_CODE					
						ldl	rp			; current rp
 40000300  77		     1		db	070h or (rp and 00fh)
						celldn				; bump down 1 cell
 40000301  60 8C	     1		db	060h,08ch
						stl	rp			;
 40000303  D7		     1		db	0d0h or (rp and 00fh)
						popx				; get data
			     1		ldl	spx		;; fetch sp			  1
 40000304  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 40000305  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 40000307  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000308  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000309  30		     2		db	030h or (0 and 00fh)
						ldl	rp			; get new rp
 4000030A  77		     1		db	070h or (rp and 00fh)
						stnl	0			; put on rp
 4000030B  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000030C  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 4000030D  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000030F  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000310  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000311  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000312  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000314  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000315  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000316  F6		     2		db	0f6h

				;   SP@ 	( -- a )
				;		Push the current data stack pointer.

						$CODE	3,'SP@',SPAT
			     1		ALIGN	4				
 40000318		     1	SPAT:						
 40000318 = 40000318	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FA44		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA44  40000318 R	     1		DD	 _CODE,_LINK			
	   4001FA58 R
 4001FA4C = 4001FA4C	     1		_LINK	= $				
 4001FA4C  03 53 50 40	     1		DB	3,'SP@'			
			     1	ORG	_CODE					
						ldl	spx			; get current sp
 40000318  75		     1		db	070h or (spx and 00fh)
						pushx				; to tos
			     1		ldl	spx		;; sp				  1
 40000319  75		     2		db	070h or (spx and 00fh)
 4000031A  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 4000031C  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 4000031D  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 4000031E  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000031F  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000320  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000322  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000323  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000324  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000325  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000327  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000328  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000329  F6		     2		db	0f6h

				;   SP! 	( a -- )
				;		Set the data stack pointer.

						$CODE	3,'SP!',SPSTO
			     1		ALIGN	4				
 4000032C		     1	SPSTO:						
 4000032C = 4000032C	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FA38		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA38  4000032C R	     1		DD	 _CODE,_LINK			
	   4001FA4C R
 4001FA40 = 4001FA40	     1		_LINK	= $				
 4001FA40  03 53 50 21	     1		DB	3,'SP!'			
			     1	ORG	_CODE					
						popx				; get value
			     1		ldl	spx		;; fetch sp			  1
 4000032C  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 4000032D  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 4000032F  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 40000330  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 40000331  30		     2		db	030h or (0 and 00fh)
						stl	spx			; set in sp
 40000332  D5		     1		db	0d0h or (spx and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000333  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000334  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000336  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000337  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000338  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000339  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000033B  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000033C  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000033D  F6		     2		db	0f6h

				;   DROP	( w -- )
				;		Discard top stack item.

						$CODE	4,'DROP',DROP
			     1		ALIGN	4				
 40000340		     1	DROP:						
 40000340 = 40000340	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (4 AND 01FH)/CELLL		
 = 4001FA28		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA28  40000340 R	     1		DD	 _CODE,_LINK			
	   4001FA40 R
 4001FA30 = 4001FA30	     1		_LINK	= $				
 4001FA30  04 44 52 4F 50    1		DB	4,'DROP'			
			     1	ORG	_CODE					
						ldl	spx			; get sp
 40000340  75		     1		db	070h or (spx and 00fh)
						adcx	4			; bump by 1 cell
 40000341  84		     1		db	080h or (4 and 00fh)
						stl	spx			; and set it
 40000342  D5		     1		db	0d0h or (spx and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000343  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000344  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000346  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000347  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000348  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000349  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000034B  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 4000034C  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000034D  F6		     2		db	0f6h

				;   DUP 	( w -- w w )
				;		Duplicate the top stack item.

						$CODE	3,'DUP',DUPP
			     1		ALIGN	4				
 40000350		     1	DUPP:						
 40000350 = 40000350	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001FA1C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA1C  40000350 R	     1		DD	 _CODE,_LINK			
	   4001FA30 R
 4001FA24 = 4001FA24	     1		_LINK	= $				
 4001FA24  03 44 55 50	     1		DB	3,'DUP'			
			     1	ORG	_CODE					
						ldl	spx			; get sp
 40000350  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get tos
 40000351  30		     1		db	030h or (0 and 00fh)
						pushx				; push another copy
			     1		ldl	spx		;; sp				  1
 40000352  75		     2		db	070h or (spx and 00fh)
 40000353  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 40000355  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 40000356  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 40000357  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000358  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000359  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000035B  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000035C  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000035D  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000035E  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000360  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000361  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000362  F6		     2		db	0f6h

				;   SWAP	( w1 w2 -- w2 w1 )
				;		Exchange top two stack items.

						$CODE	4,'SWAP',SWAP
			     1		ALIGN	4				
 40000364		     1	SWAP:						
 40000364 = 40000364	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (4 AND 01FH)/CELLL		
 = 4001FA0C		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001FA0C  40000364 R	     1		DD	 _CODE,_LINK			
	   4001FA24 R
 4001FA14 = 4001FA14	     1		_LINK	= $				
 4001FA14  04 53 57 41 50    1		DB	4,'SWAP'			
			     1	ORG	_CODE					
						ldl	spx			;
 40000364  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get tos
 40000365  30		     1		db	030h or (0 and 00fh)
						ldl	spx			;
 40000366  75		     1		db	070h or (spx and 00fh)
						ldnl	1			; get nos
 40000367  31		     1		db	030h or (1 and 00fh)
						ldl	spx			;
 40000368  75		     1		db	070h or (spx and 00fh)
						stnl	0			; nos -> tos
 40000369  E0		     1		db	0e0h or (0 and 00fh)
						ldl	spx			;
 4000036A  75		     1		db	070h or (spx and 00fh)
						stnl	1			; tos -> nos
 4000036B  E1		     1		db	0e0h or (1 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 4000036C  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 4000036D  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000036F  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000370  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000371  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000372  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000374  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000375  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000376  F6		     2		db	0f6h

				;   OVER	( w1 w2 -- w1 w2 w1 )
				;		Copy second stack item to top.

						$CODE	4,'OVER',OVER
			     1		ALIGN	4				
 40000378		     1	OVER:						
 40000378 = 40000378	     1		_CODE	= $				
 = 00000001		     1		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F9FC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9FC  40000378 R	     1		DD	 _CODE,_LINK			
	   4001FA14 R
 4001FA04 = 4001FA04	     1		_LINK	= $				
 4001FA04  04 4F 56 45 52    1		DB	4,'OVER'			
			     1	ORG	_CODE					
						ldl	spx			; point to stack
 40000378  75		     1		db	070h or (spx and 00fh)
						ldnl	1			; get nos
 40000379  31		     1		db	030h or (1 and 00fh)
						pushx				; push another copy
			     1		ldl	spx		;; sp				  1
 4000037A  75		     2		db	070h or (spx and 00fh)
 4000037B  60 8C	     1		db	060h,08ch	
			     1		stl	spx		;;				  1
 4000037D  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldl	spx		;;				  1
 4000037E  75		     2		db	070h or (spx and 00fh)
			     1		stnl	0		;; (sp) = n			  1
 4000037F  E0		     2		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000380  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000381  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 40000383  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 40000384  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 40000385  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 40000386  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 40000388  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000389  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 4000038A  F6		     2		db	0f6h

				;   0<		( n -- t )
				;		Return true if n is negative.

						$CODE	2,'0<',ZLESS
			     1		ALIGN	4				
 4000038C		     1	ZLESS:						
 4000038C = 4000038C	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F9F0		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9F0  4000038C R	     1		DD	 _CODE,_LINK			
	   4001FA04 R
 4001F9F8 = 4001F9F8	     1		_LINK	= $				
 4001F9F8  02 30 3C	     1		DB	2,'0<'			
			     1	ORG	_CODE					
						ldl	spx			; access the stack
 4000038C  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get value
 4000038D  30		     1		db	030h or (0 and 00fh)
						mint				; $8000.0000
 4000038E  24 F2	     1		db	024h,0f2h
						andx				; sign bit
 40000390  24 F6	     1		db	024h,0f6h
						eqc	0			; true if 0 or +
 40000392  C0		     1		db	0c0h or (0 and 00fh)
						notx				; flip it
 40000393  23 F2	     1		db	023h,0f2h
						ldl	spx			;
 40000395  75		     1		db	070h or (spx and 00fh)
						stnl	0			;
 40000396  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 40000397  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 40000398  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 4000039A  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 4000039B  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 4000039C  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 4000039D  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 4000039F  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400003A0  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400003A1  F6		     2		db	0f6h

				;   AND 	( w w -- w )
				;		Bitwise AND.

						$CODE	3,'AND',ANDD
			     1		ALIGN	4				
 400003A4		     1	ANDD:						
 400003A4 = 400003A4	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F9E4		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9E4  400003A4 R	     1		DD	 _CODE,_LINK			
	   4001F9F8 R
 4001F9EC = 4001F9EC	     1		_LINK	= $				
 4001F9EC  03 41 4E 44	     1		DB	3,'AND'			
			     1	ORG	_CODE					
						popx				; get 1 parm
			     1		ldl	spx		;; fetch sp			  1
 400003A4  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 400003A5  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 400003A7  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 400003A8  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 400003A9  30		     2		db	030h or (0 and 00fh)
						ldl	spx			;
 400003AA  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get 2nd parm
 400003AB  30		     1		db	030h or (0 and 00fh)
						andx				; do bitwise and
 400003AC  24 F6	     1		db	024h,0f6h
						ldl	spx			;
 400003AE  75		     1		db	070h or (spx and 00fh)
						stnl	0			; result to tos
 400003AF  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400003B0  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400003B1  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400003B3  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400003B4  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400003B5  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400003B6  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400003B8  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400003B9  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400003BA  F6		     2		db	0f6h

				;   OR		( w w -- w )
				;		Bitwise inclusive OR.

						$CODE	2,'OR',ORR
			     1		ALIGN	4				
 400003BC		     1	ORR:						
 400003BC = 400003BC	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F9D8		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9D8  400003BC R	     1		DD	 _CODE,_LINK			
	   4001F9EC R
 4001F9E0 = 4001F9E0	     1		_LINK	= $				
 4001F9E0  02 4F 52	     1		DB	2,'OR'			
			     1	ORG	_CODE					
						popx				; get 1 parm
			     1		ldl	spx		;; fetch sp			  1
 400003BC  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 400003BD  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 400003BF  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 400003C0  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 400003C1  30		     2		db	030h or (0 and 00fh)
						ldl	spx			;
 400003C2  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get 2nd parm
 400003C3  30		     1		db	030h or (0 and 00fh)
						orx				; do bitwise or
 400003C4  24 FB	     1		db	024h,0fbh
						ldl	spx			;
 400003C6  75		     1		db	070h or (spx and 00fh)
						stnl	0			; result to tos
 400003C7  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400003C8  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400003C9  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400003CB  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400003CC  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400003CD  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400003CE  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400003D0  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400003D1  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400003D2  F6		     2		db	0f6h

				;   XOR 	( w w -- w )
				;		Bitwise exclusive OR.

						$CODE	3,'XOR',XORR
			     1		ALIGN	4				
 400003D4		     1	XORR:						
 400003D4 = 400003D4	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F9CC		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9CC  400003D4 R	     1		DD	 _CODE,_LINK			
	   4001F9E0 R
 4001F9D4 = 4001F9D4	     1		_LINK	= $				
 4001F9D4  03 58 4F 52	     1		DB	3,'XOR'			
			     1	ORG	_CODE					
						popx				; get 1 parm
			     1		ldl	spx		;; fetch sp			  1
 400003D4  75		     2		db	070h or (spx and 00fh)
			     1		dupx			;; extra copy for fetch 	  2
 400003D5  25 FA	     2		db	025h,0fah
			     1		adcx	4		;; bump up 1 level		  1
 400003D7  84		     2		db	080h or (4 and 00fh)
			     1		stl	spx		;; save it			  1
 400003D8  D5		     2		db	0d0h or (spx and 00fh)
			     1		ldnl	0		;; get previous tos		  1
 400003D9  30		     2		db	030h or (0 and 00fh)
						ldl	spx			;
 400003DA  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get 2nd parm
 400003DB  30		     1		db	030h or (0 and 00fh)
						xorx				; do bitwise xor
 400003DC  23 F3	     1		db	023h,0f3h
						ldl	spx			;
 400003DE  75		     1		db	070h or (spx and 00fh)
						stnl	0			; result to tos
 400003DF  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400003E0  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400003E1  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400003E3  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400003E4  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400003E5  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400003E6  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400003E8  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 400003E9  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 400003EA  F6		     2		db	0f6h

				;   UM+ 	( w w -- w cy )
				;		Add two numbers, return the sum and carry flag.

						$CODE	3,'UM+',UPLUS
			     1		ALIGN	4				
 400003EC		     1	UPLUS:						
 400003EC = 400003EC	     1		_CODE	= $				
 = 00000000		     1		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F9C0		     1		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     1	ORG	_NAME					
 4001F9C0  400003EC R	     1		DD	 _CODE,_LINK			
	   4001F9D4 R
 4001F9C8 = 4001F9C8	     1		_LINK	= $				
 4001F9C8  03 55 4D 2B	     1		DB	3,'UM+'			
			     1	ORG	_CODE					
						ldc	0			; no carry in
 400003EC  40		     1		db	040h or (0 and 00fh)
						ldl	spx
 400003ED  75		     1		db	070h or (spx and 00fh)
						ldnl	0			; get one operand from tos
 400003EE  30		     1		db	030h or (0 and 00fh)
						ldl	spx
 400003EF  75		     1		db	070h or (spx and 00fh)
						ldnl	1			; get second operand from nos
 400003F0  31		     1		db	030h or (1 and 00fh)
 400003F1  23 F7				db	023h,0f7h		; do a long sum
						ldl	spx
 400003F3  75		     1		db	070h or (spx and 00fh)
						stnl	1			; store sum at nos
 400003F4  E1		     1		db	0e0h or (1 and 00fh)
						ldl	spx
 400003F5  75		     1		db	070h or (spx and 00fh)
						stnl	0			; store cy at tos
 400003F6  E0		     1		db	0e0h or (0 and 00fh)
						$NEXT
			     1		ldl	ip			;; get ip		  1
 400003F7  76		     2		db	070h or (ip and 00fh)
			     1		dupx				;;			  2
 400003F8  25 FA	     2		db	025h,0fah
			     1		adcx	4			;; bump it one cell	  1
 400003FA  84		     2		db	080h or (4 and 00fh)
			     1		stl	ip			;; and save it back	  1
 400003FB  D6		     2		db	0d0h or (ip and 00fh)
			     1		ldnl	0			;; get orig (ip)	  1
 400003FC  30		     2		db	030h or (0 and 00fh)
			     1		dupx				;; it points to cfa	  2
 400003FD  25 FA	     2		db	025h,0fah
			     1		stl	w			;; save it		  1
 400003FF  D4		     2		db	0d0h or (w and 00fh)
			     1		ldnl	0			;; get the code address   1
 40000400  30		     2		db	030h or (0 and 00fh)
			     1		gcall				;; and jump to it	  1
 40000401  F6		     2		db	0f6h

				;; System and user variables

				;   doVAR	( -- a )
				;		Run time routine for VARIABLE and CREATE.

						$COLON	COMPO+5,'doVAR',DOVAR
			     1		$CODE	COMPO+5,'doVAR',DOVAR
			     2		ALIGN	4				
 40000404		     2	DOVAR:						
 40000404 = 40000404	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (COMPO+5 AND 01FH)/CELLL		
 = 4001F9B0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F9B0  40000404 R	     2		DD	 _CODE,_LINK			
	   4001F9C8 R
 4001F9B8 = 4001F9B8	     2		_LINK	= $				
 4001F9B8  45 64 6F 56 41    2		DB	COMPO+5,'doVAR'			
	   52
			     2	ORG	_CODE					
			     1		align	4
 40000404  48		     1		db	048h		
 40000405  21 FB	     1		db	021h,0fbh	
 40000407  25 FA	     1		db	025h,0fah	
 40000409  84		     1		db	084h		
 4000040A  F0		     1		db	0f0h		
 4000040B  30		     1		db	030h		
 4000040C  F6		     1		db	0f6h		
 4000040D  00 00 00	     1		db	0,0,0
 40000410  400001C0 R	     1		dd	DOLST
 40000414  400002D4 R				DD	RFROM,EXIT
	   400001D4 R

				;   UP		( -- a )
				;		Pointer to the user area.

						$COLON	2,'UP',UP
			     1		$CODE	2,'UP',UP
			     2		ALIGN	4				
 4000041C		     2	UP:						
 4000041C = 4000041C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F9A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F9A4  4000041C R	     2		DD	 _CODE,_LINK			
	   4001F9B8 R
 4001F9AC = 4001F9AC	     2		_LINK	= $				
 4001F9AC  02 55 50	     2		DB	2,'UP'			
			     2	ORG	_CODE					
			     1		align	4
 4000041C  48		     1		db	048h		
 4000041D  21 FB	     1		db	021h,0fbh	
 4000041F  25 FA	     1		db	025h,0fah	
 40000421  84		     1		db	084h		
 40000422  F0		     1		db	0f0h		
 40000423  30		     1		db	030h		
 40000424  F6		     1		db	0f6h		
 40000425  00 00 00	     1		db	0,0,0
 40000428  400001C0 R	     1		dd	DOLST
 4000042C  40000404 R				DD	DOVAR
 40000430  4001FB7C				DD	UPP

				;   doUSER	( -- a )
				;		Run time routine for user variables.

						$COLON	COMPO+6,'doUSER',DOUSE
			     1		$CODE	COMPO+6,'doUSER',DOUSE
			     2		ALIGN	4				
 40000434		     2	DOUSE:						
 40000434 = 40000434	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (COMPO+6 AND 01FH)/CELLL		
 = 4001F994		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F994  40000434 R	     2		DD	 _CODE,_LINK			
	   4001F9AC R
 4001F99C = 4001F99C	     2		_LINK	= $				
 4001F99C  46 64 6F 55 53    2		DB	COMPO+6,'doUSER'			
	   45 52
			     2	ORG	_CODE					
			     1		align	4
 40000434  48		     1		db	048h		
 40000435  21 FB	     1		db	021h,0fbh	
 40000437  25 FA	     1		db	025h,0fah	
 40000439  84		     1		db	084h		
 4000043A  F0		     1		db	0f0h		
 4000043B  30		     1		db	030h		
 4000043C  F6		     1		db	0f6h		
 4000043D  00 00 00	     1		db	0,0,0
 40000440  400001C0 R	     1		dd	DOLST
 40000444  400002D4 R				DD	RFROM,AT,UP,AT,PLUS,EXIT
	   40000270 R
	   4000041C R
	   40000270 R
	   40000740 R
	   400001D4 R

				;   SP0 	( -- a )
				;		Pointer to bottom of the data stack.

						$USER	3,'SP0',SZERO
			     1		$CODE	3,'SP0',SZERO
			     2		ALIGN	4				
 4000045C		     2	SZERO:						
 4000045C = 4000045C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F988		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F988  4000045C R	     2		DD	 _CODE,_LINK			
	   4001F99C R
 4001F990 = 4001F990	     2		_LINK	= $				
 4001F990  03 53 50 30	     2		DB	3,'SP0'			
			     2	ORG	_CODE					
			     1		align	4
 4000045C  48		     1		db	048h		
 4000045D  21 FB	     1		db	021h,0fbh	
 4000045F  25 FA	     1		db	025h,0fah	
 40000461  84		     1		db	084h		
 40000462  F0		     1		db	0f0h		
 40000463  30		     1		db	030h		
 40000464  F6		     1		db	0f6h		
 40000465  00 00 00	     1		db	0,0,0
 40000468  400001C0 R	     1		dd	DOLST
 4000046C  40000434 R	     1		DD	DOUSE,_USER			
	   00000010
 = 00000014		     1		_USER	= _USER+CELLL			

				;   RP0 	( -- a )
				;		Pointer to bottom of the return stack.

						$USER	3,'RP0',RZERO
			     1		$CODE	3,'RP0',RZERO
			     2		ALIGN	4				
 40000474		     2	RZERO:						
 40000474 = 40000474	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F97C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F97C  40000474 R	     2		DD	 _CODE,_LINK			
	   4001F990 R
 4001F984 = 4001F984	     2		_LINK	= $				
 4001F984  03 52 50 30	     2		DB	3,'RP0'			
			     2	ORG	_CODE					
			     1		align	4
 40000474  48		     1		db	048h		
 40000475  21 FB	     1		db	021h,0fbh	
 40000477  25 FA	     1		db	025h,0fah	
 40000479  84		     1		db	084h		
 4000047A  F0		     1		db	0f0h		
 4000047B  30		     1		db	030h		
 4000047C  F6		     1		db	0f6h		
 4000047D  00 00 00	     1		db	0,0,0
 40000480  400001C0 R	     1		dd	DOLST
 40000484  40000434 R	     1		DD	DOUSE,_USER			
	   00000014
 = 00000018		     1		_USER	= _USER+CELLL			

				;   '?KEY       ( -- a )
				;		Execution vector of ?KEY.

						$USER	5,"'?KEY",TQKEY
			     1		$CODE	5,"'?KEY",TQKEY
			     2		ALIGN	4				
 4000048C		     2	TQKEY:						
 4000048C = 4000048C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F96C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F96C  4000048C R	     2		DD	 _CODE,_LINK			
	   4001F984 R
 4001F974 = 4001F974	     2		_LINK	= $				
 4001F974  05 27 3F 4B 45    2		DB	5,"'?KEY"			
	   59
			     2	ORG	_CODE					
			     1		align	4
 4000048C  48		     1		db	048h		
 4000048D  21 FB	     1		db	021h,0fbh	
 4000048F  25 FA	     1		db	025h,0fah	
 40000491  84		     1		db	084h		
 40000492  F0		     1		db	0f0h		
 40000493  30		     1		db	030h		
 40000494  F6		     1		db	0f6h		
 40000495  00 00 00	     1		db	0,0,0
 40000498  400001C0 R	     1		dd	DOLST
 4000049C  40000434 R	     1		DD	DOUSE,_USER			
	   00000018
 = 0000001C		     1		_USER	= _USER+CELLL			

				;   'EMIT       ( -- a )
				;		Execution vector of EMIT.

						$USER	5,"'EMIT",TEMIT
			     1		$CODE	5,"'EMIT",TEMIT
			     2		ALIGN	4				
 400004A4		     2	TEMIT:						
 400004A4 = 400004A4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F95C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F95C  400004A4 R	     2		DD	 _CODE,_LINK			
	   4001F974 R
 4001F964 = 4001F964	     2		_LINK	= $				
 4001F964  05 27 45 4D 49    2		DB	5,"'EMIT"			
	   54
			     2	ORG	_CODE					
			     1		align	4
 400004A4  48		     1		db	048h		
 400004A5  21 FB	     1		db	021h,0fbh	
 400004A7  25 FA	     1		db	025h,0fah	
 400004A9  84		     1		db	084h		
 400004AA  F0		     1		db	0f0h		
 400004AB  30		     1		db	030h		
 400004AC  F6		     1		db	0f6h		
 400004AD  00 00 00	     1		db	0,0,0
 400004B0  400001C0 R	     1		dd	DOLST
 400004B4  40000434 R	     1		DD	DOUSE,_USER			
	   0000001C
 = 00000020		     1		_USER	= _USER+CELLL			

				;   'EXPECT     ( -- a )
				;		Execution vector of EXPECT.

						$USER	7,"'EXPECT",TEXPE
			     1		$CODE	7,"'EXPECT",TEXPE
			     2		ALIGN	4				
 400004BC		     2	TEXPE:						
 400004BC = 400004BC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F94C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F94C  400004BC R	     2		DD	 _CODE,_LINK			
	   4001F964 R
 4001F954 = 4001F954	     2		_LINK	= $				
 4001F954  07 27 45 58 50    2		DB	7,"'EXPECT"			
	   45 43 54
			     2	ORG	_CODE					
			     1		align	4
 400004BC  48		     1		db	048h		
 400004BD  21 FB	     1		db	021h,0fbh	
 400004BF  25 FA	     1		db	025h,0fah	
 400004C1  84		     1		db	084h		
 400004C2  F0		     1		db	0f0h		
 400004C3  30		     1		db	030h		
 400004C4  F6		     1		db	0f6h		
 400004C5  00 00 00	     1		db	0,0,0
 400004C8  400001C0 R	     1		dd	DOLST
 400004CC  40000434 R	     1		DD	DOUSE,_USER			
	   00000020
 = 00000024		     1		_USER	= _USER+CELLL			

				;   'TAP        ( -- a )
				;		Execution vector of TAP.

						$USER	4,"'TAP",TTAP
			     1		$CODE	4,"'TAP",TTAP
			     2		ALIGN	4				
 400004D4		     2	TTAP:						
 400004D4 = 400004D4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F93C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F93C  400004D4 R	     2		DD	 _CODE,_LINK			
	   4001F954 R
 4001F944 = 4001F944	     2		_LINK	= $				
 4001F944  04 27 54 41 50    2		DB	4,"'TAP"			
			     2	ORG	_CODE					
			     1		align	4
 400004D4  48		     1		db	048h		
 400004D5  21 FB	     1		db	021h,0fbh	
 400004D7  25 FA	     1		db	025h,0fah	
 400004D9  84		     1		db	084h		
 400004DA  F0		     1		db	0f0h		
 400004DB  30		     1		db	030h		
 400004DC  F6		     1		db	0f6h		
 400004DD  00 00 00	     1		db	0,0,0
 400004E0  400001C0 R	     1		dd	DOLST
 400004E4  40000434 R	     1		DD	DOUSE,_USER			
	   00000024
 = 00000028		     1		_USER	= _USER+CELLL			

				;   'ECHO       ( -- a )
				;		Execution vector of ECHO.

						$USER	5,"'ECHO",TECHO
			     1		$CODE	5,"'ECHO",TECHO
			     2		ALIGN	4				
 400004EC		     2	TECHO:						
 400004EC = 400004EC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F92C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F92C  400004EC R	     2		DD	 _CODE,_LINK			
	   4001F944 R
 4001F934 = 4001F934	     2		_LINK	= $				
 4001F934  05 27 45 43 48    2		DB	5,"'ECHO"			
	   4F
			     2	ORG	_CODE					
			     1		align	4
 400004EC  48		     1		db	048h		
 400004ED  21 FB	     1		db	021h,0fbh	
 400004EF  25 FA	     1		db	025h,0fah	
 400004F1  84		     1		db	084h		
 400004F2  F0		     1		db	0f0h		
 400004F3  30		     1		db	030h		
 400004F4  F6		     1		db	0f6h		
 400004F5  00 00 00	     1		db	0,0,0
 400004F8  400001C0 R	     1		dd	DOLST
 400004FC  40000434 R	     1		DD	DOUSE,_USER			
	   00000028
 = 0000002C		     1		_USER	= _USER+CELLL			

				;   'PROMPT     ( -- a )
				;		Execution vector of PROMPT.

						$USER	7,"'PROMPT",TPROM
			     1		$CODE	7,"'PROMPT",TPROM
			     2		ALIGN	4				
 40000504		     2	TPROM:						
 40000504 = 40000504	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F91C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F91C  40000504 R	     2		DD	 _CODE,_LINK			
	   4001F934 R
 4001F924 = 4001F924	     2		_LINK	= $				
 4001F924  07 27 50 52 4F    2		DB	7,"'PROMPT"			
	   4D 50 54
			     2	ORG	_CODE					
			     1		align	4
 40000504  48		     1		db	048h		
 40000505  21 FB	     1		db	021h,0fbh	
 40000507  25 FA	     1		db	025h,0fah	
 40000509  84		     1		db	084h		
 4000050A  F0		     1		db	0f0h		
 4000050B  30		     1		db	030h		
 4000050C  F6		     1		db	0f6h		
 4000050D  00 00 00	     1		db	0,0,0
 40000510  400001C0 R	     1		dd	DOLST
 40000514  40000434 R	     1		DD	DOUSE,_USER			
	   0000002C
 = 00000030		     1		_USER	= _USER+CELLL			

				;   BASE	( -- a )
				;		Storage of the radix base for numeric I/O.

						$USER	4,'BASE',BASE
			     1		$CODE	4,'BASE',BASE
			     2		ALIGN	4				
 4000051C		     2	BASE:						
 4000051C = 4000051C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F90C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F90C  4000051C R	     2		DD	 _CODE,_LINK			
	   4001F924 R
 4001F914 = 4001F914	     2		_LINK	= $				
 4001F914  04 42 41 53 45    2		DB	4,'BASE'			
			     2	ORG	_CODE					
			     1		align	4
 4000051C  48		     1		db	048h		
 4000051D  21 FB	     1		db	021h,0fbh	
 4000051F  25 FA	     1		db	025h,0fah	
 40000521  84		     1		db	084h		
 40000522  F0		     1		db	0f0h		
 40000523  30		     1		db	030h		
 40000524  F6		     1		db	0f6h		
 40000525  00 00 00	     1		db	0,0,0
 40000528  400001C0 R	     1		dd	DOLST
 4000052C  40000434 R	     1		DD	DOUSE,_USER			
	   00000030
 = 00000034		     1		_USER	= _USER+CELLL			

				;   tmp 	( -- a )
				;		A temporary storage location used in parse and find.

						$USER	COMPO+3,'tmp',TEMP
			     1		$CODE	COMPO+3,'tmp',TEMP
			     2		ALIGN	4				
 40000534		     2	TEMP:						
 40000534 = 40000534	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001F900		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F900  40000534 R	     2		DD	 _CODE,_LINK			
	   4001F914 R
 4001F908 = 4001F908	     2		_LINK	= $				
 4001F908  43 74 6D 70	     2		DB	COMPO+3,'tmp'			
			     2	ORG	_CODE					
			     1		align	4
 40000534  48		     1		db	048h		
 40000535  21 FB	     1		db	021h,0fbh	
 40000537  25 FA	     1		db	025h,0fah	
 40000539  84		     1		db	084h		
 4000053A  F0		     1		db	0f0h		
 4000053B  30		     1		db	030h		
 4000053C  F6		     1		db	0f6h		
 4000053D  00 00 00	     1		db	0,0,0
 40000540  400001C0 R	     1		dd	DOLST
 40000544  40000434 R	     1		DD	DOUSE,_USER			
	   00000034
 = 00000038		     1		_USER	= _USER+CELLL			

				;   SPAN	( -- a )
				;		Hold character count received by EXPECT.

						$USER	4,'SPAN',SPAN
			     1		$CODE	4,'SPAN',SPAN
			     2		ALIGN	4				
 4000054C		     2	SPAN:						
 4000054C = 4000054C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F8F0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8F0  4000054C R	     2		DD	 _CODE,_LINK			
	   4001F908 R
 4001F8F8 = 4001F8F8	     2		_LINK	= $				
 4001F8F8  04 53 50 41 4E    2		DB	4,'SPAN'			
			     2	ORG	_CODE					
			     1		align	4
 4000054C  48		     1		db	048h		
 4000054D  21 FB	     1		db	021h,0fbh	
 4000054F  25 FA	     1		db	025h,0fah	
 40000551  84		     1		db	084h		
 40000552  F0		     1		db	0f0h		
 40000553  30		     1		db	030h		
 40000554  F6		     1		db	0f6h		
 40000555  00 00 00	     1		db	0,0,0
 40000558  400001C0 R	     1		dd	DOLST
 4000055C  40000434 R	     1		DD	DOUSE,_USER			
	   00000038
 = 0000003C		     1		_USER	= _USER+CELLL			

				;   >IN 	( -- a )
				;		Hold the character pointer while parsing input stream.

						$USER	3,'>IN',INN
			     1		$CODE	3,'>IN',INN
			     2		ALIGN	4				
 40000564		     2	INN:						
 40000564 = 40000564	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F8E4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8E4  40000564 R	     2		DD	 _CODE,_LINK			
	   4001F8F8 R
 4001F8EC = 4001F8EC	     2		_LINK	= $				
 4001F8EC  03 3E 49 4E	     2		DB	3,'>IN'			
			     2	ORG	_CODE					
			     1		align	4
 40000564  48		     1		db	048h		
 40000565  21 FB	     1		db	021h,0fbh	
 40000567  25 FA	     1		db	025h,0fah	
 40000569  84		     1		db	084h		
 4000056A  F0		     1		db	0f0h		
 4000056B  30		     1		db	030h		
 4000056C  F6		     1		db	0f6h		
 4000056D  00 00 00	     1		db	0,0,0
 40000570  400001C0 R	     1		dd	DOLST
 40000574  40000434 R	     1		DD	DOUSE,_USER			
	   0000003C
 = 00000040		     1		_USER	= _USER+CELLL			

				;   #TIB	( -- a )
				;		Hold the current count and address of the terminal input buffer.

						$USER	4,'#TIB',NTIB
			     1		$CODE	4,'#TIB',NTIB
			     2		ALIGN	4				
 4000057C		     2	NTIB:						
 4000057C = 4000057C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F8D4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8D4  4000057C R	     2		DD	 _CODE,_LINK			
	   4001F8EC R
 4001F8DC = 4001F8DC	     2		_LINK	= $				
 4001F8DC  04 23 54 49 42    2		DB	4,'#TIB'			
			     2	ORG	_CODE					
			     1		align	4
 4000057C  48		     1		db	048h		
 4000057D  21 FB	     1		db	021h,0fbh	
 4000057F  25 FA	     1		db	025h,0fah	
 40000581  84		     1		db	084h		
 40000582  F0		     1		db	0f0h		
 40000583  30		     1		db	030h		
 40000584  F6		     1		db	0f6h		
 40000585  00 00 00	     1		db	0,0,0
 40000588  400001C0 R	     1		dd	DOLST
 4000058C  40000434 R	     1		DD	DOUSE,_USER			
	   00000040
 = 00000044		     1		_USER	= _USER+CELLL			
 = 00000048					_USER = _USER+CELLL

				;   CSP 	( -- a )
				;		Hold the stack pointer for error checking.

						$USER	3,'CSP',CSP
			     1		$CODE	3,'CSP',CSP
			     2		ALIGN	4				
 40000594		     2	CSP:						
 40000594 = 40000594	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F8C8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8C8  40000594 R	     2		DD	 _CODE,_LINK			
	   4001F8DC R
 4001F8D0 = 4001F8D0	     2		_LINK	= $				
 4001F8D0  03 43 53 50	     2		DB	3,'CSP'			
			     2	ORG	_CODE					
			     1		align	4
 40000594  48		     1		db	048h		
 40000595  21 FB	     1		db	021h,0fbh	
 40000597  25 FA	     1		db	025h,0fah	
 40000599  84		     1		db	084h		
 4000059A  F0		     1		db	0f0h		
 4000059B  30		     1		db	030h		
 4000059C  F6		     1		db	0f6h		
 4000059D  00 00 00	     1		db	0,0,0
 400005A0  400001C0 R	     1		dd	DOLST
 400005A4  40000434 R	     1		DD	DOUSE,_USER			
	   00000048
 = 0000004C		     1		_USER	= _USER+CELLL			

				;   'EVAL       ( -- a )
				;		Execution vector of EVAL.

						$USER	5,"'EVAL",TEVAL
			     1		$CODE	5,"'EVAL",TEVAL
			     2		ALIGN	4				
 400005AC		     2	TEVAL:						
 400005AC = 400005AC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F8B8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8B8  400005AC R	     2		DD	 _CODE,_LINK			
	   4001F8D0 R
 4001F8C0 = 4001F8C0	     2		_LINK	= $				
 4001F8C0  05 27 45 56 41    2		DB	5,"'EVAL"			
	   4C
			     2	ORG	_CODE					
			     1		align	4
 400005AC  48		     1		db	048h		
 400005AD  21 FB	     1		db	021h,0fbh	
 400005AF  25 FA	     1		db	025h,0fah	
 400005B1  84		     1		db	084h		
 400005B2  F0		     1		db	0f0h		
 400005B3  30		     1		db	030h		
 400005B4  F6		     1		db	0f6h		
 400005B5  00 00 00	     1		db	0,0,0
 400005B8  400001C0 R	     1		dd	DOLST
 400005BC  40000434 R	     1		DD	DOUSE,_USER			
	   0000004C
 = 00000050		     1		_USER	= _USER+CELLL			

				;   'NUMBER     ( -- a )
				;		Execution vector of NUMBER?.

						$USER	7,"'NUMBER",TNUMB
			     1		$CODE	7,"'NUMBER",TNUMB
			     2		ALIGN	4				
 400005C4		     2	TNUMB:						
 400005C4 = 400005C4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F8A8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F8A8  400005C4 R	     2		DD	 _CODE,_LINK			
	   4001F8C0 R
 4001F8B0 = 4001F8B0	     2		_LINK	= $				
 4001F8B0  07 27 4E 55 4D    2		DB	7,"'NUMBER"			
	   42 45 52
			     2	ORG	_CODE					
			     1		align	4
 400005C4  48		     1		db	048h		
 400005C5  21 FB	     1		db	021h,0fbh	
 400005C7  25 FA	     1		db	025h,0fah	
 400005C9  84		     1		db	084h		
 400005CA  F0		     1		db	0f0h		
 400005CB  30		     1		db	030h		
 400005CC  F6		     1		db	0f6h		
 400005CD  00 00 00	     1		db	0,0,0
 400005D0  400001C0 R	     1		dd	DOLST
 400005D4  40000434 R	     1		DD	DOUSE,_USER			
	   00000050
 = 00000054		     1		_USER	= _USER+CELLL			

				;   HLD 	( -- a )
				;		Hold a pointer in building a numeric output string.

						$USER	3,'HLD',HLD
			     1		$CODE	3,'HLD',HLD
			     2		ALIGN	4				
 400005DC		     2	HLD:						
 400005DC = 400005DC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F89C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F89C  400005DC R	     2		DD	 _CODE,_LINK			
	   4001F8B0 R
 4001F8A4 = 4001F8A4	     2		_LINK	= $				
 4001F8A4  03 48 4C 44	     2		DB	3,'HLD'			
			     2	ORG	_CODE					
			     1		align	4
 400005DC  48		     1		db	048h		
 400005DD  21 FB	     1		db	021h,0fbh	
 400005DF  25 FA	     1		db	025h,0fah	
 400005E1  84		     1		db	084h		
 400005E2  F0		     1		db	0f0h		
 400005E3  30		     1		db	030h		
 400005E4  F6		     1		db	0f6h		
 400005E5  00 00 00	     1		db	0,0,0
 400005E8  400001C0 R	     1		dd	DOLST
 400005EC  40000434 R	     1		DD	DOUSE,_USER			
	   00000054
 = 00000058		     1		_USER	= _USER+CELLL			

				;   HANDLER	( -- a )
				;		Hold the return stack pointer for error handling.

						$USER	7,'HANDLER',HANDL
			     1		$CODE	7,'HANDLER',HANDL
			     2		ALIGN	4				
 400005F4		     2	HANDL:						
 400005F4 = 400005F4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F88C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F88C  400005F4 R	     2		DD	 _CODE,_LINK			
	   4001F8A4 R
 4001F894 = 4001F894	     2		_LINK	= $				
 4001F894  07 48 41 4E 44    2		DB	7,'HANDLER'			
	   4C 45 52
			     2	ORG	_CODE					
			     1		align	4
 400005F4  48		     1		db	048h		
 400005F5  21 FB	     1		db	021h,0fbh	
 400005F7  25 FA	     1		db	025h,0fah	
 400005F9  84		     1		db	084h		
 400005FA  F0		     1		db	0f0h		
 400005FB  30		     1		db	030h		
 400005FC  F6		     1		db	0f6h		
 400005FD  00 00 00	     1		db	0,0,0
 40000600  400001C0 R	     1		dd	DOLST
 40000604  40000434 R	     1		DD	DOUSE,_USER			
	   00000058
 = 0000005C		     1		_USER	= _USER+CELLL			

				;   CONTEXT	( -- a )
				;		A area to specify vocabulary search order.

						$USER	7,'CONTEXT',CNTXT
			     1		$CODE	7,'CONTEXT',CNTXT
			     2		ALIGN	4				
 4000060C		     2	CNTXT:						
 4000060C = 4000060C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F87C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F87C  4000060C R	     2		DD	 _CODE,_LINK			
	   4001F894 R
 4001F884 = 4001F884	     2		_LINK	= $				
 4001F884  07 43 4F 4E 54    2		DB	7,'CONTEXT'			
	   45 58 54
			     2	ORG	_CODE					
			     1		align	4
 4000060C  48		     1		db	048h		
 4000060D  21 FB	     1		db	021h,0fbh	
 4000060F  25 FA	     1		db	025h,0fah	
 40000611  84		     1		db	084h		
 40000612  F0		     1		db	0f0h		
 40000613  30		     1		db	030h		
 40000614  F6		     1		db	0f6h		
 40000615  00 00 00	     1		db	0,0,0
 40000618  400001C0 R	     1		dd	DOLST
 4000061C  40000434 R	     1		DD	DOUSE,_USER			
	   0000005C
 = 00000060		     1		_USER	= _USER+CELLL			
 = 00000080					_USER = _USER+VOCSS*CELLL	;vocabulary stack

				;   CURRENT	( -- a )
				;		Point to the vocabulary to be extended.

						$USER	7,'CURRENT',CRRNT
			     1		$CODE	7,'CURRENT',CRRNT
			     2		ALIGN	4				
 40000624		     2	CRRNT:						
 40000624 = 40000624	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F86C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F86C  40000624 R	     2		DD	 _CODE,_LINK			
	   4001F884 R
 4001F874 = 4001F874	     2		_LINK	= $				
 4001F874  07 43 55 52 52    2		DB	7,'CURRENT'			
	   45 4E 54
			     2	ORG	_CODE					
			     1		align	4
 40000624  48		     1		db	048h		
 40000625  21 FB	     1		db	021h,0fbh	
 40000627  25 FA	     1		db	025h,0fah	
 40000629  84		     1		db	084h		
 4000062A  F0		     1		db	0f0h		
 4000062B  30		     1		db	030h		
 4000062C  F6		     1		db	0f6h		
 4000062D  00 00 00	     1		db	0,0,0
 40000630  400001C0 R	     1		dd	DOLST
 40000634  40000434 R	     1		DD	DOUSE,_USER			
	   00000080
 = 00000084		     1		_USER	= _USER+CELLL			
 = 00000088					_USER = _USER+CELLL		;vocabulary link pointer

				;   CP		( -- a )
				;		Point to the top of the code dictionary.

						$USER	2,'CP',CP
			     1		$CODE	2,'CP',CP
			     2		ALIGN	4				
 4000063C		     2	CP:						
 4000063C = 4000063C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F860		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F860  4000063C R	     2		DD	 _CODE,_LINK			
	   4001F874 R
 4001F868 = 4001F868	     2		_LINK	= $				
 4001F868  02 43 50	     2		DB	2,'CP'			
			     2	ORG	_CODE					
			     1		align	4
 4000063C  48		     1		db	048h		
 4000063D  21 FB	     1		db	021h,0fbh	
 4000063F  25 FA	     1		db	025h,0fah	
 40000641  84		     1		db	084h		
 40000642  F0		     1		db	0f0h		
 40000643  30		     1		db	030h		
 40000644  F6		     1		db	0f6h		
 40000645  00 00 00	     1		db	0,0,0
 40000648  400001C0 R	     1		dd	DOLST
 4000064C  40000434 R	     1		DD	DOUSE,_USER			
	   00000088
 = 0000008C		     1		_USER	= _USER+CELLL			

				;   NP		( -- a )
				;		Point to the bottom of the name dictionary.

						$USER	2,'NP',NP
			     1		$CODE	2,'NP',NP
			     2		ALIGN	4				
 40000654		     2	NP:						
 40000654 = 40000654	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F854		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F854  40000654 R	     2		DD	 _CODE,_LINK			
	   4001F868 R
 4001F85C = 4001F85C	     2		_LINK	= $				
 4001F85C  02 4E 50	     2		DB	2,'NP'			
			     2	ORG	_CODE					
			     1		align	4
 40000654  48		     1		db	048h		
 40000655  21 FB	     1		db	021h,0fbh	
 40000657  25 FA	     1		db	025h,0fah	
 40000659  84		     1		db	084h		
 4000065A  F0		     1		db	0f0h		
 4000065B  30		     1		db	030h		
 4000065C  F6		     1		db	0f6h		
 4000065D  00 00 00	     1		db	0,0,0
 40000660  400001C0 R	     1		dd	DOLST
 40000664  40000434 R	     1		DD	DOUSE,_USER			
	   0000008C
 = 00000090		     1		_USER	= _USER+CELLL			

				;   LAST	( -- a )
				;		Point to the last name in the name dictionary.

						$USER	4,'LAST',LAST
			     1		$CODE	4,'LAST',LAST
			     2		ALIGN	4				
 4000066C		     2	LAST:						
 4000066C = 4000066C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F844		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F844  4000066C R	     2		DD	 _CODE,_LINK			
	   4001F85C R
 4001F84C = 4001F84C	     2		_LINK	= $				
 4001F84C  04 4C 41 53 54    2		DB	4,'LAST'			
			     2	ORG	_CODE					
			     1		align	4
 4000066C  48		     1		db	048h		
 4000066D  21 FB	     1		db	021h,0fbh	
 4000066F  25 FA	     1		db	025h,0fah	
 40000671  84		     1		db	084h		
 40000672  F0		     1		db	0f0h		
 40000673  30		     1		db	030h		
 40000674  F6		     1		db	0f6h		
 40000675  00 00 00	     1		db	0,0,0
 40000678  400001C0 R	     1		dd	DOLST
 4000067C  40000434 R	     1		DD	DOUSE,_USER			
	   00000090
 = 00000094		     1		_USER	= _USER+CELLL			

				;; Common functions

				;   doVOC	( -- )
				;		Run time action of VOCABULARY's.

						$COLON	COMPO+5,'doVOC',DOVOC
			     1		$CODE	COMPO+5,'doVOC',DOVOC
			     2		ALIGN	4				
 40000684		     2	DOVOC:						
 40000684 = 40000684	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (COMPO+5 AND 01FH)/CELLL		
 = 4001F834		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F834  40000684 R	     2		DD	 _CODE,_LINK			
	   4001F84C R
 4001F83C = 4001F83C	     2		_LINK	= $				
 4001F83C  45 64 6F 56 4F    2		DB	COMPO+5,'doVOC'			
	   43
			     2	ORG	_CODE					
			     1		align	4
 40000684  48		     1		db	048h		
 40000685  21 FB	     1		db	021h,0fbh	
 40000687  25 FA	     1		db	025h,0fah	
 40000689  84		     1		db	084h		
 4000068A  F0		     1		db	0f0h		
 4000068B  30		     1		db	030h		
 4000068C  F6		     1		db	0f6h		
 4000068D  00 00 00	     1		db	0,0,0
 40000690  400001C0 R	     1		dd	DOLST
 40000694  400002D4 R				DD	RFROM,CNTXT,STORE,EXIT
	   4000060C R
	   40000254 R
	   400001D4 R

				;   FORTH	( -- )
				;		Make FORTH the context vocabulary.

						$COLON	5,'FORTH',FORTH
			     1		$CODE	5,'FORTH',FORTH
			     2		ALIGN	4				
 400006A4		     2	FORTH:						
 400006A4 = 400006A4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F824		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F824  400006A4 R	     2		DD	 _CODE,_LINK			
	   4001F83C R
 4001F82C = 4001F82C	     2		_LINK	= $				
 4001F82C  05 46 4F 52 54    2		DB	5,'FORTH'			
	   48
			     2	ORG	_CODE					
			     1		align	4
 400006A4  48		     1		db	048h		
 400006A5  21 FB	     1		db	021h,0fbh	
 400006A7  25 FA	     1		db	025h,0fah	
 400006A9  84		     1		db	084h		
 400006AA  F0		     1		db	0f0h		
 400006AB  30		     1		db	030h		
 400006AC  F6		     1		db	0f6h		
 400006AD  00 00 00	     1		db	0,0,0
 400006B0  400001C0 R	     1		dd	DOLST
 400006B4  40000684 R				DD	DOVOC
 400006B8  00000000				DD	0			;vocabulary head pointer
 400006BC  00000000				DD	0			;vocabulary link pointer

				;   ?DUP	( w -- w w | 0 )
				;		Dup tos if its is not zero.

						$COLON	4,'?DUP',QDUP
			     1		$CODE	4,'?DUP',QDUP
			     2		ALIGN	4				
 400006C0		     2	QDUP:						
 400006C0 = 400006C0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F814		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F814  400006C0 R	     2		DD	 _CODE,_LINK			
	   4001F82C R
 4001F81C = 4001F81C	     2		_LINK	= $				
 4001F81C  04 3F 44 55 50    2		DB	4,'?DUP'			
			     2	ORG	_CODE					
			     1		align	4
 400006C0  48		     1		db	048h		
 400006C1  21 FB	     1		db	021h,0fbh	
 400006C3  25 FA	     1		db	025h,0fah	
 400006C5  84		     1		db	084h		
 400006C6  F0		     1		db	0f0h		
 400006C7  30		     1		db	030h		
 400006C8  F6		     1		db	0f6h		
 400006C9  00 00 00	     1		db	0,0,0
 400006CC  400001C0 R	     1		dd	DOLST
 400006D0  40000350 R				DD	DUPP
 400006D4  40000220 R				DD	QBRAN,QDUP1
	   400006E0 R
 400006DC  40000350 R				DD	DUPP
 400006E0 400001D4 R		QDUP1:		DD	EXIT

				;   ROT 	( w1 w2 w3 -- w2 w3 w1 )
				;		Rot 3rd item to top.

						$COLON	3,'ROT',ROT
			     1		$CODE	3,'ROT',ROT
			     2		ALIGN	4				
 400006E4		     2	ROT:						
 400006E4 = 400006E4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F808		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F808  400006E4 R	     2		DD	 _CODE,_LINK			
	   4001F81C R
 4001F810 = 4001F810	     2		_LINK	= $				
 4001F810  03 52 4F 54	     2		DB	3,'ROT'			
			     2	ORG	_CODE					
			     1		align	4
 400006E4  48		     1		db	048h		
 400006E5  21 FB	     1		db	021h,0fbh	
 400006E7  25 FA	     1		db	025h,0fah	
 400006E9  84		     1		db	084h		
 400006EA  F0		     1		db	0f0h		
 400006EB  30		     1		db	030h		
 400006EC  F6		     1		db	0f6h		
 400006ED  00 00 00	     1		db	0,0,0
 400006F0  400001C0 R	     1		dd	DOLST
 400006F4  40000300 R				DD	TOR,SWAP,RFROM,SWAP,EXIT
	   40000364 R
	   400002D4 R
	   40000364 R
	   400001D4 R

				;   2DROP	( w w -- )
				;		Discard two items on stack.

						$COLON	5,'2DROP',DDROP
			     1		$CODE	5,'2DROP',DDROP
			     2		ALIGN	4				
 40000708		     2	DDROP:						
 40000708 = 40000708	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F7F8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7F8  40000708 R	     2		DD	 _CODE,_LINK			
	   4001F810 R
 4001F800 = 4001F800	     2		_LINK	= $				
 4001F800  05 32 44 52 4F    2		DB	5,'2DROP'			
	   50
			     2	ORG	_CODE					
			     1		align	4
 40000708  48		     1		db	048h		
 40000709  21 FB	     1		db	021h,0fbh	
 4000070B  25 FA	     1		db	025h,0fah	
 4000070D  84		     1		db	084h		
 4000070E  F0		     1		db	0f0h		
 4000070F  30		     1		db	030h		
 40000710  F6		     1		db	0f6h		
 40000711  00 00 00	     1		db	0,0,0
 40000714  400001C0 R	     1		dd	DOLST
 40000718  40000340 R				DD	DROP,DROP,EXIT
	   40000340 R
	   400001D4 R

				;   2DUP	( w1 w2 -- w1 w2 w1 w2 )
				;		Duplicate top two items.

						$COLON	4,'2DUP',DDUP
			     1		$CODE	4,'2DUP',DDUP
			     2		ALIGN	4				
 40000724		     2	DDUP:						
 40000724 = 40000724	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F7E8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7E8  40000724 R	     2		DD	 _CODE,_LINK			
	   4001F800 R
 4001F7F0 = 4001F7F0	     2		_LINK	= $				
 4001F7F0  04 32 44 55 50    2		DB	4,'2DUP'			
			     2	ORG	_CODE					
			     1		align	4
 40000724  48		     1		db	048h		
 40000725  21 FB	     1		db	021h,0fbh	
 40000727  25 FA	     1		db	025h,0fah	
 40000729  84		     1		db	084h		
 4000072A  F0		     1		db	0f0h		
 4000072B  30		     1		db	030h		
 4000072C  F6		     1		db	0f6h		
 4000072D  00 00 00	     1		db	0,0,0
 40000730  400001C0 R	     1		dd	DOLST
 40000734  40000378 R				DD	OVER,OVER,EXIT
	   40000378 R
	   400001D4 R

				;   +		( w w -- sum )
				;		Add top two items.

						$COLON	1,'+',PLUS
			     1		$CODE	1,'+',PLUS
			     2		ALIGN	4				
 40000740		     2	PLUS:						
 40000740 = 40000740	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F7DC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7DC  40000740 R	     2		DD	 _CODE,_LINK			
	   4001F7F0 R
 4001F7E4 = 4001F7E4	     2		_LINK	= $				
 4001F7E4  01 2B	     2		DB	1,'+'			
			     2	ORG	_CODE					
			     1		align	4
 40000740  48		     1		db	048h		
 40000741  21 FB	     1		db	021h,0fbh	
 40000743  25 FA	     1		db	025h,0fah	
 40000745  84		     1		db	084h		
 40000746  F0		     1		db	0f0h		
 40000747  30		     1		db	030h		
 40000748  F6		     1		db	0f6h		
 40000749  00 00 00	     1		db	0,0,0
 4000074C  400001C0 R	     1		dd	DOLST
 40000750  400003EC R				DD	UPLUS,DROP,EXIT
	   40000340 R
	   400001D4 R

				;   D+		( d d -- d )
				;		Double addition, as an example using UM+.
				;
				;		$COLON	2,'D+',DPLUS
				;		DD	TOR,SWAP,TOR,UPLUS
				;		DD	RFROM,RFROM,PLUS,PLUS,EXIT

				;   NOT 	( w -- w )
				;		One's complement of tos.

						$COLON	3,'NOT',INVER
			     1		$CODE	3,'NOT',INVER
			     2		ALIGN	4				
 4000075C		     2	INVER:						
 4000075C = 4000075C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F7D0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7D0  4000075C R	     2		DD	 _CODE,_LINK			
	   4001F7E4 R
 4001F7D8 = 4001F7D8	     2		_LINK	= $				
 4001F7D8  03 4E 4F 54	     2		DB	3,'NOT'			
			     2	ORG	_CODE					
			     1		align	4
 4000075C  48		     1		db	048h		
 4000075D  21 FB	     1		db	021h,0fbh	
 4000075F  25 FA	     1		db	025h,0fah	
 40000761  84		     1		db	084h		
 40000762  F0		     1		db	0f0h		
 40000763  30		     1		db	030h		
 40000764  F6		     1		db	0f6h		
 40000765  00 00 00	     1		db	0,0,0
 40000768  400001C0 R	     1		dd	DOLST
 4000076C  400001A8 R				DD	DOLIT,-1,XORR,EXIT
	   FFFFFFFF
	   400003D4 R
	   400001D4 R

				;   NEGATE	( n -- -n )
				;		Two's complement of tos.

						$COLON	6,'NEGATE',NEGAT
			     1		$CODE	6,'NEGATE',NEGAT
			     2		ALIGN	4				
 4000077C		     2	NEGAT:						
 4000077C = 4000077C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F7C0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7C0  4000077C R	     2		DD	 _CODE,_LINK			
	   4001F7D8 R
 4001F7C8 = 4001F7C8	     2		_LINK	= $				
 4001F7C8  06 4E 45 47 41    2		DB	6,'NEGATE'			
	   54 45
			     2	ORG	_CODE					
			     1		align	4
 4000077C  48		     1		db	048h		
 4000077D  21 FB	     1		db	021h,0fbh	
 4000077F  25 FA	     1		db	025h,0fah	
 40000781  84		     1		db	084h		
 40000782  F0		     1		db	0f0h		
 40000783  30		     1		db	030h		
 40000784  F6		     1		db	0f6h		
 40000785  00 00 00	     1		db	0,0,0
 40000788  400001C0 R	     1		dd	DOLST
 4000078C  4000075C R				DD	INVER,DOLIT,1,PLUS,EXIT
	   400001A8 R
	   00000001
	   40000740 R
	   400001D4 R

				;   DNEGATE	( d -- -d )
				;		Two's complement of top double.

						$COLON	7,'DNEGATE',DNEGA
			     1		$CODE	7,'DNEGATE',DNEGA
			     2		ALIGN	4				
 400007A0		     2	DNEGA:						
 400007A0 = 400007A0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F7B0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7B0  400007A0 R	     2		DD	 _CODE,_LINK			
	   4001F7C8 R
 4001F7B8 = 4001F7B8	     2		_LINK	= $				
 4001F7B8  07 44 4E 45 47    2		DB	7,'DNEGATE'			
	   41 54 45
			     2	ORG	_CODE					
			     1		align	4
 400007A0  48		     1		db	048h		
 400007A1  21 FB	     1		db	021h,0fbh	
 400007A3  25 FA	     1		db	025h,0fah	
 400007A5  84		     1		db	084h		
 400007A6  F0		     1		db	0f0h		
 400007A7  30		     1		db	030h		
 400007A8  F6		     1		db	0f6h		
 400007A9  00 00 00	     1		db	0,0,0
 400007AC  400001C0 R	     1		dd	DOLST
 400007B0  4000075C R				DD	INVER,TOR,INVER
	   40000300 R
	   4000075C R
 400007BC  400001A8 R				DD	DOLIT,1,UPLUS
	   00000001
	   400003EC R
 400007C8  400002D4 R				DD	RFROM,PLUS,EXIT
	   40000740 R
	   400001D4 R

				;   -		( n1 n2 -- n1-n2 )
				;		Subtraction.

						$COLON	1,'-',SUBB
			     1		$CODE	1,'-',SUBB
			     2		ALIGN	4				
 400007D4		     2	SUBB:						
 400007D4 = 400007D4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F7A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F7A4  400007D4 R	     2		DD	 _CODE,_LINK			
	   4001F7B8 R
 4001F7AC = 4001F7AC	     2		_LINK	= $				
 4001F7AC  01 2D	     2		DB	1,'-'			
			     2	ORG	_CODE					
			     1		align	4
 400007D4  48		     1		db	048h		
 400007D5  21 FB	     1		db	021h,0fbh	
 400007D7  25 FA	     1		db	025h,0fah	
 400007D9  84		     1		db	084h		
 400007DA  F0		     1		db	0f0h		
 400007DB  30		     1		db	030h		
 400007DC  F6		     1		db	0f6h		
 400007DD  00 00 00	     1		db	0,0,0
 400007E0  400001C0 R	     1		dd	DOLST
 400007E4  4000077C R				DD	NEGAT,PLUS,EXIT
	   40000740 R
	   400001D4 R

				;   ABS 	( n -- n )
				;		Return the absolute value of n.

						$COLON	3,'ABS',ABSS
			     1		$CODE	3,'ABS',ABSS
			     2		ALIGN	4				
 400007F0		     2	ABSS:						
 400007F0 = 400007F0	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F798		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F798  400007F0 R	     2		DD	 _CODE,_LINK			
	   4001F7AC R
 4001F7A0 = 4001F7A0	     2		_LINK	= $				
 4001F7A0  03 41 42 53	     2		DB	3,'ABS'			
			     2	ORG	_CODE					
			     1		align	4
 400007F0  48		     1		db	048h		
 400007F1  21 FB	     1		db	021h,0fbh	
 400007F3  25 FA	     1		db	025h,0fah	
 400007F5  84		     1		db	084h		
 400007F6  F0		     1		db	0f0h		
 400007F7  30		     1		db	030h		
 400007F8  F6		     1		db	0f6h		
 400007F9  00 00 00	     1		db	0,0,0
 400007FC  400001C0 R	     1		dd	DOLST
 40000800  40000350 R				DD	DUPP,ZLESS
	   4000038C R
 40000808  40000220 R				DD	QBRAN,ABS1
	   40000814 R
 40000810  4000077C R				DD	NEGAT
 40000814 400001D4 R		ABS1:		DD	EXIT

				;   =		( w w -- t )
				;		Return true if top two are equal.

						$COLON	1,'=',EQUAL
			     1		$CODE	1,'=',EQUAL
			     2		ALIGN	4				
 40000818		     2	EQUAL:						
 40000818 = 40000818	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F78C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F78C  40000818 R	     2		DD	 _CODE,_LINK			
	   4001F7A0 R
 4001F794 = 4001F794	     2		_LINK	= $				
 4001F794  01 3D	     2		DB	1,'='			
			     2	ORG	_CODE					
			     1		align	4
 40000818  48		     1		db	048h		
 40000819  21 FB	     1		db	021h,0fbh	
 4000081B  25 FA	     1		db	025h,0fah	
 4000081D  84		     1		db	084h		
 4000081E  F0		     1		db	0f0h		
 4000081F  30		     1		db	030h		
 40000820  F6		     1		db	0f6h		
 40000821  00 00 00	     1		db	0,0,0
 40000824  400001C0 R	     1		dd	DOLST
 40000828  400003D4 R				DD	XORR
 4000082C  40000220 R				DD	QBRAN,EQU1
	   40000840 R
 40000834  400001A8 R				DD	DOLIT,0,EXIT		;false flag
	   00000000
	   400001D4 R
 40000840 400001A8 R		EQU1:		DD	DOLIT,-1,EXIT		;true flag
	   FFFFFFFF
	   400001D4 R

				;   U<		( u u -- t )
				;		Unsigned compare of top two items.

						$COLON	2,'U<',ULESS
			     1		$CODE	2,'U<',ULESS
			     2		ALIGN	4				
 4000084C		     2	ULESS:						
 4000084C = 4000084C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F780		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F780  4000084C R	     2		DD	 _CODE,_LINK			
	   4001F794 R
 4001F788 = 4001F788	     2		_LINK	= $				
 4001F788  02 55 3C	     2		DB	2,'U<'			
			     2	ORG	_CODE					
			     1		align	4
 4000084C  48		     1		db	048h		
 4000084D  21 FB	     1		db	021h,0fbh	
 4000084F  25 FA	     1		db	025h,0fah	
 40000851  84		     1		db	084h		
 40000852  F0		     1		db	0f0h		
 40000853  30		     1		db	030h		
 40000854  F6		     1		db	0f6h		
 40000855  00 00 00	     1		db	0,0,0
 40000858  400001C0 R	     1		dd	DOLST
 4000085C  40000724 R				DD	DDUP,XORR,ZLESS
	   400003D4 R
	   4000038C R
 40000868  40000220 R				DD	QBRAN,ULES1
	   40000880 R
 40000870  40000364 R				DD	SWAP,DROP,ZLESS,EXIT
	   40000340 R
	   4000038C R
	   400001D4 R
 40000880 400007D4 R		ULES1:		DD	SUBB,ZLESS,EXIT
	   4000038C R
	   400001D4 R

				;   <		( n1 n2 -- t )
				;		Signed compare of top two items.

						$COLON	1,'<',LESS
			     1		$CODE	1,'<',LESS
			     2		ALIGN	4				
 4000088C		     2	LESS:						
 4000088C = 4000088C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F774		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F774  4000088C R	     2		DD	 _CODE,_LINK			
	   4001F788 R
 4001F77C = 4001F77C	     2		_LINK	= $				
 4001F77C  01 3C	     2		DB	1,'<'			
			     2	ORG	_CODE					
			     1		align	4
 4000088C  48		     1		db	048h		
 4000088D  21 FB	     1		db	021h,0fbh	
 4000088F  25 FA	     1		db	025h,0fah	
 40000891  84		     1		db	084h		
 40000892  F0		     1		db	0f0h		
 40000893  30		     1		db	030h		
 40000894  F6		     1		db	0f6h		
 40000895  00 00 00	     1		db	0,0,0
 40000898  400001C0 R	     1		dd	DOLST
 4000089C  40000724 R				DD	DDUP,XORR,ZLESS
	   400003D4 R
	   4000038C R
 400008A8  40000220 R				DD	QBRAN,LESS1
	   400008BC R
 400008B0  40000340 R				DD	DROP,ZLESS,EXIT
	   4000038C R
	   400001D4 R
 400008BC 400007D4 R		LESS1:		DD	SUBB,ZLESS,EXIT
	   4000038C R
	   400001D4 R

				;   MAX 	( n n -- n )
				;		Return the greater of two top stack items.

						$COLON	3,'MAX',MAX
			     1		$CODE	3,'MAX',MAX
			     2		ALIGN	4				
 400008C8		     2	MAX:						
 400008C8 = 400008C8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F768		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F768  400008C8 R	     2		DD	 _CODE,_LINK			
	   4001F77C R
 4001F770 = 4001F770	     2		_LINK	= $				
 4001F770  03 4D 41 58	     2		DB	3,'MAX'			
			     2	ORG	_CODE					
			     1		align	4
 400008C8  48		     1		db	048h		
 400008C9  21 FB	     1		db	021h,0fbh	
 400008CB  25 FA	     1		db	025h,0fah	
 400008CD  84		     1		db	084h		
 400008CE  F0		     1		db	0f0h		
 400008CF  30		     1		db	030h		
 400008D0  F6		     1		db	0f6h		
 400008D1  00 00 00	     1		db	0,0,0
 400008D4  400001C0 R	     1		dd	DOLST
 400008D8  40000724 R				DD	DDUP,LESS
	   4000088C R
 400008E0  40000220 R				DD	QBRAN,MAX1
	   400008EC R
 400008E8  40000364 R				DD	SWAP
 400008EC 40000340 R		MAX1:		DD	DROP,EXIT
	   400001D4 R

				;   MIN 	( n n -- n )
				;		Return the smaller of top two stack items.

						$COLON	3,'MIN',MIN
			     1		$CODE	3,'MIN',MIN
			     2		ALIGN	4				
 400008F4		     2	MIN:						
 400008F4 = 400008F4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F75C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F75C  400008F4 R	     2		DD	 _CODE,_LINK			
	   4001F770 R
 4001F764 = 4001F764	     2		_LINK	= $				
 4001F764  03 4D 49 4E	     2		DB	3,'MIN'			
			     2	ORG	_CODE					
			     1		align	4
 400008F4  48		     1		db	048h		
 400008F5  21 FB	     1		db	021h,0fbh	
 400008F7  25 FA	     1		db	025h,0fah	
 400008F9  84		     1		db	084h		
 400008FA  F0		     1		db	0f0h		
 400008FB  30		     1		db	030h		
 400008FC  F6		     1		db	0f6h		
 400008FD  00 00 00	     1		db	0,0,0
 40000900  400001C0 R	     1		dd	DOLST
 40000904  40000724 R				DD	DDUP,SWAP,LESS
	   40000364 R
	   4000088C R
 40000910  40000220 R				DD	QBRAN,MIN1
	   4000091C R
 40000918  40000364 R				DD	SWAP
 4000091C 40000340 R		MIN1:		DD	DROP,EXIT
	   400001D4 R

				;   WITHIN	( u ul uh -- t )
				;		Return true if u is within the range of ul and uh.

						$COLON	6,'WITHIN',WITHI
			     1		$CODE	6,'WITHIN',WITHI
			     2		ALIGN	4				
 40000924		     2	WITHI:						
 40000924 = 40000924	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F74C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F74C  40000924 R	     2		DD	 _CODE,_LINK			
	   4001F764 R
 4001F754 = 4001F754	     2		_LINK	= $				
 4001F754  06 57 49 54 48    2		DB	6,'WITHIN'			
	   49 4E
			     2	ORG	_CODE					
			     1		align	4
 40000924  48		     1		db	048h		
 40000925  21 FB	     1		db	021h,0fbh	
 40000927  25 FA	     1		db	025h,0fah	
 40000929  84		     1		db	084h		
 4000092A  F0		     1		db	0f0h		
 4000092B  30		     1		db	030h		
 4000092C  F6		     1		db	0f6h		
 4000092D  00 00 00	     1		db	0,0,0
 40000930  400001C0 R	     1		dd	DOLST
 40000934  40000378 R				DD	OVER,SUBB,TOR			;ul <= u < uh
	   400007D4 R
	   40000300 R
 40000940  400007D4 R				DD	SUBB,RFROM,ULESS,EXIT
	   400002D4 R
	   4000084C R
	   400001D4 R

				;; Divide

				;   UM/MOD	( udl udh u -- ur uq )
				;		Unsigned divide of a double by a single. Return mod and quotient.

						$COLON	6,'UM/MOD',UMMOD
			     1		$CODE	6,'UM/MOD',UMMOD
			     2		ALIGN	4				
 40000950		     2	UMMOD:						
 40000950 = 40000950	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F73C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F73C  40000950 R	     2		DD	 _CODE,_LINK			
	   4001F754 R
 4001F744 = 4001F744	     2		_LINK	= $				
 4001F744  06 55 4D 2F 4D    2		DB	6,'UM/MOD'			
	   4F 44
			     2	ORG	_CODE					
			     1		align	4
 40000950  48		     1		db	048h		
 40000951  21 FB	     1		db	021h,0fbh	
 40000953  25 FA	     1		db	025h,0fah	
 40000955  84		     1		db	084h		
 40000956  F0		     1		db	0f0h		
 40000957  30		     1		db	030h		
 40000958  F6		     1		db	0f6h		
 40000959  00 00 00	     1		db	0,0,0
 4000095C  400001C0 R	     1		dd	DOLST
 40000960  40000724 R				DD	DDUP,ULESS
	   4000084C R
 40000968  40000220 R				DD	QBRAN,UMM4
	   40000A08 R
 40000970  4000077C R				DD	NEGAT,DOLIT,15,TOR
	   400001A8 R
	   0000000F
	   40000300 R
 40000980 40000300 R		UMM1:		DD	TOR,DUPP,UPLUS
	   40000350 R
	   400003EC R
 4000098C  40000300 R				DD	TOR,TOR,DUPP,UPLUS
	   40000300 R
	   40000350 R
	   400003EC R
 4000099C  400002D4 R				DD	RFROM,PLUS,DUPP
	   40000740 R
	   40000350 R
 400009A8  400002D4 R				DD	RFROM,RAT,SWAP,TOR
	   400002EC R
	   40000364 R
	   40000300 R
 400009B8  400003EC R				DD	UPLUS,RFROM,ORR
	   400002D4 R
	   400003BC R
 400009C4  40000220 R				DD	QBRAN,UMM2
	   400009EC R
 400009CC  40000300 R				DD	TOR,DROP,DOLIT,1,PLUS,RFROM
	   40000340 R
	   400001A8 R
	   00000001
	   40000740 R
	   400002D4 R
 400009E4  40000244 R				DD	BRAN,UMM3
	   400009F0 R
 400009EC 40000340 R		UMM2:		DD	DROP
 400009F0 400002D4 R		UMM3:		DD	RFROM
 400009F4  400001F0 R				DD	DONXT,UMM1
	   40000980 R
 400009FC  40000340 R				DD	DROP,SWAP,EXIT
	   40000364 R
	   400001D4 R
 40000A08 40000340 R		UMM4:		DD	DROP,DDROP
	   40000708 R
 40000A10  400001A8 R				DD	DOLIT,-1,DUPP,EXIT	;overflow, return max
	   FFFFFFFF
	   40000350 R
	   400001D4 R

				;   M/MOD	( d n -- r q )
				;		Signed floored divide of double by single. Return mod and quotient.

						$COLON	5,'M/MOD',MSMOD
			     1		$CODE	5,'M/MOD',MSMOD
			     2		ALIGN	4				
 40000A20		     2	MSMOD:						
 40000A20 = 40000A20	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F72C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F72C  40000A20 R	     2		DD	 _CODE,_LINK			
	   4001F744 R
 4001F734 = 4001F734	     2		_LINK	= $				
 4001F734  05 4D 2F 4D 4F    2		DB	5,'M/MOD'			
	   44
			     2	ORG	_CODE					
			     1		align	4
 40000A20  48		     1		db	048h		
 40000A21  21 FB	     1		db	021h,0fbh	
 40000A23  25 FA	     1		db	025h,0fah	
 40000A25  84		     1		db	084h		
 40000A26  F0		     1		db	0f0h		
 40000A27  30		     1		db	030h		
 40000A28  F6		     1		db	0f6h		
 40000A29  00 00 00	     1		db	0,0,0
 40000A2C  400001C0 R	     1		dd	DOLST
 40000A30  40000350 R				DD	DUPP,ZLESS,DUPP,TOR
	   4000038C R
	   40000350 R
	   40000300 R
 40000A40  40000220 R				DD	QBRAN,MMOD1
	   40000A58 R
 40000A48  4000077C R				DD	NEGAT,TOR,DNEGA,RFROM
	   40000300 R
	   400007A0 R
	   400002D4 R
 40000A58 40000300 R		MMOD1:		DD	TOR,DUPP,ZLESS
	   40000350 R
	   4000038C R
 40000A64  40000220 R				DD	QBRAN,MMOD2
	   40000A74 R
 40000A6C  400002EC R				DD	RAT,PLUS
	   40000740 R
 40000A74 400002D4 R		MMOD2:		DD	RFROM,UMMOD,RFROM
	   40000950 R
	   400002D4 R
 40000A80  40000220 R				DD	QBRAN,MMOD3
	   40000A94 R
 40000A88  40000364 R				DD	SWAP,NEGAT,SWAP
	   4000077C R
	   40000364 R
 40000A94 400001D4 R		MMOD3:		DD	EXIT

				;   /MOD	( n n -- r q )
				;		Signed divide. Return mod and quotient.

						$COLON	4,'/MOD',SLMOD
			     1		$CODE	4,'/MOD',SLMOD
			     2		ALIGN	4				
 40000A98		     2	SLMOD:						
 40000A98 = 40000A98	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F71C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F71C  40000A98 R	     2		DD	 _CODE,_LINK			
	   4001F734 R
 4001F724 = 4001F724	     2		_LINK	= $				
 4001F724  04 2F 4D 4F 44    2		DB	4,'/MOD'			
			     2	ORG	_CODE					
			     1		align	4
 40000A98  48		     1		db	048h		
 40000A99  21 FB	     1		db	021h,0fbh	
 40000A9B  25 FA	     1		db	025h,0fah	
 40000A9D  84		     1		db	084h		
 40000A9E  F0		     1		db	0f0h		
 40000A9F  30		     1		db	030h		
 40000AA0  F6		     1		db	0f6h		
 40000AA1  00 00 00	     1		db	0,0,0
 40000AA4  400001C0 R	     1		dd	DOLST
 40000AA8  40000378 R				DD	OVER,ZLESS,SWAP,MSMOD,EXIT
	   4000038C R
	   40000364 R
	   40000A20 R
	   400001D4 R

				;   MOD 	( n n -- r )
				;		Signed divide. Return mod only.

						$COLON	3,'MOD',MODD
			     1		$CODE	3,'MOD',MODD
			     2		ALIGN	4				
 40000ABC		     2	MODD:						
 40000ABC = 40000ABC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F710		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F710  40000ABC R	     2		DD	 _CODE,_LINK			
	   4001F724 R
 4001F718 = 4001F718	     2		_LINK	= $				
 4001F718  03 4D 4F 44	     2		DB	3,'MOD'			
			     2	ORG	_CODE					
			     1		align	4
 40000ABC  48		     1		db	048h		
 40000ABD  21 FB	     1		db	021h,0fbh	
 40000ABF  25 FA	     1		db	025h,0fah	
 40000AC1  84		     1		db	084h		
 40000AC2  F0		     1		db	0f0h		
 40000AC3  30		     1		db	030h		
 40000AC4  F6		     1		db	0f6h		
 40000AC5  00 00 00	     1		db	0,0,0
 40000AC8  400001C0 R	     1		dd	DOLST
 40000ACC  40000A98 R				DD	SLMOD,DROP,EXIT
	   40000340 R
	   400001D4 R

				;   /		( n n -- q )
				;		Signed divide. Return quotient only.

						$COLON	1,'/',SLASH
			     1		$CODE	1,'/',SLASH
			     2		ALIGN	4				
 40000AD8		     2	SLASH:						
 40000AD8 = 40000AD8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F704		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F704  40000AD8 R	     2		DD	 _CODE,_LINK			
	   4001F718 R
 4001F70C = 4001F70C	     2		_LINK	= $				
 4001F70C  01 2F	     2		DB	1,'/'			
			     2	ORG	_CODE					
			     1		align	4
 40000AD8  48		     1		db	048h		
 40000AD9  21 FB	     1		db	021h,0fbh	
 40000ADB  25 FA	     1		db	025h,0fah	
 40000ADD  84		     1		db	084h		
 40000ADE  F0		     1		db	0f0h		
 40000ADF  30		     1		db	030h		
 40000AE0  F6		     1		db	0f6h		
 40000AE1  00 00 00	     1		db	0,0,0
 40000AE4  400001C0 R	     1		dd	DOLST
 40000AE8  40000A98 R				DD	SLMOD,SWAP,DROP,EXIT
	   40000364 R
	   40000340 R
	   400001D4 R

				;; Multiply

				;   UM* 	( u u -- ud )
				;		Unsigned multiply. Return double product.

						$COLON	3,'UM*',UMSTA
			     1		$CODE	3,'UM*',UMSTA
			     2		ALIGN	4				
 40000AF8		     2	UMSTA:						
 40000AF8 = 40000AF8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F6F8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6F8  40000AF8 R	     2		DD	 _CODE,_LINK			
	   4001F70C R
 4001F700 = 4001F700	     2		_LINK	= $				
 4001F700  03 55 4D 2A	     2		DB	3,'UM*'			
			     2	ORG	_CODE					
			     1		align	4
 40000AF8  48		     1		db	048h		
 40000AF9  21 FB	     1		db	021h,0fbh	
 40000AFB  25 FA	     1		db	025h,0fah	
 40000AFD  84		     1		db	084h		
 40000AFE  F0		     1		db	0f0h		
 40000AFF  30		     1		db	030h		
 40000B00  F6		     1		db	0f6h		
 40000B01  00 00 00	     1		db	0,0,0
 40000B04  400001C0 R	     1		dd	DOLST
 40000B08  400001A8 R				DD	DOLIT,0,SWAP,DOLIT,15,TOR
	   00000000
	   40000364 R
	   400001A8 R
	   0000000F
	   40000300 R
 40000B20 40000350 R		UMST1:		DD	DUPP,UPLUS,TOR,TOR
	   400003EC R
	   40000300 R
	   40000300 R
 40000B30  40000350 R				DD	DUPP,UPLUS,RFROM,PLUS,RFROM
	   400003EC R
	   400002D4 R
	   40000740 R
	   400002D4 R
 40000B44  40000220 R				DD	QBRAN,UMST2
	   40000B60 R
 40000B4C  40000300 R				DD	TOR,OVER,UPLUS,RFROM,PLUS
	   40000378 R
	   400003EC R
	   400002D4 R
	   40000740 R
 40000B60 400001F0 R		UMST2:		DD	DONXT,UMST1
	   40000B20 R
 40000B68  400006E4 R				DD	ROT,DROP,EXIT
	   40000340 R
	   400001D4 R

				;   *		( n n -- n )
				;		Signed multiply. Return single product.

						$COLON	1,'*',STAR
			     1		$CODE	1,'*',STAR
			     2		ALIGN	4				
 40000B74		     2	STAR:						
 40000B74 = 40000B74	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F6EC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6EC  40000B74 R	     2		DD	 _CODE,_LINK			
	   4001F700 R
 4001F6F4 = 4001F6F4	     2		_LINK	= $				
 4001F6F4  01 2A	     2		DB	1,'*'			
			     2	ORG	_CODE					
			     1		align	4
 40000B74  48		     1		db	048h		
 40000B75  21 FB	     1		db	021h,0fbh	
 40000B77  25 FA	     1		db	025h,0fah	
 40000B79  84		     1		db	084h		
 40000B7A  F0		     1		db	0f0h		
 40000B7B  30		     1		db	030h		
 40000B7C  F6		     1		db	0f6h		
 40000B7D  00 00 00	     1		db	0,0,0
 40000B80  400001C0 R	     1		dd	DOLST
 40000B84  40000AF8 R				DD	UMSTA,DROP,EXIT
	   40000340 R
	   400001D4 R

				;   M*		( n n -- d )
				;		Signed multiply. Return double product.

						$COLON	2,'M*',MSTAR
			     1		$CODE	2,'M*',MSTAR
			     2		ALIGN	4				
 40000B90		     2	MSTAR:						
 40000B90 = 40000B90	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F6E0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6E0  40000B90 R	     2		DD	 _CODE,_LINK			
	   4001F6F4 R
 4001F6E8 = 4001F6E8	     2		_LINK	= $				
 4001F6E8  02 4D 2A	     2		DB	2,'M*'			
			     2	ORG	_CODE					
			     1		align	4
 40000B90  48		     1		db	048h		
 40000B91  21 FB	     1		db	021h,0fbh	
 40000B93  25 FA	     1		db	025h,0fah	
 40000B95  84		     1		db	084h		
 40000B96  F0		     1		db	0f0h		
 40000B97  30		     1		db	030h		
 40000B98  F6		     1		db	0f6h		
 40000B99  00 00 00	     1		db	0,0,0
 40000B9C  400001C0 R	     1		dd	DOLST
 40000BA0  40000724 R				DD	DDUP,XORR,ZLESS,TOR
	   400003D4 R
	   4000038C R
	   40000300 R
 40000BB0  400007F0 R				DD	ABSS,SWAP,ABSS,UMSTA
	   40000364 R
	   400007F0 R
	   40000AF8 R
 40000BC0  400002D4 R				DD	RFROM
 40000BC4  40000220 R				DD	QBRAN,MSTA1
	   40000BD0 R
 40000BCC  400007A0 R				DD	DNEGA
 40000BD0 400001D4 R		MSTA1:		DD	EXIT

				;   */MOD	( n1 n2 n3 -- r q )
				;		Multiply n1 and n2, then divide by n3. Return mod and quotient.

						$COLON	5,'*/MOD',SSMOD
			     1		$CODE	5,'*/MOD',SSMOD
			     2		ALIGN	4				
 40000BD4		     2	SSMOD:						
 40000BD4 = 40000BD4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F6D0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6D0  40000BD4 R	     2		DD	 _CODE,_LINK			
	   4001F6E8 R
 4001F6D8 = 4001F6D8	     2		_LINK	= $				
 4001F6D8  05 2A 2F 4D 4F    2		DB	5,'*/MOD'			
	   44
			     2	ORG	_CODE					
			     1		align	4
 40000BD4  48		     1		db	048h		
 40000BD5  21 FB	     1		db	021h,0fbh	
 40000BD7  25 FA	     1		db	025h,0fah	
 40000BD9  84		     1		db	084h		
 40000BDA  F0		     1		db	0f0h		
 40000BDB  30		     1		db	030h		
 40000BDC  F6		     1		db	0f6h		
 40000BDD  00 00 00	     1		db	0,0,0
 40000BE0  400001C0 R	     1		dd	DOLST
 40000BE4  40000300 R				DD	TOR,MSTAR,RFROM,MSMOD,EXIT
	   40000B90 R
	   400002D4 R
	   40000A20 R
	   400001D4 R

				;   */		( n1 n2 n3 -- q )
				;		Multiply n1 by n2, then divide by n3. Return quotient only.

						$COLON	2,'*/',STASL
			     1		$CODE	2,'*/',STASL
			     2		ALIGN	4				
 40000BF8		     2	STASL:						
 40000BF8 = 40000BF8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F6C4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6C4  40000BF8 R	     2		DD	 _CODE,_LINK			
	   4001F6D8 R
 4001F6CC = 4001F6CC	     2		_LINK	= $				
 4001F6CC  02 2A 2F	     2		DB	2,'*/'			
			     2	ORG	_CODE					
			     1		align	4
 40000BF8  48		     1		db	048h		
 40000BF9  21 FB	     1		db	021h,0fbh	
 40000BFB  25 FA	     1		db	025h,0fah	
 40000BFD  84		     1		db	084h		
 40000BFE  F0		     1		db	0f0h		
 40000BFF  30		     1		db	030h		
 40000C00  F6		     1		db	0f6h		
 40000C01  00 00 00	     1		db	0,0,0
 40000C04  400001C0 R	     1		dd	DOLST
 40000C08  40000BD4 R				DD	SSMOD,SWAP,DROP,EXIT
	   40000364 R
	   40000340 R
	   400001D4 R

				;; Miscellaneous

				;   CELL+	( a -- a )
				;		Add cell size in byte to address.

						$COLON	5,'CELL+',CELLP
			     1		$CODE	5,'CELL+',CELLP
			     2		ALIGN	4				
 40000C18		     2	CELLP:						
 40000C18 = 40000C18	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F6B4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6B4  40000C18 R	     2		DD	 _CODE,_LINK			
	   4001F6CC R
 4001F6BC = 4001F6BC	     2		_LINK	= $				
 4001F6BC  05 43 45 4C 4C    2		DB	5,'CELL+'			
	   2B
			     2	ORG	_CODE					
			     1		align	4
 40000C18  48		     1		db	048h		
 40000C19  21 FB	     1		db	021h,0fbh	
 40000C1B  25 FA	     1		db	025h,0fah	
 40000C1D  84		     1		db	084h		
 40000C1E  F0		     1		db	0f0h		
 40000C1F  30		     1		db	030h		
 40000C20  F6		     1		db	0f6h		
 40000C21  00 00 00	     1		db	0,0,0
 40000C24  400001C0 R	     1		dd	DOLST
 40000C28  400001A8 R				DD	DOLIT,CELLL,PLUS,EXIT
	   00000004
	   40000740 R
	   400001D4 R

				;   CELL-	( a -- a )
				;		Subtract cell size in byte from address.

						$COLON	5,'CELL-',CELLM
			     1		$CODE	5,'CELL-',CELLM
			     2		ALIGN	4				
 40000C38		     2	CELLM:						
 40000C38 = 40000C38	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F6A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F6A4  40000C38 R	     2		DD	 _CODE,_LINK			
	   4001F6BC R
 4001F6AC = 4001F6AC	     2		_LINK	= $				
 4001F6AC  05 43 45 4C 4C    2		DB	5,'CELL-'			
	   2D
			     2	ORG	_CODE					
			     1		align	4
 40000C38  48		     1		db	048h		
 40000C39  21 FB	     1		db	021h,0fbh	
 40000C3B  25 FA	     1		db	025h,0fah	
 40000C3D  84		     1		db	084h		
 40000C3E  F0		     1		db	0f0h		
 40000C3F  30		     1		db	030h		
 40000C40  F6		     1		db	0f6h		
 40000C41  00 00 00	     1		db	0,0,0
 40000C44  400001C0 R	     1		dd	DOLST
 40000C48  400001A8 R				DD	DOLIT,0-CELLL,PLUS,EXIT
	   FFFFFFFC
	   40000740 R
	   400001D4 R

				;   CELLS	( n -- n )
				;		Multiply tos by cell size in bytes.

						$COLON	5,'CELLS',CELLS
			     1		$CODE	5,'CELLS',CELLS
			     2		ALIGN	4				
 40000C58		     2	CELLS:						
 40000C58 = 40000C58	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F694		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F694  40000C58 R	     2		DD	 _CODE,_LINK			
	   4001F6AC R
 4001F69C = 4001F69C	     2		_LINK	= $				
 4001F69C  05 43 45 4C 4C    2		DB	5,'CELLS'			
	   53
			     2	ORG	_CODE					
			     1		align	4
 40000C58  48		     1		db	048h		
 40000C59  21 FB	     1		db	021h,0fbh	
 40000C5B  25 FA	     1		db	025h,0fah	
 40000C5D  84		     1		db	084h		
 40000C5E  F0		     1		db	0f0h		
 40000C5F  30		     1		db	030h		
 40000C60  F6		     1		db	0f6h		
 40000C61  00 00 00	     1		db	0,0,0
 40000C64  400001C0 R	     1		dd	DOLST
 40000C68  400001A8 R				DD	DOLIT,CELLL,STAR,EXIT
	   00000004
	   40000B74 R
	   400001D4 R

				;   ALIGNED	( b -- a )
				;		Align address to the cell boundary.

						$COLON	7,'ALIGNED',ALGND
			     1		$CODE	7,'ALIGNED',ALGND
			     2		ALIGN	4				
 40000C78		     2	ALGND:						
 40000C78 = 40000C78	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F684		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F684  40000C78 R	     2		DD	 _CODE,_LINK			
	   4001F69C R
 4001F68C = 4001F68C	     2		_LINK	= $				
 4001F68C  07 41 4C 49 47    2		DB	7,'ALIGNED'			
	   4E 45 44
			     2	ORG	_CODE					
			     1		align	4
 40000C78  48		     1		db	048h		
 40000C79  21 FB	     1		db	021h,0fbh	
 40000C7B  25 FA	     1		db	025h,0fah	
 40000C7D  84		     1		db	084h		
 40000C7E  F0		     1		db	0f0h		
 40000C7F  30		     1		db	030h		
 40000C80  F6		     1		db	0f6h		
 40000C81  00 00 00	     1		db	0,0,0
 40000C84  400001C0 R	     1		dd	DOLST
 40000C88  40000350 R				DD	DUPP,DOLIT,0,DOLIT,CELLL
	   400001A8 R
	   00000000
	   400001A8 R
	   00000004
 40000C9C  40000950 R				DD	UMMOD,DROP,DUPP
	   40000340 R
	   40000350 R
 40000CA8  40000220 R				DD	QBRAN,ALGN1
	   40000CC0 R
 40000CB0  400001A8 R				DD	DOLIT,CELLL,SWAP,SUBB
	   00000004
	   40000364 R
	   400007D4 R
 40000CC0 40000740 R		ALGN1:		DD	PLUS,EXIT
	   400001D4 R

				;   BL		( -- 32 )
				;		Return 32, the blank character.

						$COLON	2,'BL',BLANK
			     1		$CODE	2,'BL',BLANK
			     2		ALIGN	4				
 40000CC8		     2	BLANK:						
 40000CC8 = 40000CC8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F678		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F678  40000CC8 R	     2		DD	 _CODE,_LINK			
	   4001F68C R
 4001F680 = 4001F680	     2		_LINK	= $				
 4001F680  02 42 4C	     2		DB	2,'BL'			
			     2	ORG	_CODE					
			     1		align	4
 40000CC8  48		     1		db	048h		
 40000CC9  21 FB	     1		db	021h,0fbh	
 40000CCB  25 FA	     1		db	025h,0fah	
 40000CCD  84		     1		db	084h		
 40000CCE  F0		     1		db	0f0h		
 40000CCF  30		     1		db	030h		
 40000CD0  F6		     1		db	0f6h		
 40000CD1  00 00 00	     1		db	0,0,0
 40000CD4  400001C0 R	     1		dd	DOLST
 40000CD8  400001A8 R				DD	DOLIT,' ',EXIT
	   00000020
	   400001D4 R

				;   >CHAR	( c -- c )
				;		Filter non-printing characters.

						$COLON	5,'>CHAR',TCHAR
			     1		$CODE	5,'>CHAR',TCHAR
			     2		ALIGN	4				
 40000CE4		     2	TCHAR:						
 40000CE4 = 40000CE4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F668		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F668  40000CE4 R	     2		DD	 _CODE,_LINK			
	   4001F680 R
 4001F670 = 4001F670	     2		_LINK	= $				
 4001F670  05 3E 43 48 41    2		DB	5,'>CHAR'			
	   52
			     2	ORG	_CODE					
			     1		align	4
 40000CE4  48		     1		db	048h		
 40000CE5  21 FB	     1		db	021h,0fbh	
 40000CE7  25 FA	     1		db	025h,0fah	
 40000CE9  84		     1		db	084h		
 40000CEA  F0		     1		db	0f0h		
 40000CEB  30		     1		db	030h		
 40000CEC  F6		     1		db	0f6h		
 40000CED  00 00 00	     1		db	0,0,0
 40000CF0  400001C0 R	     1		dd	DOLST
 40000CF4  400001A8 R				DD	DOLIT,07FH,ANDD,DUPP	;mask msb
	   0000007F
	   400003A4 R
	   40000350 R
 40000D04  400001A8 R				DD	DOLIT,127,BLANK,WITHI	;check for printable
	   0000007F
	   40000CC8 R
	   40000924 R
 40000D14  40000220 R				DD	QBRAN,TCHA1
	   40000D28 R
 40000D1C  40000340 R				DD	DROP,DOLIT,'_'          ;replace non-printables
	   400001A8 R
	   0000005F
 40000D28 400001D4 R		TCHA1:		DD	EXIT

				;   DEPTH	( -- n )
				;		Return the depth of the data stack.

						$COLON	5,'DEPTH',DEPTH
			     1		$CODE	5,'DEPTH',DEPTH
			     2		ALIGN	4				
 40000D2C		     2	DEPTH:						
 40000D2C = 40000D2C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F658		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F658  40000D2C R	     2		DD	 _CODE,_LINK			
	   4001F670 R
 4001F660 = 4001F660	     2		_LINK	= $				
 4001F660  05 44 45 50 54    2		DB	5,'DEPTH'			
	   48
			     2	ORG	_CODE					
			     1		align	4
 40000D2C  48		     1		db	048h		
 40000D2D  21 FB	     1		db	021h,0fbh	
 40000D2F  25 FA	     1		db	025h,0fah	
 40000D31  84		     1		db	084h		
 40000D32  F0		     1		db	0f0h		
 40000D33  30		     1		db	030h		
 40000D34  F6		     1		db	0f6h		
 40000D35  00 00 00	     1		db	0,0,0
 40000D38  400001C0 R	     1		dd	DOLST
 40000D3C  40000318 R				DD	SPAT,SZERO,AT,SWAP,SUBB
	   4000045C R
	   40000270 R
	   40000364 R
	   400007D4 R
 40000D50  400001A8 R				DD	DOLIT,CELLL,SLASH,EXIT
	   00000004
	   40000AD8 R
	   400001D4 R

				;   PICK	( ... +n -- ... w )
				;		Copy the nth stack item to tos.

						$COLON	4,'PICK',PICK
			     1		$CODE	4,'PICK',PICK
			     2		ALIGN	4				
 40000D60		     2	PICK:						
 40000D60 = 40000D60	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F648		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F648  40000D60 R	     2		DD	 _CODE,_LINK			
	   4001F660 R
 4001F650 = 4001F650	     2		_LINK	= $				
 4001F650  04 50 49 43 4B    2		DB	4,'PICK'			
			     2	ORG	_CODE					
			     1		align	4
 40000D60  48		     1		db	048h		
 40000D61  21 FB	     1		db	021h,0fbh	
 40000D63  25 FA	     1		db	025h,0fah	
 40000D65  84		     1		db	084h		
 40000D66  F0		     1		db	0f0h		
 40000D67  30		     1		db	030h		
 40000D68  F6		     1		db	0f6h		
 40000D69  00 00 00	     1		db	0,0,0
 40000D6C  400001C0 R	     1		dd	DOLST
 40000D70  400001A8 R				DD	DOLIT,1,PLUS,CELLS
	   00000001
	   40000740 R
	   40000C58 R
 40000D80  40000318 R				DD	SPAT,PLUS,AT,EXIT
	   40000740 R
	   40000270 R
	   400001D4 R

				;; Memory access

				;   +!		( n a -- )
				;		Add n to the contents at address a.

						$COLON	2,'+!',PSTOR
			     1		$CODE	2,'+!',PSTOR
			     2		ALIGN	4				
 40000D90		     2	PSTOR:						
 40000D90 = 40000D90	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F63C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F63C  40000D90 R	     2		DD	 _CODE,_LINK			
	   4001F650 R
 4001F644 = 4001F644	     2		_LINK	= $				
 4001F644  02 2B 21	     2		DB	2,'+!'			
			     2	ORG	_CODE					
			     1		align	4
 40000D90  48		     1		db	048h		
 40000D91  21 FB	     1		db	021h,0fbh	
 40000D93  25 FA	     1		db	025h,0fah	
 40000D95  84		     1		db	084h		
 40000D96  F0		     1		db	0f0h		
 40000D97  30		     1		db	030h		
 40000D98  F6		     1		db	0f6h		
 40000D99  00 00 00	     1		db	0,0,0
 40000D9C  400001C0 R	     1		dd	DOLST
 40000DA0  40000364 R				DD	SWAP,OVER,AT,PLUS
	   40000378 R
	   40000270 R
	   40000740 R
 40000DB0  40000364 R				DD	SWAP,STORE,EXIT
	   40000254 R
	   400001D4 R

				;   2!		( d a -- )
				;		Store the double integer to address a.

						$COLON	2,'2!',DSTOR
			     1		$CODE	2,'2!',DSTOR
			     2		ALIGN	4				
 40000DBC		     2	DSTOR:						
 40000DBC = 40000DBC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F630		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F630  40000DBC R	     2		DD	 _CODE,_LINK			
	   4001F644 R
 4001F638 = 4001F638	     2		_LINK	= $				
 4001F638  02 32 21	     2		DB	2,'2!'			
			     2	ORG	_CODE					
			     1		align	4
 40000DBC  48		     1		db	048h		
 40000DBD  21 FB	     1		db	021h,0fbh	
 40000DBF  25 FA	     1		db	025h,0fah	
 40000DC1  84		     1		db	084h		
 40000DC2  F0		     1		db	0f0h		
 40000DC3  30		     1		db	030h		
 40000DC4  F6		     1		db	0f6h		
 40000DC5  00 00 00	     1		db	0,0,0
 40000DC8  400001C0 R	     1		dd	DOLST
 40000DCC  40000364 R				DD	SWAP,OVER,STORE
	   40000378 R
	   40000254 R
 40000DD8  40000C18 R				DD	CELLP,STORE,EXIT
	   40000254 R
	   400001D4 R

				;   2@		( a -- d )
				;		Fetch double integer from address a.

						$COLON	2,'2@',DAT
			     1		$CODE	2,'2@',DAT
			     2		ALIGN	4				
 40000DE4		     2	DAT:						
 40000DE4 = 40000DE4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F624		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F624  40000DE4 R	     2		DD	 _CODE,_LINK			
	   4001F638 R
 4001F62C = 4001F62C	     2		_LINK	= $				
 4001F62C  02 32 40	     2		DB	2,'2@'			
			     2	ORG	_CODE					
			     1		align	4
 40000DE4  48		     1		db	048h		
 40000DE5  21 FB	     1		db	021h,0fbh	
 40000DE7  25 FA	     1		db	025h,0fah	
 40000DE9  84		     1		db	084h		
 40000DEA  F0		     1		db	0f0h		
 40000DEB  30		     1		db	030h		
 40000DEC  F6		     1		db	0f6h		
 40000DED  00 00 00	     1		db	0,0,0
 40000DF0  400001C0 R	     1		dd	DOLST
 40000DF4  40000350 R				DD	DUPP,CELLP,AT
	   40000C18 R
	   40000270 R
 40000E00  40000364 R				DD	SWAP,AT,EXIT
	   40000270 R
	   400001D4 R

				;   COUNT	( b -- b +n )
				;		Return count byte of a string and add 1 to byte address.

						$COLON	5,'COUNT',COUNT
			     1		$CODE	5,'COUNT',COUNT
			     2		ALIGN	4				
 40000E0C		     2	COUNT:						
 40000E0C = 40000E0C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F614		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F614  40000E0C R	     2		DD	 _CODE,_LINK			
	   4001F62C R
 4001F61C = 4001F61C	     2		_LINK	= $				
 4001F61C  05 43 4F 55 4E    2		DB	5,'COUNT'			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40000E0C  48		     1		db	048h		
 40000E0D  21 FB	     1		db	021h,0fbh	
 40000E0F  25 FA	     1		db	025h,0fah	
 40000E11  84		     1		db	084h		
 40000E12  F0		     1		db	0f0h		
 40000E13  30		     1		db	030h		
 40000E14  F6		     1		db	0f6h		
 40000E15  00 00 00	     1		db	0,0,0
 40000E18  400001C0 R	     1		dd	DOLST
 40000E1C  40000350 R				DD	DUPP,DOLIT,1,PLUS
	   400001A8 R
	   00000001
	   40000740 R
 40000E2C  40000364 R				DD	SWAP,CAT,EXIT
	   4000029C R
	   400001D4 R

				;   HERE	( -- a )
				;		Return the top of the code dictionary.

						$COLON	4,'HERE',HERE
			     1		$CODE	4,'HERE',HERE
			     2		ALIGN	4				
 40000E38		     2	HERE:						
 40000E38 = 40000E38	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F604		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F604  40000E38 R	     2		DD	 _CODE,_LINK			
	   4001F61C R
 4001F60C = 4001F60C	     2		_LINK	= $				
 4001F60C  04 48 45 52 45    2		DB	4,'HERE'			
			     2	ORG	_CODE					
			     1		align	4
 40000E38  48		     1		db	048h		
 40000E39  21 FB	     1		db	021h,0fbh	
 40000E3B  25 FA	     1		db	025h,0fah	
 40000E3D  84		     1		db	084h		
 40000E3E  F0		     1		db	0f0h		
 40000E3F  30		     1		db	030h		
 40000E40  F6		     1		db	0f6h		
 40000E41  00 00 00	     1		db	0,0,0
 40000E44  400001C0 R	     1		dd	DOLST
 40000E48  4000063C R				DD	CP,AT,EXIT
	   40000270 R
	   400001D4 R

				;   PAD 	( -- a )
				;		Return the address of a temporary buffer.

						$COLON	3,'PAD',PAD
			     1		$CODE	3,'PAD',PAD
			     2		ALIGN	4				
 40000E54		     2	PAD:						
 40000E54 = 40000E54	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F5F8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5F8  40000E54 R	     2		DD	 _CODE,_LINK			
	   4001F60C R
 4001F600 = 4001F600	     2		_LINK	= $				
 4001F600  03 50 41 44	     2		DB	3,'PAD'			
			     2	ORG	_CODE					
			     1		align	4
 40000E54  48		     1		db	048h		
 40000E55  21 FB	     1		db	021h,0fbh	
 40000E57  25 FA	     1		db	025h,0fah	
 40000E59  84		     1		db	084h		
 40000E5A  F0		     1		db	0f0h		
 40000E5B  30		     1		db	030h		
 40000E5C  F6		     1		db	0f6h		
 40000E5D  00 00 00	     1		db	0,0,0
 40000E60  400001C0 R	     1		dd	DOLST
 40000E64  40000E38 R				DD	HERE,DOLIT,80,PLUS,EXIT
	   400001A8 R
	   00000050
	   40000740 R
	   400001D4 R

				;   TIB 	( -- a )
				;		Return the address of the terminal input buffer.

						$COLON	3,'TIB',TIB
			     1		$CODE	3,'TIB',TIB
			     2		ALIGN	4				
 40000E78		     2	TIB:						
 40000E78 = 40000E78	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F5EC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5EC  40000E78 R	     2		DD	 _CODE,_LINK			
	   4001F600 R
 4001F5F4 = 4001F5F4	     2		_LINK	= $				
 4001F5F4  03 54 49 42	     2		DB	3,'TIB'			
			     2	ORG	_CODE					
			     1		align	4
 40000E78  48		     1		db	048h		
 40000E79  21 FB	     1		db	021h,0fbh	
 40000E7B  25 FA	     1		db	025h,0fah	
 40000E7D  84		     1		db	084h		
 40000E7E  F0		     1		db	0f0h		
 40000E7F  30		     1		db	030h		
 40000E80  F6		     1		db	0f6h		
 40000E81  00 00 00	     1		db	0,0,0
 40000E84  400001C0 R	     1		dd	DOLST
 40000E88  4000057C R				DD	NTIB,CELLP,AT,EXIT
	   40000C18 R
	   40000270 R
	   400001D4 R

				;   @EXECUTE	( a -- )
				;		Execute vector stored in address a.

						$COLON	8,'@EXECUTE',ATEXE
			     1		$CODE	8,'@EXECUTE',ATEXE
			     2		ALIGN	4				
 40000E98		     2	ATEXE:						
 40000E98 = 40000E98	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (8 AND 01FH)/CELLL		
 = 4001F5D8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5D8  40000E98 R	     2		DD	 _CODE,_LINK			
	   4001F5F4 R
 4001F5E0 = 4001F5E0	     2		_LINK	= $				
 4001F5E0  08 40 45 58 45    2		DB	8,'@EXECUTE'			
	   43 55 54 45
			     2	ORG	_CODE					
			     1		align	4
 40000E98  48		     1		db	048h		
 40000E99  21 FB	     1		db	021h,0fbh	
 40000E9B  25 FA	     1		db	025h,0fah	
 40000E9D  84		     1		db	084h		
 40000E9E  F0		     1		db	0f0h		
 40000E9F  30		     1		db	030h		
 40000EA0  F6		     1		db	0f6h		
 40000EA1  00 00 00	     1		db	0,0,0
 40000EA4  400001C0 R	     1		dd	DOLST
 40000EA8  40000270 R				DD	AT,QDUP 		;?address or zero
	   400006C0 R
 40000EB0  40000220 R				DD	QBRAN,EXE1
	   40000EBC R
 40000EB8  400001E8 R				DD	EXECU			;execute if non-zero
 40000EBC 400001D4 R		EXE1:		DD	EXIT			;do nothing if zero

				;   CMOVE	( b1 b2 u -- )
				;		Copy u bytes from b1 to b2.

						$COLON	5,'CMOVE',CMOVE
			     1		$CODE	5,'CMOVE',CMOVE
			     2		ALIGN	4				
 40000EC0		     2	CMOVE:						
 40000EC0 = 40000EC0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F5C8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5C8  40000EC0 R	     2		DD	 _CODE,_LINK			
	   4001F5E0 R
 4001F5D0 = 4001F5D0	     2		_LINK	= $				
 4001F5D0  05 43 4D 4F 56    2		DB	5,'CMOVE'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 40000EC0  48		     1		db	048h		
 40000EC1  21 FB	     1		db	021h,0fbh	
 40000EC3  25 FA	     1		db	025h,0fah	
 40000EC5  84		     1		db	084h		
 40000EC6  F0		     1		db	0f0h		
 40000EC7  30		     1		db	030h		
 40000EC8  F6		     1		db	0f6h		
 40000EC9  00 00 00	     1		db	0,0,0
 40000ECC  400001C0 R	     1		dd	DOLST
 40000ED0  40000300 R				DD	TOR
 40000ED4  40000244 R				DD	BRAN,CMOV2
	   40000F0C R
 40000EDC 40000300 R		CMOV1:		DD	TOR,DUPP,CAT
	   40000350 R
	   4000029C R
 40000EE8  400002EC R				DD	RAT,CSTOR
	   40000280 R
 40000EF0  400001A8 R				DD	DOLIT,1,PLUS
	   00000001
	   40000740 R
 40000EFC  400002D4 R				DD	RFROM,DOLIT,1,PLUS
	   400001A8 R
	   00000001
	   40000740 R
 40000F0C 400001F0 R		CMOV2:		DD	DONXT,CMOV1
	   40000EDC R
 40000F14  40000708 R				DD	DDROP,EXIT
	   400001D4 R

				;   FILL	( b u c -- )
				;		Fill u bytes of character c to area beginning at b.

						$COLON	4,'FILL',FILL
			     1		$CODE	4,'FILL',FILL
			     2		ALIGN	4				
 40000F1C		     2	FILL:						
 40000F1C = 40000F1C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F5B8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5B8  40000F1C R	     2		DD	 _CODE,_LINK			
	   4001F5D0 R
 4001F5C0 = 4001F5C0	     2		_LINK	= $				
 4001F5C0  04 46 49 4C 4C    2		DB	4,'FILL'			
			     2	ORG	_CODE					
			     1		align	4
 40000F1C  48		     1		db	048h		
 40000F1D  21 FB	     1		db	021h,0fbh	
 40000F1F  25 FA	     1		db	025h,0fah	
 40000F21  84		     1		db	084h		
 40000F22  F0		     1		db	0f0h		
 40000F23  30		     1		db	030h		
 40000F24  F6		     1		db	0f6h		
 40000F25  00 00 00	     1		db	0,0,0
 40000F28  400001C0 R	     1		dd	DOLST
 40000F2C  40000364 R				DD	SWAP,TOR,SWAP
	   40000300 R
	   40000364 R
 40000F38  40000244 R				DD	BRAN,FILL2
	   40000F54 R
 40000F40 40000724 R		FILL1:		DD	DDUP,CSTOR,DOLIT,1,PLUS
	   40000280 R
	   400001A8 R
	   00000001
	   40000740 R
 40000F54 400001F0 R		FILL2:		DD	DONXT,FILL1
	   40000F40 R
 40000F5C  40000708 R				DD	DDROP,EXIT
	   400001D4 R

				;   -TRAILING	( b u -- b u )
				;		Adjust the count to eliminate trailing white space.

						$COLON	9,'-TRAILING',DTRAI
			     1		$CODE	9,'-TRAILING',DTRAI
			     2		ALIGN	4				
 40000F64		     2	DTRAI:						
 40000F64 = 40000F64	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (9 AND 01FH)/CELLL		
 = 4001F5A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F5A4  40000F64 R	     2		DD	 _CODE,_LINK			
	   4001F5C0 R
 4001F5AC = 4001F5AC	     2		_LINK	= $				
 4001F5AC  09 2D 54 52 41    2		DB	9,'-TRAILING'			
	   49 4C 49 4E 47
			     2	ORG	_CODE					
			     1		align	4
 40000F64  48		     1		db	048h		
 40000F65  21 FB	     1		db	021h,0fbh	
 40000F67  25 FA	     1		db	025h,0fah	
 40000F69  84		     1		db	084h		
 40000F6A  F0		     1		db	0f0h		
 40000F6B  30		     1		db	030h		
 40000F6C  F6		     1		db	0f6h		
 40000F6D  00 00 00	     1		db	0,0,0
 40000F70  400001C0 R	     1		dd	DOLST
 40000F74  40000300 R				DD	TOR
 40000F78  40000244 R				DD	BRAN,DTRA2
	   40000FB4 R
 40000F80 40000CC8 R		DTRA1:		DD	BLANK,OVER,RAT,PLUS,CAT,LESS
	   40000378 R
	   400002EC R
	   40000740 R
	   4000029C R
	   4000088C R
 40000F98  40000220 R				DD	QBRAN,DTRA2
	   40000FB4 R
 40000FA0  400002D4 R				DD	RFROM,DOLIT,1,PLUS,EXIT ;adjusted count
	   400001A8 R
	   00000001
	   40000740 R
	   400001D4 R
 40000FB4 400001F0 R		DTRA2:		DD	DONXT,DTRA1
	   40000F80 R
 40000FBC  400001A8 R				DD	DOLIT,0,EXIT		;count=0
	   00000000
	   400001D4 R

				;   PACK$	( b u a -- a )
				;		Build a counted string with u characters from b. Null fill.

						$COLON	5,'PACK$',PACKS
			     1		$CODE	5,'PACK$',PACKS
			     2		ALIGN	4				
 40000FC8		     2	PACKS:						
 40000FC8 = 40000FC8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F594		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F594  40000FC8 R	     2		DD	 _CODE,_LINK			
	   4001F5AC R
 4001F59C = 4001F59C	     2		_LINK	= $				
 4001F59C  05 50 41 43 4B    2		DB	5,'PACK$'			
	   24
			     2	ORG	_CODE					
			     1		align	4
 40000FC8  48		     1		db	048h		
 40000FC9  21 FB	     1		db	021h,0fbh	
 40000FCB  25 FA	     1		db	025h,0fah	
 40000FCD  84		     1		db	084h		
 40000FCE  F0		     1		db	0f0h		
 40000FCF  30		     1		db	030h		
 40000FD0  F6		     1		db	0f6h		
 40000FD1  00 00 00	     1		db	0,0,0
 40000FD4  400001C0 R	     1		dd	DOLST
 40000FD8  40000C78 R				DD	ALGND,DUPP,TOR		;strings only on cell boundary
	   40000350 R
	   40000300 R
 40000FE4  40000378 R				DD	OVER,DUPP,DOLIT,0
	   40000350 R
	   400001A8 R
	   00000000
 40000FF4  400001A8 R				DD	DOLIT,CELLL,UMMOD,DROP	;count mod cell
	   00000004
	   40000950 R
	   40000340 R
 40001004  400007D4 R				DD	SUBB,OVER,PLUS
	   40000378 R
	   40000740 R
 40001010  400001A8 R				DD	DOLIT,0,SWAP,STORE	;null fill cell
	   00000000
	   40000364 R
	   40000254 R
 40001020  40000724 R				DD	DDUP,CSTOR,DOLIT,1,PLUS ;save count
	   40000280 R
	   400001A8 R
	   00000001
	   40000740 R
 40001034  40000364 R				DD	SWAP,CMOVE,RFROM,EXIT	;move string
	   40000EC0 R
	   400002D4 R
	   400001D4 R

				;; Numeric output, single precision

				;   DIGIT	( u -- c )
				;		Convert digit u to a character.

						$COLON	5,'DIGIT',DIGIT
			     1		$CODE	5,'DIGIT',DIGIT
			     2		ALIGN	4				
 40001044		     2	DIGIT:						
 40001044 = 40001044	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F584		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F584  40001044 R	     2		DD	 _CODE,_LINK			
	   4001F59C R
 4001F58C = 4001F58C	     2		_LINK	= $				
 4001F58C  05 44 49 47 49    2		DB	5,'DIGIT'			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40001044  48		     1		db	048h		
 40001045  21 FB	     1		db	021h,0fbh	
 40001047  25 FA	     1		db	025h,0fah	
 40001049  84		     1		db	084h		
 4000104A  F0		     1		db	0f0h		
 4000104B  30		     1		db	030h		
 4000104C  F6		     1		db	0f6h		
 4000104D  00 00 00	     1		db	0,0,0
 40001050  400001C0 R	     1		dd	DOLST
 40001054  400001A8 R				DD	DOLIT,9,OVER,LESS
	   00000009
	   40000378 R
	   4000088C R
 40001064  400001A8 R				DD	DOLIT,7,ANDD,PLUS
	   00000007
	   400003A4 R
	   40000740 R
 40001074  400001A8 R				DD	DOLIT,'0',PLUS,EXIT
	   00000030
	   40000740 R
	   400001D4 R

				;   EXTRACT	( n base -- n c )
				;		Extract the least significant digit from n.

						$COLON	7,'EXTRACT',EXTRC
			     1		$CODE	7,'EXTRACT',EXTRC
			     2		ALIGN	4				
 40001084		     2	EXTRC:						
 40001084 = 40001084	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F574		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F574  40001084 R	     2		DD	 _CODE,_LINK			
	   4001F58C R
 4001F57C = 4001F57C	     2		_LINK	= $				
 4001F57C  07 45 58 54 52    2		DB	7,'EXTRACT'			
	   41 43 54
			     2	ORG	_CODE					
			     1		align	4
 40001084  48		     1		db	048h		
 40001085  21 FB	     1		db	021h,0fbh	
 40001087  25 FA	     1		db	025h,0fah	
 40001089  84		     1		db	084h		
 4000108A  F0		     1		db	0f0h		
 4000108B  30		     1		db	030h		
 4000108C  F6		     1		db	0f6h		
 4000108D  00 00 00	     1		db	0,0,0
 40001090  400001C0 R	     1		dd	DOLST
 40001094  400001A8 R				DD	DOLIT,0,SWAP,UMMOD
	   00000000
	   40000364 R
	   40000950 R
 400010A4  40000364 R				DD	SWAP,DIGIT,EXIT
	   40001044 R
	   400001D4 R

				;   <#		( -- )
				;		Initiate the numeric output process.

						$COLON	2,'<#',BDIGS
			     1		$CODE	2,'<#',BDIGS
			     2		ALIGN	4				
 400010B0		     2	BDIGS:						
 400010B0 = 400010B0	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F568		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F568  400010B0 R	     2		DD	 _CODE,_LINK			
	   4001F57C R
 4001F570 = 4001F570	     2		_LINK	= $				
 4001F570  02 3C 23	     2		DB	2,'<#'			
			     2	ORG	_CODE					
			     1		align	4
 400010B0  48		     1		db	048h		
 400010B1  21 FB	     1		db	021h,0fbh	
 400010B3  25 FA	     1		db	025h,0fah	
 400010B5  84		     1		db	084h		
 400010B6  F0		     1		db	0f0h		
 400010B7  30		     1		db	030h		
 400010B8  F6		     1		db	0f6h		
 400010B9  00 00 00	     1		db	0,0,0
 400010BC  400001C0 R	     1		dd	DOLST
 400010C0  40000E54 R				DD	PAD,HLD,STORE,EXIT
	   400005DC R
	   40000254 R
	   400001D4 R

				;   HOLD	( c -- )
				;		Insert a character into the numeric output string.

						$COLON	4,'HOLD',HOLD
			     1		$CODE	4,'HOLD',HOLD
			     2		ALIGN	4				
 400010D0		     2	HOLD:						
 400010D0 = 400010D0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F558		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F558  400010D0 R	     2		DD	 _CODE,_LINK			
	   4001F570 R
 4001F560 = 4001F560	     2		_LINK	= $				
 4001F560  04 48 4F 4C 44    2		DB	4,'HOLD'			
			     2	ORG	_CODE					
			     1		align	4
 400010D0  48		     1		db	048h		
 400010D1  21 FB	     1		db	021h,0fbh	
 400010D3  25 FA	     1		db	025h,0fah	
 400010D5  84		     1		db	084h		
 400010D6  F0		     1		db	0f0h		
 400010D7  30		     1		db	030h		
 400010D8  F6		     1		db	0f6h		
 400010D9  00 00 00	     1		db	0,0,0
 400010DC  400001C0 R	     1		dd	DOLST
 400010E0  400005DC R				DD	HLD,AT,DOLIT,1,SUBB
	   40000270 R
	   400001A8 R
	   00000001
	   400007D4 R
 400010F4  40000350 R				DD	DUPP,HLD,STORE,CSTOR,EXIT
	   400005DC R
	   40000254 R
	   40000280 R
	   400001D4 R

				;   #		( u -- u )
				;		Extract one digit from u and append the digit to output string.

						$COLON	1,'#',DIG
			     1		$CODE	1,'#',DIG
			     2		ALIGN	4				
 40001108		     2	DIG:						
 40001108 = 40001108	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F54C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F54C  40001108 R	     2		DD	 _CODE,_LINK			
	   4001F560 R
 4001F554 = 4001F554	     2		_LINK	= $				
 4001F554  01 23	     2		DB	1,'#'			
			     2	ORG	_CODE					
			     1		align	4
 40001108  48		     1		db	048h		
 40001109  21 FB	     1		db	021h,0fbh	
 4000110B  25 FA	     1		db	025h,0fah	
 4000110D  84		     1		db	084h		
 4000110E  F0		     1		db	0f0h		
 4000110F  30		     1		db	030h		
 40001110  F6		     1		db	0f6h		
 40001111  00 00 00	     1		db	0,0,0
 40001114  400001C0 R	     1		dd	DOLST
 40001118  4000051C R				DD	BASE,AT,EXTRC,HOLD,EXIT
	   40000270 R
	   40001084 R
	   400010D0 R
	   400001D4 R

				;   #S		( u -- 0 )
				;		Convert u until all digits are added to the output string.

						$COLON	2,'#S',DIGS
			     1		$CODE	2,'#S',DIGS
			     2		ALIGN	4				
 4000112C		     2	DIGS:						
 4000112C = 4000112C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F540		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F540  4000112C R	     2		DD	 _CODE,_LINK			
	   4001F554 R
 4001F548 = 4001F548	     2		_LINK	= $				
 4001F548  02 23 53	     2		DB	2,'#S'			
			     2	ORG	_CODE					
			     1		align	4
 4000112C  48		     1		db	048h		
 4000112D  21 FB	     1		db	021h,0fbh	
 4000112F  25 FA	     1		db	025h,0fah	
 40001131  84		     1		db	084h		
 40001132  F0		     1		db	0f0h		
 40001133  30		     1		db	030h		
 40001134  F6		     1		db	0f6h		
 40001135  00 00 00	     1		db	0,0,0
 40001138  400001C0 R	     1		dd	DOLST
 4000113C 40001108 R		DIGS1:		DD	DIG,DUPP
	   40000350 R
 40001144  40000220 R				DD	QBRAN,DIGS2
	   40001154 R
 4000114C  40000244 R				DD	BRAN,DIGS1
	   4000113C R
 40001154 400001D4 R		DIGS2:		DD	EXIT

				;   SIGN	( n -- )
				;		Add a minus sign to the numeric output string.

						$COLON	4,'SIGN',SIGN
			     1		$CODE	4,'SIGN',SIGN
			     2		ALIGN	4				
 40001158		     2	SIGN:						
 40001158 = 40001158	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F530		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F530  40001158 R	     2		DD	 _CODE,_LINK			
	   4001F548 R
 4001F538 = 4001F538	     2		_LINK	= $				
 4001F538  04 53 49 47 4E    2		DB	4,'SIGN'			
			     2	ORG	_CODE					
			     1		align	4
 40001158  48		     1		db	048h		
 40001159  21 FB	     1		db	021h,0fbh	
 4000115B  25 FA	     1		db	025h,0fah	
 4000115D  84		     1		db	084h		
 4000115E  F0		     1		db	0f0h		
 4000115F  30		     1		db	030h		
 40001160  F6		     1		db	0f6h		
 40001161  00 00 00	     1		db	0,0,0
 40001164  400001C0 R	     1		dd	DOLST
 40001168  4000038C R				DD	ZLESS
 4000116C  40000220 R				DD	QBRAN,SIGN1
	   40001180 R
 40001174  400001A8 R				DD	DOLIT,'-',HOLD
	   0000002D
	   400010D0 R
 40001180 400001D4 R		SIGN1:		DD	EXIT

				;   #>		( w -- b u )
				;		Prepare the output string to be TYPE'd.

						$COLON	2,'#>',EDIGS
			     1		$CODE	2,'#>',EDIGS
			     2		ALIGN	4				
 40001184		     2	EDIGS:						
 40001184 = 40001184	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F524		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F524  40001184 R	     2		DD	 _CODE,_LINK			
	   4001F538 R
 4001F52C = 4001F52C	     2		_LINK	= $				
 4001F52C  02 23 3E	     2		DB	2,'#>'			
			     2	ORG	_CODE					
			     1		align	4
 40001184  48		     1		db	048h		
 40001185  21 FB	     1		db	021h,0fbh	
 40001187  25 FA	     1		db	025h,0fah	
 40001189  84		     1		db	084h		
 4000118A  F0		     1		db	0f0h		
 4000118B  30		     1		db	030h		
 4000118C  F6		     1		db	0f6h		
 4000118D  00 00 00	     1		db	0,0,0
 40001190  400001C0 R	     1		dd	DOLST
 40001194  40000340 R				DD	DROP,HLD,AT
	   400005DC R
	   40000270 R
 400011A0  40000E54 R				DD	PAD,OVER,SUBB,EXIT
	   40000378 R
	   400007D4 R
	   400001D4 R

				;   strn	( n -- b u )
				;		Convert a signed integer to a numeric string.

						$COLON	4,'strn',STRN
			     1		$CODE	4,'strn',STRN
			     2		ALIGN	4				
 400011B0		     2	STRN:						
 400011B0 = 400011B0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F514		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F514  400011B0 R	     2		DD	 _CODE,_LINK			
	   4001F52C R
 4001F51C = 4001F51C	     2		_LINK	= $				
 4001F51C  04 73 74 72 6E    2		DB	4,'strn'			
			     2	ORG	_CODE					
			     1		align	4
 400011B0  48		     1		db	048h		
 400011B1  21 FB	     1		db	021h,0fbh	
 400011B3  25 FA	     1		db	025h,0fah	
 400011B5  84		     1		db	084h		
 400011B6  F0		     1		db	0f0h		
 400011B7  30		     1		db	030h		
 400011B8  F6		     1		db	0f6h		
 400011B9  00 00 00	     1		db	0,0,0
 400011BC  400001C0 R	     1		dd	DOLST
 400011C0  40000350 R				DD	DUPP,TOR,ABSS
	   40000300 R
	   400007F0 R
 400011CC  400010B0 R				DD	BDIGS,DIGS,RFROM
	   4000112C R
	   400002D4 R
 400011D8  40001158 R				DD	SIGN,EDIGS,EXIT
	   40001184 R
	   400001D4 R

				;   HEX 	( -- )
				;		Use radix 16 as base for numeric conversions.

						$COLON	3,'HEX',HEX
			     1		$CODE	3,'HEX',HEX
			     2		ALIGN	4				
 400011E4		     2	HEX:						
 400011E4 = 400011E4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F508		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F508  400011E4 R	     2		DD	 _CODE,_LINK			
	   4001F51C R
 4001F510 = 4001F510	     2		_LINK	= $				
 4001F510  03 48 45 58	     2		DB	3,'HEX'			
			     2	ORG	_CODE					
			     1		align	4
 400011E4  48		     1		db	048h		
 400011E5  21 FB	     1		db	021h,0fbh	
 400011E7  25 FA	     1		db	025h,0fah	
 400011E9  84		     1		db	084h		
 400011EA  F0		     1		db	0f0h		
 400011EB  30		     1		db	030h		
 400011EC  F6		     1		db	0f6h		
 400011ED  00 00 00	     1		db	0,0,0
 400011F0  400001C0 R	     1		dd	DOLST
 400011F4  400001A8 R				DD	DOLIT,16,BASE,STORE,EXIT
	   00000010
	   4000051C R
	   40000254 R
	   400001D4 R

				;   DECIMAL	( -- )
				;		Use radix 10 as base for numeric conversions.

						$COLON	7,'DECIMAL',DECIM
			     1		$CODE	7,'DECIMAL',DECIM
			     2		ALIGN	4				
 40001208		     2	DECIM:						
 40001208 = 40001208	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F4F8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4F8  40001208 R	     2		DD	 _CODE,_LINK			
	   4001F510 R
 4001F500 = 4001F500	     2		_LINK	= $				
 4001F500  07 44 45 43 49    2		DB	7,'DECIMAL'			
	   4D 41 4C
			     2	ORG	_CODE					
			     1		align	4
 40001208  48		     1		db	048h		
 40001209  21 FB	     1		db	021h,0fbh	
 4000120B  25 FA	     1		db	025h,0fah	
 4000120D  84		     1		db	084h		
 4000120E  F0		     1		db	0f0h		
 4000120F  30		     1		db	030h		
 40001210  F6		     1		db	0f6h		
 40001211  00 00 00	     1		db	0,0,0
 40001214  400001C0 R	     1		dd	DOLST
 40001218  400001A8 R				DD	DOLIT,10,BASE,STORE,EXIT
	   0000000A
	   4000051C R
	   40000254 R
	   400001D4 R

				;; Numeric input, single precision

				;   DIGIT?	( c base -- u t )
				;		Convert a character to its numeric value. A flag indicates success.

						$COLON	6,'DIGIT?',DIGTQ
			     1		$CODE	6,'DIGIT?',DIGTQ
			     2		ALIGN	4				
 4000122C		     2	DIGTQ:						
 4000122C = 4000122C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F4E8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4E8  4000122C R	     2		DD	 _CODE,_LINK			
	   4001F500 R
 4001F4F0 = 4001F4F0	     2		_LINK	= $				
 4001F4F0  06 44 49 47 49    2		DB	6,'DIGIT?'			
	   54 3F
			     2	ORG	_CODE					
			     1		align	4
 4000122C  48		     1		db	048h		
 4000122D  21 FB	     1		db	021h,0fbh	
 4000122F  25 FA	     1		db	025h,0fah	
 40001231  84		     1		db	084h		
 40001232  F0		     1		db	0f0h		
 40001233  30		     1		db	030h		
 40001234  F6		     1		db	0f6h		
 40001235  00 00 00	     1		db	0,0,0
 40001238  400001C0 R	     1		dd	DOLST
 4000123C  40000300 R				DD	TOR,DOLIT,'0',SUBB
	   400001A8 R
	   00000030
	   400007D4 R
 4000124C  400001A8 R				DD	DOLIT,9,OVER,LESS
	   00000009
	   40000378 R
	   4000088C R
 4000125C  40000220 R				DD	QBRAN,DGTQ1
	   40001284 R
 40001264  400001A8 R				DD	DOLIT,7,SUBB
	   00000007
	   400007D4 R
 40001270  40000350 R				DD	DUPP,DOLIT,10,LESS,ORR
	   400001A8 R
	   0000000A
	   4000088C R
	   400003BC R
 40001284 40000350 R		DGTQ1:		DD	DUPP,RFROM,ULESS,EXIT
	   400002D4 R
	   4000084C R
	   400001D4 R

				;   NUMBER?	( a -- n T | a F )
				;		Convert a number string to integer. Push a flag on tos.

						$COLON	7,'NUMBER?',NUMBQ
			     1		$CODE	7,'NUMBER?',NUMBQ
			     2		ALIGN	4				
 40001294		     2	NUMBQ:						
 40001294 = 40001294	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F4D8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4D8  40001294 R	     2		DD	 _CODE,_LINK			
	   4001F4F0 R
 4001F4E0 = 4001F4E0	     2		_LINK	= $				
 4001F4E0  07 4E 55 4D 42    2		DB	7,'NUMBER?'			
	   45 52 3F
			     2	ORG	_CODE					
			     1		align	4
 40001294  48		     1		db	048h		
 40001295  21 FB	     1		db	021h,0fbh	
 40001297  25 FA	     1		db	025h,0fah	
 40001299  84		     1		db	084h		
 4000129A  F0		     1		db	0f0h		
 4000129B  30		     1		db	030h		
 4000129C  F6		     1		db	0f6h		
 4000129D  00 00 00	     1		db	0,0,0
 400012A0  400001C0 R	     1		dd	DOLST
 400012A4  4000051C R				DD	BASE,AT,TOR,DOLIT,0,OVER,COUNT
	   40000270 R
	   40000300 R
	   400001A8 R
	   00000000
	   40000378 R
	   40000E0C R
 400012C0  40000378 R				DD	OVER,CAT,DOLIT,'$',EQUAL
	   4000029C R
	   400001A8 R
	   00000024
	   40000818 R
 400012D4  40000220 R				DD	QBRAN,NUMQ1
	   40001300 R
 400012DC  400011E4 R				DD	HEX,SWAP,DOLIT,1,PLUS
	   40000364 R
	   400001A8 R
	   00000001
	   40000740 R
 400012F0  40000364 R				DD	SWAP,DOLIT,1,SUBB
	   400001A8 R
	   00000001
	   400007D4 R
 40001300 40000378 R		NUMQ1:		DD	OVER,CAT,DOLIT,'-',EQUAL,TOR
	   4000029C R
	   400001A8 R
	   0000002D
	   40000818 R
	   40000300 R
 40001318  40000364 R				DD	SWAP,RAT,SUBB,SWAP,RAT,PLUS,QDUP
	   400002EC R
	   400007D4 R
	   40000364 R
	   400002EC R
	   40000740 R
	   400006C0 R
 40001334  40000220 R				DD	QBRAN,NUMQ6
	   400013D8 R
 4000133C  400001A8 R				DD	DOLIT,1,SUBB,TOR
	   00000001
	   400007D4 R
	   40000300 R
 4000134C 40000350 R		NUMQ2:		DD	DUPP,TOR,CAT,BASE,AT,DIGTQ
	   40000300 R
	   4000029C R
	   4000051C R
	   40000270 R
	   4000122C R
 40001364  40000220 R				DD	QBRAN,NUMQ4
	   400013BC R
 4000136C  40000364 R				DD	SWAP,BASE,AT,STAR,PLUS,RFROM
	   4000051C R
	   40000270 R
	   40000B74 R
	   40000740 R
	   400002D4 R
 40001384  400001A8 R				DD	DOLIT,1,PLUS
	   00000001
	   40000740 R
 40001390  400001F0 R				DD	DONXT,NUMQ2
	   4000134C R
 40001398  400002EC R				DD	RAT,SWAP,DROP
	   40000364 R
	   40000340 R
 400013A4  40000220 R				DD	QBRAN,NUMQ3
	   400013B0 R
 400013AC  4000077C R				DD	NEGAT
 400013B0 40000364 R		NUMQ3:		DD	SWAP
 400013B4  40000244 R				DD	BRAN,NUMQ5
	   400013D4 R
 400013BC 400002D4 R		NUMQ4:		DD	RFROM,RFROM,DDROP,DDROP,DOLIT,0
	   400002D4 R
	   40000708 R
	   40000708 R
	   400001A8 R
	   00000000
 400013D4 40000350 R		NUMQ5:		DD	DUPP
 400013D8 400002D4 R		NUMQ6:		DD	RFROM,DDROP
	   40000708 R
 400013E0  400002D4 R				DD	RFROM,BASE,STORE,EXIT
	   4000051C R
	   40000254 R
	   400001D4 R

				;; Basic I/O

				;   ?KEY	( -- c T | F )
				;		Return input character and true, or a false if no input.

						$COLON	4,'?KEY',QKEY
			     1		$CODE	4,'?KEY',QKEY
			     2		ALIGN	4				
 400013F0		     2	QKEY:						
 400013F0 = 400013F0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F4C8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4C8  400013F0 R	     2		DD	 _CODE,_LINK			
	   4001F4E0 R
 4001F4D0 = 4001F4D0	     2		_LINK	= $				
 4001F4D0  04 3F 4B 45 59    2		DB	4,'?KEY'			
			     2	ORG	_CODE					
			     1		align	4
 400013F0  48		     1		db	048h		
 400013F1  21 FB	     1		db	021h,0fbh	
 400013F3  25 FA	     1		db	025h,0fah	
 400013F5  84		     1		db	084h		
 400013F6  F0		     1		db	0f0h		
 400013F7  30		     1		db	030h		
 400013F8  F6		     1		db	0f6h		
 400013F9  00 00 00	     1		db	0,0,0
 400013FC  400001C0 R	     1		dd	DOLST
 40001400  4000048C R				DD	TQKEY,ATEXE,EXIT
	   40000E98 R
	   400001D4 R

				;   KEY 	( -- c )
				;		Wait for and return an input character.

						$COLON	3,'KEY',KEY
			     1		$CODE	3,'KEY',KEY
			     2		ALIGN	4				
 4000140C		     2	KEY:						
 4000140C = 4000140C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F4BC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4BC  4000140C R	     2		DD	 _CODE,_LINK			
	   4001F4D0 R
 4001F4C4 = 4001F4C4	     2		_LINK	= $				
 4001F4C4  03 4B 45 59	     2		DB	3,'KEY'			
			     2	ORG	_CODE					
			     1		align	4
 4000140C  48		     1		db	048h		
 4000140D  21 FB	     1		db	021h,0fbh	
 4000140F  25 FA	     1		db	025h,0fah	
 40001411  84		     1		db	084h		
 40001412  F0		     1		db	0f0h		
 40001413  30		     1		db	030h		
 40001414  F6		     1		db	0f6h		
 40001415  00 00 00	     1		db	0,0,0
 40001418  400001C0 R	     1		dd	DOLST
 4000141C 400013F0 R		KEY1:		DD	QKEY
 40001420  40000220 R				DD	QBRAN,KEY1
	   4000141C R
 40001428  400001D4 R				DD	EXIT

				;   EMIT	( c -- )
				;		Send a character to the output device.

						$COLON	4,'EMIT',EMIT
			     1		$CODE	4,'EMIT',EMIT
			     2		ALIGN	4				
 4000142C		     2	EMIT:						
 4000142C = 4000142C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F4AC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F4AC  4000142C R	     2		DD	 _CODE,_LINK			
	   4001F4C4 R
 4001F4B4 = 4001F4B4	     2		_LINK	= $				
 4001F4B4  04 45 4D 49 54    2		DB	4,'EMIT'			
			     2	ORG	_CODE					
			     1		align	4
 4000142C  48		     1		db	048h		
 4000142D  21 FB	     1		db	021h,0fbh	
 4000142F  25 FA	     1		db	025h,0fah	
 40001431  84		     1		db	084h		
 40001432  F0		     1		db	0f0h		
 40001433  30		     1		db	030h		
 40001434  F6		     1		db	0f6h		
 40001435  00 00 00	     1		db	0,0,0
 40001438  400001C0 R	     1		dd	DOLST
 4000143C  400004A4 R				DD	TEMIT,ATEXE,EXIT
	   40000E98 R
	   400001D4 R

				;   NUF?	( -- t )
				;		Return false if no input, else pause and if CR return true.

						$COLON	4,'NUF?',NUFQ
			     1		$CODE	4,'NUF?',NUFQ
			     2		ALIGN	4				
 40001448		     2	NUFQ:						
 40001448 = 40001448	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F49C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F49C  40001448 R	     2		DD	 _CODE,_LINK			
	   4001F4B4 R
 4001F4A4 = 4001F4A4	     2		_LINK	= $				
 4001F4A4  04 4E 55 46 3F    2		DB	4,'NUF?'			
			     2	ORG	_CODE					
			     1		align	4
 40001448  48		     1		db	048h		
 40001449  21 FB	     1		db	021h,0fbh	
 4000144B  25 FA	     1		db	025h,0fah	
 4000144D  84		     1		db	084h		
 4000144E  F0		     1		db	0f0h		
 4000144F  30		     1		db	030h		
 40001450  F6		     1		db	0f6h		
 40001451  00 00 00	     1		db	0,0,0
 40001454  400001C0 R	     1		dd	DOLST
 40001458  400013F0 R				DD	QKEY,DUPP
	   40000350 R
 40001460  40000220 R				DD	QBRAN,NUFQ1
	   4000147C R
 40001468  40000708 R				DD	DDROP,KEY,DOLIT,CRR,EQUAL
	   4000140C R
	   400001A8 R
	   0000000D
	   40000818 R
 4000147C 400001D4 R		NUFQ1:		DD	EXIT

				;   PACE	( -- )
				;		Send a pace character for the file downloading process.

						$COLON	4,'PACE',PACE
			     1		$CODE	4,'PACE',PACE
			     2		ALIGN	4				
 40001480		     2	PACE:						
 40001480 = 40001480	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F48C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F48C  40001480 R	     2		DD	 _CODE,_LINK			
	   4001F4A4 R
 4001F494 = 4001F494	     2		_LINK	= $				
 4001F494  04 50 41 43 45    2		DB	4,'PACE'			
			     2	ORG	_CODE					
			     1		align	4
 40001480  48		     1		db	048h		
 40001481  21 FB	     1		db	021h,0fbh	
 40001483  25 FA	     1		db	025h,0fah	
 40001485  84		     1		db	084h		
 40001486  F0		     1		db	0f0h		
 40001487  30		     1		db	030h		
 40001488  F6		     1		db	0f6h		
 40001489  00 00 00	     1		db	0,0,0
 4000148C  400001C0 R	     1		dd	DOLST
 40001490  400001A8 R				DD	DOLIT,11,EMIT,EXIT
	   0000000B
	   4000142C R
	   400001D4 R

				;   SPACE	( -- )
				;		Send the blank character to the output device.

						$COLON	5,'SPACE',SPACE
			     1		$CODE	5,'SPACE',SPACE
			     2		ALIGN	4				
 400014A0		     2	SPACE:						
 400014A0 = 400014A0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F47C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F47C  400014A0 R	     2		DD	 _CODE,_LINK			
	   4001F494 R
 4001F484 = 4001F484	     2		_LINK	= $				
 4001F484  05 53 50 41 43    2		DB	5,'SPACE'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 400014A0  48		     1		db	048h		
 400014A1  21 FB	     1		db	021h,0fbh	
 400014A3  25 FA	     1		db	025h,0fah	
 400014A5  84		     1		db	084h		
 400014A6  F0		     1		db	0f0h		
 400014A7  30		     1		db	030h		
 400014A8  F6		     1		db	0f6h		
 400014A9  00 00 00	     1		db	0,0,0
 400014AC  400001C0 R	     1		dd	DOLST
 400014B0  40000CC8 R				DD	BLANK,EMIT,EXIT
	   4000142C R
	   400001D4 R

				;   SPACES	( +n -- )
				;		Send n spaces to the output device.

						$COLON	6,'SPACES',SPACS
			     1		$CODE	6,'SPACES',SPACS
			     2		ALIGN	4				
 400014BC		     2	SPACS:						
 400014BC = 400014BC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F46C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F46C  400014BC R	     2		DD	 _CODE,_LINK			
	   4001F484 R
 4001F474 = 4001F474	     2		_LINK	= $				
 4001F474  06 53 50 41 43    2		DB	6,'SPACES'			
	   45 53
			     2	ORG	_CODE					
			     1		align	4
 400014BC  48		     1		db	048h		
 400014BD  21 FB	     1		db	021h,0fbh	
 400014BF  25 FA	     1		db	025h,0fah	
 400014C1  84		     1		db	084h		
 400014C2  F0		     1		db	0f0h		
 400014C3  30		     1		db	030h		
 400014C4  F6		     1		db	0f6h		
 400014C5  00 00 00	     1		db	0,0,0
 400014C8  400001C0 R	     1		dd	DOLST
 400014CC  400001A8 R				DD	DOLIT,0,MAX,TOR
	   00000000
	   400008C8 R
	   40000300 R
 400014DC  40000244 R				DD	BRAN,CHAR2
	   400014E8 R
 400014E4 400014A0 R		CHAR1:		DD	SPACE
 400014E8 400001F0 R		CHAR2:		DD	DONXT,CHAR1
	   400014E4 R
 400014F0  400001D4 R				DD	EXIT

				;   TYPE	( b u -- )
				;		Output u characters from b.

						$COLON	4,'TYPE',TYPEE
			     1		$CODE	4,'TYPE',TYPEE
			     2		ALIGN	4				
 400014F4		     2	TYPEE:						
 400014F4 = 400014F4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F45C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F45C  400014F4 R	     2		DD	 _CODE,_LINK			
	   4001F474 R
 4001F464 = 4001F464	     2		_LINK	= $				
 4001F464  04 54 59 50 45    2		DB	4,'TYPE'			
			     2	ORG	_CODE					
			     1		align	4
 400014F4  48		     1		db	048h		
 400014F5  21 FB	     1		db	021h,0fbh	
 400014F7  25 FA	     1		db	025h,0fah	
 400014F9  84		     1		db	084h		
 400014FA  F0		     1		db	0f0h		
 400014FB  30		     1		db	030h		
 400014FC  F6		     1		db	0f6h		
 400014FD  00 00 00	     1		db	0,0,0
 40001500  400001C0 R	     1		dd	DOLST
 40001504  40000300 R				DD	TOR
 40001508  40000244 R				DD	BRAN,TYPE2
	   40001528 R
 40001510 40000350 R		TYPE1:		DD	DUPP,CAT,EMIT
	   4000029C R
	   4000142C R
 4000151C  400001A8 R				DD	DOLIT,1,PLUS
	   00000001
	   40000740 R
 40001528 400001F0 R		TYPE2:		DD	DONXT,TYPE1
	   40001510 R
 40001530  40000340 R				DD	DROP,EXIT
	   400001D4 R

				;   CR		( -- )
				;		Output a carriage return and a line feed.

						$COLON	2,'CR',CR
			     1		$CODE	2,'CR',CR
			     2		ALIGN	4				
 40001538		     2	CR:						
 40001538 = 40001538	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F450		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F450  40001538 R	     2		DD	 _CODE,_LINK			
	   4001F464 R
 4001F458 = 4001F458	     2		_LINK	= $				
 4001F458  02 43 52	     2		DB	2,'CR'			
			     2	ORG	_CODE					
			     1		align	4
 40001538  48		     1		db	048h		
 40001539  21 FB	     1		db	021h,0fbh	
 4000153B  25 FA	     1		db	025h,0fah	
 4000153D  84		     1		db	084h		
 4000153E  F0		     1		db	0f0h		
 4000153F  30		     1		db	030h		
 40001540  F6		     1		db	0f6h		
 40001541  00 00 00	     1		db	0,0,0
 40001544  400001C0 R	     1		dd	DOLST
 40001548  400001A8 R				DD	DOLIT,CRR,EMIT
	   0000000D
	   4000142C R
 40001554  400001A8 R				DD	DOLIT,LF,EMIT,EXIT
	   0000000A
	   4000142C R
	   400001D4 R

				;   do$ 	( -- a )
				;		Return the address of a compiled string.

						$COLON	COMPO+3,'do$',DOSTR
			     1		$CODE	COMPO+3,'do$',DOSTR
			     2		ALIGN	4				
 40001564		     2	DOSTR:						
 40001564 = 40001564	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001F444		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F444  40001564 R	     2		DD	 _CODE,_LINK			
	   4001F458 R
 4001F44C = 4001F44C	     2		_LINK	= $				
 4001F44C  43 64 6F 24	     2		DB	COMPO+3,'do$'			
			     2	ORG	_CODE					
			     1		align	4
 40001564  48		     1		db	048h		
 40001565  21 FB	     1		db	021h,0fbh	
 40001567  25 FA	     1		db	025h,0fah	
 40001569  84		     1		db	084h		
 4000156A  F0		     1		db	0f0h		
 4000156B  30		     1		db	030h		
 4000156C  F6		     1		db	0f6h		
 4000156D  00 00 00	     1		db	0,0,0
 40001570  400001C0 R	     1		dd	DOLST
 40001574  400002D4 R				DD	RFROM,RAT,RFROM,COUNT,PLUS
	   400002EC R
	   400002D4 R
	   40000E0C R
	   40000740 R
 40001588  40000C78 R				DD	ALGND,TOR,SWAP,TOR,EXIT
	   40000300 R
	   40000364 R
	   40000300 R
	   400001D4 R

				;   $"|         ( -- a )
				;		Run time routine compiled by $". Return address of a compiled string.

						$COLON	COMPO+3,'$"|',STRQP
			     1		$CODE	COMPO+3,'$"|',STRQP
			     2		ALIGN	4				
 4000159C		     2	STRQP:						
 4000159C = 4000159C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001F438		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F438  4000159C R	     2		DD	 _CODE,_LINK			
	   4001F44C R
 4001F440 = 4001F440	     2		_LINK	= $				
 4001F440  43 24 22 7C	     2		DB	COMPO+3,'$"|'			
			     2	ORG	_CODE					
			     1		align	4
 4000159C  48		     1		db	048h		
 4000159D  21 FB	     1		db	021h,0fbh	
 4000159F  25 FA	     1		db	025h,0fah	
 400015A1  84		     1		db	084h		
 400015A2  F0		     1		db	0f0h		
 400015A3  30		     1		db	030h		
 400015A4  F6		     1		db	0f6h		
 400015A5  00 00 00	     1		db	0,0,0
 400015A8  400001C0 R	     1		dd	DOLST
 400015AC  40001564 R				DD	DOSTR,EXIT		;force a call to do$
	   400001D4 R

				;   ."|         ( -- )
				;		Run time routine of ." . Output a compiled string.

						$COLON	COMPO+3,'."|',DOTQP
			     1		$CODE	COMPO+3,'."|',DOTQP
			     2		ALIGN	4				
 400015B4		     2	DOTQP:						
 400015B4 = 400015B4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001F42C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F42C  400015B4 R	     2		DD	 _CODE,_LINK			
	   4001F440 R
 4001F434 = 4001F434	     2		_LINK	= $				
 4001F434  43 2E 22 7C	     2		DB	COMPO+3,'."|'			
			     2	ORG	_CODE					
			     1		align	4
 400015B4  48		     1		db	048h		
 400015B5  21 FB	     1		db	021h,0fbh	
 400015B7  25 FA	     1		db	025h,0fah	
 400015B9  84		     1		db	084h		
 400015BA  F0		     1		db	0f0h		
 400015BB  30		     1		db	030h		
 400015BC  F6		     1		db	0f6h		
 400015BD  00 00 00	     1		db	0,0,0
 400015C0  400001C0 R	     1		dd	DOLST
 400015C4  40001564 R				DD	DOSTR,COUNT,TYPEE,EXIT
	   40000E0C R
	   400014F4 R
	   400001D4 R

				;   .R		( n +n -- )
				;		Display an integer in a field of n columns, right justified.

						$COLON	2,'.R',DOTR
			     1		$CODE	2,'.R',DOTR
			     2		ALIGN	4				
 400015D4		     2	DOTR:						
 400015D4 = 400015D4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F420		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F420  400015D4 R	     2		DD	 _CODE,_LINK			
	   4001F434 R
 4001F428 = 4001F428	     2		_LINK	= $				
 4001F428  02 2E 52	     2		DB	2,'.R'			
			     2	ORG	_CODE					
			     1		align	4
 400015D4  48		     1		db	048h		
 400015D5  21 FB	     1		db	021h,0fbh	
 400015D7  25 FA	     1		db	025h,0fah	
 400015D9  84		     1		db	084h		
 400015DA  F0		     1		db	0f0h		
 400015DB  30		     1		db	030h		
 400015DC  F6		     1		db	0f6h		
 400015DD  00 00 00	     1		db	0,0,0
 400015E0  400001C0 R	     1		dd	DOLST
 400015E4  40000300 R				DD	TOR,STRN,RFROM,OVER,SUBB
	   400011B0 R
	   400002D4 R
	   40000378 R
	   400007D4 R
 400015F8  400014BC R				DD	SPACS,TYPEE,EXIT
	   400014F4 R
	   400001D4 R

				;   U.R 	( u +n -- )
				;		Display an unsigned integer in n column, right justified.

						$COLON	3,'U.R',UDOTR
			     1		$CODE	3,'U.R',UDOTR
			     2		ALIGN	4				
 40001604		     2	UDOTR:						
 40001604 = 40001604	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F414		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F414  40001604 R	     2		DD	 _CODE,_LINK			
	   4001F428 R
 4001F41C = 4001F41C	     2		_LINK	= $				
 4001F41C  03 55 2E 52	     2		DB	3,'U.R'			
			     2	ORG	_CODE					
			     1		align	4
 40001604  48		     1		db	048h		
 40001605  21 FB	     1		db	021h,0fbh	
 40001607  25 FA	     1		db	025h,0fah	
 40001609  84		     1		db	084h		
 4000160A  F0		     1		db	0f0h		
 4000160B  30		     1		db	030h		
 4000160C  F6		     1		db	0f6h		
 4000160D  00 00 00	     1		db	0,0,0
 40001610  400001C0 R	     1		dd	DOLST
 40001614  40000300 R				DD	TOR,BDIGS,DIGS,EDIGS
	   400010B0 R
	   4000112C R
	   40001184 R
 40001624  400002D4 R				DD	RFROM,OVER,SUBB
	   40000378 R
	   400007D4 R
 40001630  400014BC R				DD	SPACS,TYPEE,EXIT
	   400014F4 R
	   400001D4 R

				;   U.		( u -- )
				;		Display an unsigned integer in free format.

						$COLON	2,'U.',UDOT
			     1		$CODE	2,'U.',UDOT
			     2		ALIGN	4				
 4000163C		     2	UDOT:						
 4000163C = 4000163C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F408		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F408  4000163C R	     2		DD	 _CODE,_LINK			
	   4001F41C R
 4001F410 = 4001F410	     2		_LINK	= $				
 4001F410  02 55 2E	     2		DB	2,'U.'			
			     2	ORG	_CODE					
			     1		align	4
 4000163C  48		     1		db	048h		
 4000163D  21 FB	     1		db	021h,0fbh	
 4000163F  25 FA	     1		db	025h,0fah	
 40001641  84		     1		db	084h		
 40001642  F0		     1		db	0f0h		
 40001643  30		     1		db	030h		
 40001644  F6		     1		db	0f6h		
 40001645  00 00 00	     1		db	0,0,0
 40001648  400001C0 R	     1		dd	DOLST
 4000164C  400010B0 R				DD	BDIGS,DIGS,EDIGS
	   4000112C R
	   40001184 R
 40001658  400014A0 R				DD	SPACE,TYPEE,EXIT
	   400014F4 R
	   400001D4 R

				;   .		( w -- )
				;		Display an integer in free format, preceeded by a space.

						$COLON	1,'.',DOT
			     1		$CODE	1,'.',DOT
			     2		ALIGN	4				
 40001664		     2	DOT:						
 40001664 = 40001664	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F3FC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3FC  40001664 R	     2		DD	 _CODE,_LINK			
	   4001F410 R
 4001F404 = 4001F404	     2		_LINK	= $				
 4001F404  01 2E	     2		DB	1,'.'			
			     2	ORG	_CODE					
			     1		align	4
 40001664  48		     1		db	048h		
 40001665  21 FB	     1		db	021h,0fbh	
 40001667  25 FA	     1		db	025h,0fah	
 40001669  84		     1		db	084h		
 4000166A  F0		     1		db	0f0h		
 4000166B  30		     1		db	030h		
 4000166C  F6		     1		db	0f6h		
 4000166D  00 00 00	     1		db	0,0,0
 40001670  400001C0 R	     1		dd	DOLST
 40001674  4000051C R				DD	BASE,AT,DOLIT,10,XORR	;?decimal
	   40000270 R
	   400001A8 R
	   0000000A
	   400003D4 R
 40001688  40000220 R				DD	QBRAN,DOT1
	   40001698 R
 40001690  4000163C R				DD	UDOT,EXIT		;no, display unsigned
	   400001D4 R
 40001698 400011B0 R		DOT1:		DD	STRN,SPACE,TYPEE,EXIT	 ;yes, display signed
	   400014A0 R
	   400014F4 R
	   400001D4 R

				;   ?		( a -- )
				;		Display the contents in a memory cell.

						$COLON	1,'?',QUEST
			     1		$CODE	1,'?',QUEST
			     2		ALIGN	4				
 400016A8		     2	QUEST:						
 400016A8 = 400016A8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F3F0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3F0  400016A8 R	     2		DD	 _CODE,_LINK			
	   4001F404 R
 4001F3F8 = 4001F3F8	     2		_LINK	= $				
 4001F3F8  01 3F	     2		DB	1,'?'			
			     2	ORG	_CODE					
			     1		align	4
 400016A8  48		     1		db	048h		
 400016A9  21 FB	     1		db	021h,0fbh	
 400016AB  25 FA	     1		db	025h,0fah	
 400016AD  84		     1		db	084h		
 400016AE  F0		     1		db	0f0h		
 400016AF  30		     1		db	030h		
 400016B0  F6		     1		db	0f6h		
 400016B1  00 00 00	     1		db	0,0,0
 400016B4  400001C0 R	     1		dd	DOLST
 400016B8  40000270 R				DD	AT,DOT,EXIT
	   40001664 R
	   400001D4 R

				;; Parsing

				;   parse	( b u c -- b u delta ; <string> )
				;		Scan string delimited by c. Return found string and its offset.

						$COLON	5,'parse',PARS
			     1		$CODE	5,'parse',PARS
			     2		ALIGN	4				
 400016C4		     2	PARS:						
 400016C4 = 400016C4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F3E0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3E0  400016C4 R	     2		DD	 _CODE,_LINK			
	   4001F3F8 R
 4001F3E8 = 4001F3E8	     2		_LINK	= $				
 4001F3E8  05 70 61 72 73    2		DB	5,'parse'			
	   65
			     2	ORG	_CODE					
			     1		align	4
 400016C4  48		     1		db	048h		
 400016C5  21 FB	     1		db	021h,0fbh	
 400016C7  25 FA	     1		db	025h,0fah	
 400016C9  84		     1		db	084h		
 400016CA  F0		     1		db	0f0h		
 400016CB  30		     1		db	030h		
 400016CC  F6		     1		db	0f6h		
 400016CD  00 00 00	     1		db	0,0,0
 400016D0  400001C0 R	     1		dd	DOLST
 400016D4  40000534 R				DD	TEMP,STORE,OVER,TOR,DUPP
	   40000254 R
	   40000378 R
	   40000300 R
	   40000350 R
 400016E8  40000220 R				DD	QBRAN,PARS8
	   40001804 R
 400016F0  400001A8 R				DD	DOLIT,1,SUBB,TEMP,AT,BLANK,EQUAL
	   00000001
	   400007D4 R
	   40000534 R
	   40000270 R
	   40000CC8 R
	   40000818 R
 4000170C  40000220 R				DD	QBRAN,PARS3
	   40001768 R
 40001714  40000300 R				DD	TOR
 40001718 40000CC8 R		PARS1:		DD	BLANK,OVER,CAT		;skip leading blanks ONLY
	   40000378 R
	   4000029C R
 40001724  400007D4 R				DD	SUBB,ZLESS,INVER
	   4000038C R
	   4000075C R
 40001730  40000220 R				DD	QBRAN,PARS2
	   40001764 R
 40001738  400001A8 R				DD	DOLIT,1,PLUS
	   00000001
	   40000740 R
 40001744  400001F0 R				DD	DONXT,PARS1
	   40001718 R
 4000174C  400002D4 R				DD	RFROM,DROP,DOLIT,0,DUPP,EXIT
	   40000340 R
	   400001A8 R
	   00000000
	   40000350 R
	   400001D4 R
 40001764 400002D4 R		PARS2:		DD	RFROM
 40001768 40000378 R		PARS3:		DD	OVER,SWAP
	   40000364 R
 40001770  40000300 R				DD	TOR
 40001774 40000534 R		PARS4:		DD	TEMP,AT,OVER,CAT,SUBB	;scan for delimiter
	   40000270 R
	   40000378 R
	   4000029C R
	   400007D4 R
 40001788  40000534 R				DD	TEMP,AT,BLANK,EQUAL
	   40000270 R
	   40000CC8 R
	   40000818 R
 40001798  40000220 R				DD	QBRAN,PARS5
	   400017A4 R
 400017A0  4000038C R				DD	ZLESS
 400017A4 40000220 R		PARS5:		DD	QBRAN,PARS6
	   400017D0 R
 400017AC  400001A8 R				DD	DOLIT,1,PLUS
	   00000001
	   40000740 R
 400017B8  400001F0 R				DD	DONXT,PARS4
	   40001774 R
 400017C0  40000350 R				DD	DUPP,TOR
	   40000300 R
 400017C8  40000244 R				DD	BRAN,PARS7
	   400017EC R
 400017D0 400002D4 R		PARS6:		DD	RFROM,DROP,DUPP
	   40000340 R
	   40000350 R
 400017DC  400001A8 R				DD	DOLIT,1,PLUS,TOR
	   00000001
	   40000740 R
	   40000300 R
 400017EC 40000378 R		PARS7:		DD	OVER,SUBB
	   400007D4 R
 400017F4  400002D4 R				DD	RFROM,RFROM,SUBB,EXIT
	   400002D4 R
	   400007D4 R
	   400001D4 R
 40001804 40000378 R		PARS8:		DD	OVER,RFROM,SUBB,EXIT
	   400002D4 R
	   400007D4 R
	   400001D4 R

				;   PARSE	( c -- b u ; <string> )
				;		Scan input stream and return counted string delimited by c.

						$COLON	5,'PARSE',PARSE
			     1		$CODE	5,'PARSE',PARSE
			     2		ALIGN	4				
 40001814		     2	PARSE:						
 40001814 = 40001814	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F3D0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3D0  40001814 R	     2		DD	 _CODE,_LINK			
	   4001F3E8 R
 4001F3D8 = 4001F3D8	     2		_LINK	= $				
 4001F3D8  05 50 41 52 53    2		DB	5,'PARSE'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 40001814  48		     1		db	048h		
 40001815  21 FB	     1		db	021h,0fbh	
 40001817  25 FA	     1		db	025h,0fah	
 40001819  84		     1		db	084h		
 4000181A  F0		     1		db	0f0h		
 4000181B  30		     1		db	030h		
 4000181C  F6		     1		db	0f6h		
 4000181D  00 00 00	     1		db	0,0,0
 40001820  400001C0 R	     1		dd	DOLST
 40001824  40000300 R				DD	TOR,TIB,INN,AT,PLUS	;current input buffer pointer
	   40000E78 R
	   40000564 R
	   40000270 R
	   40000740 R
 40001838  4000057C R				DD	NTIB,AT,INN,AT,SUBB	;remaining count
	   40000270 R
	   40000564 R
	   40000270 R
	   400007D4 R
 4000184C  400002D4 R				DD	RFROM,PARS,INN,PSTOR,EXIT
	   400016C4 R
	   40000564 R
	   40000D90 R
	   400001D4 R

				;   .(		( -- )
				;		Output following string up to next ) .

						$COLON	IMEDD+2,'.(',DOTPR
			     1		$CODE	IMEDD+2,'.(',DOTPR
			     2		ALIGN	4				
 40001860		     2	DOTPR:						
 40001860 = 40001860	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+2 AND 01FH)/CELLL		
 = 4001F3C4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3C4  40001860 R	     2		DD	 _CODE,_LINK			
	   4001F3D8 R
 4001F3CC = 4001F3CC	     2		_LINK	= $				
 4001F3CC  82 2E 28	     2		DB	IMEDD+2,'.('			
			     2	ORG	_CODE					
			     1		align	4
 40001860  48		     1		db	048h		
 40001861  21 FB	     1		db	021h,0fbh	
 40001863  25 FA	     1		db	025h,0fah	
 40001865  84		     1		db	084h		
 40001866  F0		     1		db	0f0h		
 40001867  30		     1		db	030h		
 40001868  F6		     1		db	0f6h		
 40001869  00 00 00	     1		db	0,0,0
 4000186C  400001C0 R	     1		dd	DOLST
 40001870  400001A8 R				DD	DOLIT,')',PARSE,TYPEE,EXIT
	   00000029
	   40001814 R
	   400014F4 R
	   400001D4 R

				;   (		( -- )
				;		Ignore following string up to next ) . A comment.

						$COLON	IMEDD+1,'(',PAREN
			     1		$CODE	IMEDD+1,'(',PAREN
			     2		ALIGN	4				
 40001884		     2	PAREN:						
 40001884 = 40001884	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+1 AND 01FH)/CELLL		
 = 4001F3B8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3B8  40001884 R	     2		DD	 _CODE,_LINK			
	   4001F3CC R
 4001F3C0 = 4001F3C0	     2		_LINK	= $				
 4001F3C0  81 28	     2		DB	IMEDD+1,'('			
			     2	ORG	_CODE					
			     1		align	4
 40001884  48		     1		db	048h		
 40001885  21 FB	     1		db	021h,0fbh	
 40001887  25 FA	     1		db	025h,0fah	
 40001889  84		     1		db	084h		
 4000188A  F0		     1		db	0f0h		
 4000188B  30		     1		db	030h		
 4000188C  F6		     1		db	0f6h		
 4000188D  00 00 00	     1		db	0,0,0
 40001890  400001C0 R	     1		dd	DOLST
 40001894  400001A8 R				DD	DOLIT,')',PARSE,DDROP,EXIT
	   00000029
	   40001814 R
	   40000708 R
	   400001D4 R

				;   \		( -- )
				;		Ignore following text till the end of line.

						$COLON	IMEDD+1,'\',BKSLA
			     1		$CODE	IMEDD+1,'\',BKSLA
			     2		ALIGN	4				
 400018A8		     2	BKSLA:						
 400018A8 = 400018A8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+1 AND 01FH)/CELLL		
 = 4001F3AC		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F3AC  400018A8 R	     2		DD	 _CODE,_LINK			
	   4001F3C0 R
 4001F3B4 = 4001F3B4	     2		_LINK	= $				
 4001F3B4  81 5C	     2		DB	IMEDD+1,'\'			
			     2	ORG	_CODE					
			     1		align	4
 400018A8  48		     1		db	048h		
 400018A9  21 FB	     1		db	021h,0fbh	
 400018AB  25 FA	     1		db	025h,0fah	
 400018AD  84		     1		db	084h		
 400018AE  F0		     1		db	0f0h		
 400018AF  30		     1		db	030h		
 400018B0  F6		     1		db	0f6h		
 400018B1  00 00 00	     1		db	0,0,0
 400018B4  400001C0 R	     1		dd	DOLST
 400018B8  4000057C R				DD	NTIB,AT,INN,STORE,EXIT
	   40000270 R
	   40000564 R
	   40000254 R
	   400001D4 R

				;   CHAR	( -- c )
				;		Parse next word and return its first character.

						$COLON	4,'CHAR',CHAR
			     1		$CODE	4,'CHAR',CHAR
			     2		ALIGN	4				
 400018CC		     2	CHAR:						
 400018CC = 400018CC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F39C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F39C  400018CC R	     2		DD	 _CODE,_LINK			
	   4001F3B4 R
 4001F3A4 = 4001F3A4	     2		_LINK	= $				
 4001F3A4  04 43 48 41 52    2		DB	4,'CHAR'			
			     2	ORG	_CODE					
			     1		align	4
 400018CC  48		     1		db	048h		
 400018CD  21 FB	     1		db	021h,0fbh	
 400018CF  25 FA	     1		db	025h,0fah	
 400018D1  84		     1		db	084h		
 400018D2  F0		     1		db	0f0h		
 400018D3  30		     1		db	030h		
 400018D4  F6		     1		db	0f6h		
 400018D5  00 00 00	     1		db	0,0,0
 400018D8  400001C0 R	     1		dd	DOLST
 400018DC  40000CC8 R				DD	BLANK,PARSE,DROP,CAT,EXIT
	   40001814 R
	   40000340 R
	   4000029C R
	   400001D4 R

				;   TOKEN	( -- a ; <string> )
				;		Parse a word from input stream and copy it to name dictionary.

						$COLON	5,'TOKEN',TOKEN
			     1		$CODE	5,'TOKEN',TOKEN
			     2		ALIGN	4				
 400018F0		     2	TOKEN:						
 400018F0 = 400018F0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F38C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F38C  400018F0 R	     2		DD	 _CODE,_LINK			
	   4001F3A4 R
 4001F394 = 4001F394	     2		_LINK	= $				
 4001F394  05 54 4F 4B 45    2		DB	5,'TOKEN'			
	   4E
			     2	ORG	_CODE					
			     1		align	4
 400018F0  48		     1		db	048h		
 400018F1  21 FB	     1		db	021h,0fbh	
 400018F3  25 FA	     1		db	025h,0fah	
 400018F5  84		     1		db	084h		
 400018F6  F0		     1		db	0f0h		
 400018F7  30		     1		db	030h		
 400018F8  F6		     1		db	0f6h		
 400018F9  00 00 00	     1		db	0,0,0
 400018FC  400001C0 R	     1		dd	DOLST
 40001900  40000CC8 R				DD	BLANK,PARSE,DOLIT,31,MIN
	   40001814 R
	   400001A8 R
	   0000001F
	   400008F4 R
 40001914  40000654 R				DD	NP,AT,OVER,SUBB,CELLM
	   40000270 R
	   40000378 R
	   400007D4 R
	   40000C38 R
 40001928  40000FC8 R				DD	PACKS,EXIT
	   400001D4 R

				;   WORD	( c -- a ; <string> )
				;		Parse a word from input stream and copy it to code dictionary.

						$COLON	4,'WORD',WORDD
			     1		$CODE	4,'WORD',WORDD
			     2		ALIGN	4				
 40001930		     2	WORDD:						
 40001930 = 40001930	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F37C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F37C  40001930 R	     2		DD	 _CODE,_LINK			
	   4001F394 R
 4001F384 = 4001F384	     2		_LINK	= $				
 4001F384  04 57 4F 52 44    2		DB	4,'WORD'			
			     2	ORG	_CODE					
			     1		align	4
 40001930  48		     1		db	048h		
 40001931  21 FB	     1		db	021h,0fbh	
 40001933  25 FA	     1		db	025h,0fah	
 40001935  84		     1		db	084h		
 40001936  F0		     1		db	0f0h		
 40001937  30		     1		db	030h		
 40001938  F6		     1		db	0f6h		
 40001939  00 00 00	     1		db	0,0,0
 4000193C  400001C0 R	     1		dd	DOLST
 40001940  40001814 R				DD	PARSE,HERE,PACKS,EXIT
	   40000E38 R
	   40000FC8 R
	   400001D4 R

				;; Dictionary search

				;   NAME>	( na -- ca )
				;		Return a code address given a name address.

						$COLON	5,'NAME>',NAMET
			     1		$CODE	5,'NAME>',NAMET
			     2		ALIGN	4				
 40001950		     2	NAMET:						
 40001950 = 40001950	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F36C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F36C  40001950 R	     2		DD	 _CODE,_LINK			
	   4001F384 R
 4001F374 = 4001F374	     2		_LINK	= $				
 4001F374  05 4E 41 4D 45    2		DB	5,'NAME>'			
	   3E
			     2	ORG	_CODE					
			     1		align	4
 40001950  48		     1		db	048h		
 40001951  21 FB	     1		db	021h,0fbh	
 40001953  25 FA	     1		db	025h,0fah	
 40001955  84		     1		db	084h		
 40001956  F0		     1		db	0f0h		
 40001957  30		     1		db	030h		
 40001958  F6		     1		db	0f6h		
 40001959  00 00 00	     1		db	0,0,0
 4000195C  400001C0 R	     1		dd	DOLST
 40001960  40000C38 R				DD	CELLM,CELLM,AT,EXIT
	   40000C38 R
	   40000270 R
	   400001D4 R

				;   SAME?	( a a u -- a a f \ -0+ )
				;		Compare u cells in two strings. Return 0 if identical.

						$COLON	5,'SAME?',SAMEQ
			     1		$CODE	5,'SAME?',SAMEQ
			     2		ALIGN	4				
 40001970		     2	SAMEQ:						
 40001970 = 40001970	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F35C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F35C  40001970 R	     2		DD	 _CODE,_LINK			
	   4001F374 R
 4001F364 = 4001F364	     2		_LINK	= $				
 4001F364  05 53 41 4D 45    2		DB	5,'SAME?'			
	   3F
			     2	ORG	_CODE					
			     1		align	4
 40001970  48		     1		db	048h		
 40001971  21 FB	     1		db	021h,0fbh	
 40001973  25 FA	     1		db	025h,0fah	
 40001975  84		     1		db	084h		
 40001976  F0		     1		db	0f0h		
 40001977  30		     1		db	030h		
 40001978  F6		     1		db	0f6h		
 40001979  00 00 00	     1		db	0,0,0
 4000197C  400001C0 R	     1		dd	DOLST
 40001980  40000300 R				DD	TOR
 40001984  40000244 R				DD	BRAN,SAME2
	   400019D0 R
 4000198C 40000378 R		SAME1:		DD	OVER,RAT,CELLS,PLUS,AT
	   400002EC R
	   40000C58 R
	   40000740 R
	   40000270 R
 400019A0  40000378 R				DD	OVER,RAT,CELLS,PLUS,AT
	   400002EC R
	   40000C58 R
	   40000740 R
	   40000270 R
 400019B4  400007D4 R				DD	SUBB,QDUP
	   400006C0 R
 400019BC  40000220 R				DD	QBRAN,SAME2
	   400019D0 R
 400019C4  400002D4 R				DD	RFROM,DROP,EXIT 	;strings not equal
	   40000340 R
	   400001D4 R
 400019D0 400001F0 R		SAME2:		DD	DONXT,SAME1
	   4000198C R
 400019D8  400001A8 R				DD	DOLIT,0,EXIT		;strings equal
	   00000000
	   400001D4 R

				;   find	( a va -- ca na | a F )
				;		Search a vocabulary for a string. Return ca and na if succeeded.

						$COLON	4,'find',FIND
			     1		$CODE	4,'find',FIND
			     2		ALIGN	4				
 400019E4		     2	FIND:						
 400019E4 = 400019E4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F34C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F34C  400019E4 R	     2		DD	 _CODE,_LINK			
	   4001F364 R
 4001F354 = 4001F354	     2		_LINK	= $				
 4001F354  04 66 69 6E 64    2		DB	4,'find'			
			     2	ORG	_CODE					
			     1		align	4
 400019E4  48		     1		db	048h		
 400019E5  21 FB	     1		db	021h,0fbh	
 400019E7  25 FA	     1		db	025h,0fah	
 400019E9  84		     1		db	084h		
 400019EA  F0		     1		db	0f0h		
 400019EB  30		     1		db	030h		
 400019EC  F6		     1		db	0f6h		
 400019ED  00 00 00	     1		db	0,0,0
 400019F0  400001C0 R	     1		dd	DOLST
 400019F4  40000364 R				DD	SWAP,DUPP,CAT
	   40000350 R
	   4000029C R
 40001A00  400001A8 R				DD	DOLIT,CELLL,SLASH,TEMP,STORE
	   00000004
	   40000AD8 R
	   40000534 R
	   40000254 R
 40001A14  40000350 R				DD	DUPP,AT,TOR,CELLP,SWAP
	   40000270 R
	   40000300 R
	   40000C18 R
	   40000364 R
 40001A28 40000270 R		FIND1:		DD	AT,DUPP
	   40000350 R
 40001A30  40000220 R				DD	QBRAN,FIND6
	   40001A88 R
 40001A38  40000350 R				DD	DUPP,AT,DOLIT,MASKK,ANDD,RAT,XORR
	   40000270 R
	   400001A8 R
	   00007F1F
	   400003A4 R
	   400002EC R
	   400003D4 R
 40001A54  40000220 R				DD	QBRAN,FIND2
	   40001A70 R
 40001A5C  40000C18 R				DD	CELLP,DOLIT,-1		;true flag
	   400001A8 R
	   FFFFFFFF
 40001A68  40000244 R				DD	BRAN,FIND3
	   40001A80 R
 40001A70 40000C18 R		FIND2:		DD	CELLP,TEMP,AT,SAMEQ
	   40000534 R
	   40000270 R
	   40001970 R
 40001A80 40000244 R		FIND3:		DD	BRAN,FIND4
	   40001AA0 R
 40001A88 400002D4 R		FIND6:		DD	RFROM,DROP
	   40000340 R
 40001A90  40000364 R				DD	SWAP,CELLM,SWAP,EXIT
	   40000C38 R
	   40000364 R
	   400001D4 R
 40001AA0 40000220 R		FIND4:		DD	QBRAN,FIND5
	   40001AB8 R
 40001AA8  40000C38 R				DD	CELLM,CELLM
	   40000C38 R
 40001AB0  40000244 R				DD	BRAN,FIND1
	   40001A28 R
 40001AB8 400002D4 R		FIND5:		DD	RFROM,DROP,SWAP,DROP
	   40000340 R
	   40000364 R
	   40000340 R
 40001AC8  40000C38 R				DD	CELLM
 40001ACC  40000350 R				DD	DUPP,NAMET,SWAP,EXIT
	   40001950 R
	   40000364 R
	   400001D4 R

				;   NAME?	( a -- ca na | a F )
				;		Search all context vocabularies for a string.

						$COLON	5,'NAME?',NAMEQ
			     1		$CODE	5,'NAME?',NAMEQ
			     2		ALIGN	4				
 40001ADC		     2	NAMEQ:						
 40001ADC = 40001ADC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F33C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F33C  40001ADC R	     2		DD	 _CODE,_LINK			
	   4001F354 R
 4001F344 = 4001F344	     2		_LINK	= $				
 4001F344  05 4E 41 4D 45    2		DB	5,'NAME?'			
	   3F
			     2	ORG	_CODE					
			     1		align	4
 40001ADC  48		     1		db	048h		
 40001ADD  21 FB	     1		db	021h,0fbh	
 40001ADF  25 FA	     1		db	025h,0fah	
 40001AE1  84		     1		db	084h		
 40001AE2  F0		     1		db	0f0h		
 40001AE3  30		     1		db	030h		
 40001AE4  F6		     1		db	0f6h		
 40001AE5  00 00 00	     1		db	0,0,0
 40001AE8  400001C0 R	     1		dd	DOLST
 40001AEC  4000060C R				DD	CNTXT,DUPP,DAT,XORR	;?context=also
	   40000350 R
	   40000DE4 R
	   400003D4 R
 40001AFC  40000220 R				DD	QBRAN,NAMQ1
	   40001B08 R
 40001B04  40000C38 R				DD	CELLM			;no, start with context
 40001B08 40000300 R		NAMQ1:		DD	TOR
 40001B0C 400002D4 R		NAMQ2:		DD	RFROM,CELLP,DUPP,TOR	;next in search order
	   40000C18 R
	   40000350 R
	   40000300 R
 40001B1C  40000270 R				DD	AT,QDUP
	   400006C0 R
 40001B24  40000220 R				DD	QBRAN,NAMQ3
	   40001B48 R
 40001B2C  400019E4 R				DD	FIND,QDUP		;search vocabulary
	   400006C0 R
 40001B34  40000220 R				DD	QBRAN,NAMQ2
	   40001B0C R
 40001B3C  400002D4 R				DD	RFROM,DROP,EXIT 	;found name
	   40000340 R
	   400001D4 R
 40001B48 400002D4 R		NAMQ3:		DD	RFROM,DROP		;name not found
	   40000340 R
 40001B50  400001A8 R				DD	DOLIT,0,EXIT		;false flag
	   00000000
	   400001D4 R

				;; Terminal response

				;   ^H		( bot eot cur -- bot eot cur )
				;		Backup the cursor by one character.

						$COLON	2,'^H',BKSP
			     1		$CODE	2,'^H',BKSP
			     2		ALIGN	4				
 40001B5C		     2	BKSP:						
 40001B5C = 40001B5C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001F330		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F330  40001B5C R	     2		DD	 _CODE,_LINK			
	   4001F344 R
 4001F338 = 4001F338	     2		_LINK	= $				
 4001F338  02 5E 48	     2		DB	2,'^H'			
			     2	ORG	_CODE					
			     1		align	4
 40001B5C  48		     1		db	048h		
 40001B5D  21 FB	     1		db	021h,0fbh	
 40001B5F  25 FA	     1		db	025h,0fah	
 40001B61  84		     1		db	084h		
 40001B62  F0		     1		db	0f0h		
 40001B63  30		     1		db	030h		
 40001B64  F6		     1		db	0f6h		
 40001B65  00 00 00	     1		db	0,0,0
 40001B68  400001C0 R	     1		dd	DOLST
 40001B6C  40000300 R				DD	TOR,OVER,RFROM,SWAP,OVER,XORR
	   40000378 R
	   400002D4 R
	   40000364 R
	   40000378 R
	   400003D4 R
 40001B84  40000220 R				DD	QBRAN,BACK1
	   40001BC4 R
 40001B8C  400001A8 R				DD	DOLIT,BKSPP,TECHO,ATEXE,DOLIT,1,SUBB
	   00000008
	   400004EC R
	   40000E98 R
	   400001A8 R
	   00000001
	   400007D4 R
 40001BA8  40000CC8 R				DD	BLANK,TECHO,ATEXE
	   400004EC R
	   40000E98 R
 40001BB4  400001A8 R				DD	DOLIT,BKSPP,TECHO,ATEXE
	   00000008
	   400004EC R
	   40000E98 R
 40001BC4 400001D4 R		BACK1:		DD	EXIT

				;   TAP 	( bot eot cur c -- bot eot cur )
				;		Accept and echo the key stroke and bump the cursor.

						$COLON	3,'TAP',TAP
			     1		$CODE	3,'TAP',TAP
			     2		ALIGN	4				
 40001BC8		     2	TAP:						
 40001BC8 = 40001BC8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F324		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F324  40001BC8 R	     2		DD	 _CODE,_LINK			
	   4001F338 R
 4001F32C = 4001F32C	     2		_LINK	= $				
 4001F32C  03 54 41 50	     2		DB	3,'TAP'			
			     2	ORG	_CODE					
			     1		align	4
 40001BC8  48		     1		db	048h		
 40001BC9  21 FB	     1		db	021h,0fbh	
 40001BCB  25 FA	     1		db	025h,0fah	
 40001BCD  84		     1		db	084h		
 40001BCE  F0		     1		db	0f0h		
 40001BCF  30		     1		db	030h		
 40001BD0  F6		     1		db	0f6h		
 40001BD1  00 00 00	     1		db	0,0,0
 40001BD4  400001C0 R	     1		dd	DOLST
 40001BD8  40000350 R				DD	DUPP,TECHO,ATEXE
	   400004EC R
	   40000E98 R
 40001BE4  40000378 R				DD	OVER,CSTOR,DOLIT,1,PLUS,EXIT
	   40000280 R
	   400001A8 R
	   00000001
	   40000740 R
	   400001D4 R

				;   kTAP	( bot eot cur c -- bot eot cur )
				;		Process a key stroke, CR or backspace.

						$COLON	4,'kTAP',KTAP
			     1		$CODE	4,'kTAP',KTAP
			     2		ALIGN	4				
 40001BFC		     2	KTAP:						
 40001BFC = 40001BFC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F314		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F314  40001BFC R	     2		DD	 _CODE,_LINK			
	   4001F32C R
 4001F31C = 4001F31C	     2		_LINK	= $				
 4001F31C  04 6B 54 41 50    2		DB	4,'kTAP'			
			     2	ORG	_CODE					
			     1		align	4
 40001BFC  48		     1		db	048h		
 40001BFD  21 FB	     1		db	021h,0fbh	
 40001BFF  25 FA	     1		db	025h,0fah	
 40001C01  84		     1		db	084h		
 40001C02  F0		     1		db	0f0h		
 40001C03  30		     1		db	030h		
 40001C04  F6		     1		db	0f6h		
 40001C05  00 00 00	     1		db	0,0,0
 40001C08  400001C0 R	     1		dd	DOLST
 40001C0C  40000350 R				DD	DUPP,DOLIT,CRR,XORR
	   400001A8 R
	   0000000D
	   400003D4 R
 40001C1C  40000220 R				DD	QBRAN,KTAP2
	   40001C4C R
 40001C24  400001A8 R				DD	DOLIT,BKSPP,XORR
	   00000008
	   400003D4 R
 40001C30  40000220 R				DD	QBRAN,KTAP1
	   40001C44 R
 40001C38  40000CC8 R				DD	BLANK,TAP,EXIT
	   40001BC8 R
	   400001D4 R
 40001C44 40001B5C R		KTAP1:		DD	BKSP,EXIT
	   400001D4 R
 40001C4C 40000340 R		KTAP2:		DD	DROP,SWAP,DROP,DUPP,EXIT
	   40000364 R
	   40000340 R
	   40000350 R
	   400001D4 R

				;   accept	( b u -- b u )
				;		Accept characters to input buffer. Return with actual count.

						$COLON	6,'accept',ACCEP
			     1		$CODE	6,'accept',ACCEP
			     2		ALIGN	4				
 40001C60		     2	ACCEP:						
 40001C60 = 40001C60	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F304		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F304  40001C60 R	     2		DD	 _CODE,_LINK			
	   4001F31C R
 4001F30C = 4001F30C	     2		_LINK	= $				
 4001F30C  06 61 63 63 65    2		DB	6,'accept'			
	   70 74
			     2	ORG	_CODE					
			     1		align	4
 40001C60  48		     1		db	048h		
 40001C61  21 FB	     1		db	021h,0fbh	
 40001C63  25 FA	     1		db	025h,0fah	
 40001C65  84		     1		db	084h		
 40001C66  F0		     1		db	0f0h		
 40001C67  30		     1		db	030h		
 40001C68  F6		     1		db	0f6h		
 40001C69  00 00 00	     1		db	0,0,0
 40001C6C  400001C0 R	     1		dd	DOLST
 40001C70  40000378 R				DD	OVER,PLUS,OVER
	   40000740 R
	   40000378 R
 40001C7C 40000724 R		ACCP1:		DD	DDUP,XORR
	   400003D4 R
 40001C84  40000220 R				DD	QBRAN,ACCP4
	   40001CC8 R
 40001C8C  4000140C R				DD	KEY,DUPP
	   40000350 R
				;		DD	BLANK,SUBB,DOLIT,95,ULESS
 40001C94  40000CC8 R				DD	BLANK,DOLIT,127,WITHI
	   400001A8 R
	   0000007F
	   40000924 R
 40001CA4  40000220 R				DD	QBRAN,ACCP2
	   40001CB8 R
 40001CAC  40001BC8 R				DD	TAP
 40001CB0  40000244 R				DD	BRAN,ACCP3
	   40001CC0 R
 40001CB8 400004D4 R		ACCP2:		DD	TTAP,ATEXE
	   40000E98 R
 40001CC0 40000244 R		ACCP3:		DD	BRAN,ACCP1
	   40001C7C R
 40001CC8 40000340 R		ACCP4:		DD	DROP,OVER,SUBB,EXIT
	   40000378 R
	   400007D4 R
	   400001D4 R

				;   EXPECT	( b u -- )
				;		Accept input stream and store count in SPAN.

						$COLON	6,'EXPECT',EXPEC
			     1		$CODE	6,'EXPECT',EXPEC
			     2		ALIGN	4				
 40001CD8		     2	EXPEC:						
 40001CD8 = 40001CD8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F2F4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2F4  40001CD8 R	     2		DD	 _CODE,_LINK			
	   4001F30C R
 4001F2FC = 4001F2FC	     2		_LINK	= $				
 4001F2FC  06 45 58 50 45    2		DB	6,'EXPECT'			
	   43 54
			     2	ORG	_CODE					
			     1		align	4
 40001CD8  48		     1		db	048h		
 40001CD9  21 FB	     1		db	021h,0fbh	
 40001CDB  25 FA	     1		db	025h,0fah	
 40001CDD  84		     1		db	084h		
 40001CDE  F0		     1		db	0f0h		
 40001CDF  30		     1		db	030h		
 40001CE0  F6		     1		db	0f6h		
 40001CE1  00 00 00	     1		db	0,0,0
 40001CE4  400001C0 R	     1		dd	DOLST
 40001CE8  400004BC R				DD	TEXPE,ATEXE,SPAN,STORE,DROP,EXIT
	   40000E98 R
	   4000054C R
	   40000254 R
	   40000340 R
	   400001D4 R

				;   QUERY	( -- )
				;		Accept input stream to terminal input buffer.

						$COLON	5,'QUERY',QUERY
			     1		$CODE	5,'QUERY',QUERY
			     2		ALIGN	4				
 40001D00		     2	QUERY:						
 40001D00 = 40001D00	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F2E4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2E4  40001D00 R	     2		DD	 _CODE,_LINK			
	   4001F2FC R
 4001F2EC = 4001F2EC	     2		_LINK	= $				
 4001F2EC  05 51 55 45 52    2		DB	5,'QUERY'			
	   59
			     2	ORG	_CODE					
			     1		align	4
 40001D00  48		     1		db	048h		
 40001D01  21 FB	     1		db	021h,0fbh	
 40001D03  25 FA	     1		db	025h,0fah	
 40001D05  84		     1		db	084h		
 40001D06  F0		     1		db	0f0h		
 40001D07  30		     1		db	030h		
 40001D08  F6		     1		db	0f6h		
 40001D09  00 00 00	     1		db	0,0,0
 40001D0C  400001C0 R	     1		dd	DOLST
 40001D10  40000E78 R				DD	TIB,DOLIT,80,TEXPE,ATEXE,NTIB,STORE
	   400001A8 R
	   00000050
	   400004BC R
	   40000E98 R
	   4000057C R
	   40000254 R
 40001D2C  40000340 R				DD	DROP,DOLIT,0,INN,STORE,EXIT
	   400001A8 R
	   00000000
	   40000564 R
	   40000254 R
	   400001D4 R

				;; Error handling

				;   CATCH	( ca -- 0 | err# )
				;		Execute word at ca and set up an error frame for it.

						$COLON	5,'CATCH',CATCH
			     1		$CODE	5,'CATCH',CATCH
			     2		ALIGN	4				
 40001D44		     2	CATCH:						
 40001D44 = 40001D44	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F2D4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2D4  40001D44 R	     2		DD	 _CODE,_LINK			
	   4001F2EC R
 4001F2DC = 4001F2DC	     2		_LINK	= $				
 4001F2DC  05 43 41 54 43    2		DB	5,'CATCH'			
	   48
			     2	ORG	_CODE					
			     1		align	4
 40001D44  48		     1		db	048h		
 40001D45  21 FB	     1		db	021h,0fbh	
 40001D47  25 FA	     1		db	025h,0fah	
 40001D49  84		     1		db	084h		
 40001D4A  F0		     1		db	0f0h		
 40001D4B  30		     1		db	030h		
 40001D4C  F6		     1		db	0f6h		
 40001D4D  00 00 00	     1		db	0,0,0
 40001D50  400001C0 R	     1		dd	DOLST
 40001D54  40000318 R				DD	SPAT,TOR,HANDL,AT,TOR	;save error frame
	   40000300 R
	   400005F4 R
	   40000270 R
	   40000300 R
 40001D68  400002AC R				DD	RPAT,HANDL,STORE,EXECU	;execute
	   400005F4 R
	   40000254 R
	   400001E8 R
 40001D78  400002D4 R				DD	RFROM,HANDL,STORE	;restore error frame
	   400005F4 R
	   40000254 R
 40001D84  400002D4 R				DD	RFROM,DROP,DOLIT,0,EXIT ;no error
	   40000340 R
	   400001A8 R
	   00000000
	   400001D4 R

				;   THROW	( err# -- err# )
				;		Reset system to current local error frame an update error flag.

						$COLON	5,'THROW',THROW
			     1		$CODE	5,'THROW',THROW
			     2		ALIGN	4				
 40001D98		     2	THROW:						
 40001D98 = 40001D98	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F2C4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2C4  40001D98 R	     2		DD	 _CODE,_LINK			
	   4001F2DC R
 4001F2CC = 4001F2CC	     2		_LINK	= $				
 4001F2CC  05 54 48 52 4F    2		DB	5,'THROW'			
	   57
			     2	ORG	_CODE					
			     1		align	4
 40001D98  48		     1		db	048h		
 40001D99  21 FB	     1		db	021h,0fbh	
 40001D9B  25 FA	     1		db	025h,0fah	
 40001D9D  84		     1		db	084h		
 40001D9E  F0		     1		db	0f0h		
 40001D9F  30		     1		db	030h		
 40001DA0  F6		     1		db	0f6h		
 40001DA1  00 00 00	     1		db	0,0,0
 40001DA4  400001C0 R	     1		dd	DOLST
 40001DA8  400005F4 R				DD	HANDL,AT,RPSTO		;restore return stack
	   40000270 R
	   400002C0 R
 40001DB4  400002D4 R				DD	RFROM,HANDL,STORE	;restore handler frame
	   400005F4 R
	   40000254 R
 40001DC0  400002D4 R				DD	RFROM,SWAP,TOR,SPSTO	;restore data stack
	   40000364 R
	   40000300 R
	   4000032C R
 40001DD0  40000340 R				DD	DROP,RFROM,EXIT
	   400002D4 R
	   400001D4 R

				;   NULL$	( -- a )
				;		Return address of a null string with zero count.

						$COLON	5,'NULL$',NULLS
			     1		$CODE	5,'NULL$',NULLS
			     2		ALIGN	4				
 40001DDC		     2	NULLS:						
 40001DDC = 40001DDC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F2B4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2B4  40001DDC R	     2		DD	 _CODE,_LINK			
	   4001F2CC R
 4001F2BC = 4001F2BC	     2		_LINK	= $				
 4001F2BC  05 4E 55 4C 4C    2		DB	5,'NULL$'			
	   24
			     2	ORG	_CODE					
			     1		align	4
 40001DDC  48		     1		db	048h		
 40001DDD  21 FB	     1		db	021h,0fbh	
 40001DDF  25 FA	     1		db	025h,0fah	
 40001DE1  84		     1		db	084h		
 40001DE2  F0		     1		db	0f0h		
 40001DE3  30		     1		db	030h		
 40001DE4  F6		     1		db	0f6h		
 40001DE5  00 00 00	     1		db	0,0,0
 40001DE8  400001C0 R	     1		dd	DOLST
 40001DEC  40000404 R				DD	DOVAR			;emulate CREATE
 40001DF0  00000000				DD	0
 40001DF4  63 6F 79 6F 74			DB	99,111,121,111,116,101
	   65
						ALIGN	4

				;   ABORT	( -- )
				;		Reset data stack and jump to QUIT.

						$COLON	5,'ABORT',ABORT
			     1		$CODE	5,'ABORT',ABORT
			     2		ALIGN	4				
 40001DFC		     2	ABORT:						
 40001DFC = 40001DFC	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F2A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F2A4  40001DFC R	     2		DD	 _CODE,_LINK			
	   4001F2BC R
 4001F2AC = 4001F2AC	     2		_LINK	= $				
 4001F2AC  05 41 42 4F 52    2		DB	5,'ABORT'			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40001DFC  48		     1		db	048h		
 40001DFD  21 FB	     1		db	021h,0fbh	
 40001DFF  25 FA	     1		db	025h,0fah	
 40001E01  84		     1		db	084h		
 40001E02  F0		     1		db	0f0h		
 40001E03  30		     1		db	030h		
 40001E04  F6		     1		db	0f6h		
 40001E05  00 00 00	     1		db	0,0,0
 40001E08  400001C0 R	     1		dd	DOLST
 40001E0C  40001DDC R				DD	NULLS,THROW
	   40001D98 R

				;   abort"      ( f -- )
				;		Run time routine of ABORT" . Abort with a message.

						$COLON	COMPO+6,'abort"',ABORQ
			     1		$CODE	COMPO+6,'abort"',ABORQ
			     2		ALIGN	4				
 40001E14		     2	ABORQ:						
 40001E14 = 40001E14	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (COMPO+6 AND 01FH)/CELLL		
 = 4001F294		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F294  40001E14 R	     2		DD	 _CODE,_LINK			
	   4001F2AC R
 4001F29C = 4001F29C	     2		_LINK	= $				
 4001F29C  46 61 62 6F 72    2		DB	COMPO+6,'abort"'			
	   74 22
			     2	ORG	_CODE					
			     1		align	4
 40001E14  48		     1		db	048h		
 40001E15  21 FB	     1		db	021h,0fbh	
 40001E17  25 FA	     1		db	025h,0fah	
 40001E19  84		     1		db	084h		
 40001E1A  F0		     1		db	0f0h		
 40001E1B  30		     1		db	030h		
 40001E1C  F6		     1		db	0f6h		
 40001E1D  00 00 00	     1		db	0,0,0
 40001E20  400001C0 R	     1		dd	DOLST
 40001E24  40000220 R				DD	QBRAN,ABOR1		;text flag
	   40001E34 R
 40001E2C  40001564 R				DD	DOSTR,THROW		;pass error string
	   40001D98 R
 40001E34 40001564 R		ABOR1:		DD	DOSTR,DROP,EXIT 	;drop error
	   40000340 R
	   400001D4 R

				;; The text interpreter

				;   $INTERPRET	( a -- )
				;		Interpret a word. If failed, try to convert it to an integer.

						$COLON	10,'$INTERPRET',INTER
			     1		$CODE	10,'$INTERPRET',INTER
			     2		ALIGN	4				
 40001E40		     2	INTER:						
 40001E40 = 40001E40	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (10 AND 01FH)/CELLL		
 = 4001F280		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F280  40001E40 R	     2		DD	 _CODE,_LINK			
	   4001F29C R
 4001F288 = 4001F288	     2		_LINK	= $				
 4001F288  0A 24 49 4E 54    2		DB	10,'$INTERPRET'			
	   45 52 50 52 45
	   54
			     2	ORG	_CODE					
			     1		align	4
 40001E40  48		     1		db	048h		
 40001E41  21 FB	     1		db	021h,0fbh	
 40001E43  25 FA	     1		db	025h,0fah	
 40001E45  84		     1		db	084h		
 40001E46  F0		     1		db	0f0h		
 40001E47  30		     1		db	030h		
 40001E48  F6		     1		db	0f6h		
 40001E49  00 00 00	     1		db	0,0,0
 40001E4C  400001C0 R	     1		dd	DOLST
 40001E50  40001ADC R				DD	NAMEQ,QDUP		;?defined
	   400006C0 R
 40001E58  40000220 R				DD	QBRAN,INTE1
	   40001E8C R
 40001E60  40000270 R				DD	AT,DOLIT,COMPO,ANDD	;?compile only lexicon bits
	   400001A8 R
	   00000040
	   400003A4 R
						D$	ABORQ,' compile only'
 40001E70  40001E14 R	     1		DD	ABORQ				
 40001E74 = 40001E74	     1		_LEN	= $				
 40001E74  00 20 63 6F 6D    1		DB	0,' compile only' 			
	   70 69 6C 65 20
	   6F 6E 6C 79
 40001E82 = 40001E82	     1		_CODE	= $				
			     1	ORG	_LEN					
 40001E74  0D		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 40001E84  400001E8 R				DD	EXECU,EXIT		;execute defined word
	   400001D4 R
 40001E8C 400005C4 R		INTE1:		DD	TNUMB,ATEXE		;convert a number
	   40000E98 R
 40001E94  40000220 R				DD	QBRAN,INTE2
	   40001EA0 R
 40001E9C  400001D4 R				DD	EXIT
 40001EA0 40001D98 R		INTE2:		DD	THROW			;error

				;   [		( -- )
				;		Start the text interpreter.

						$COLON	IMEDD+1,'[',LBRAC
			     1		$CODE	IMEDD+1,'[',LBRAC
			     2		ALIGN	4				
 40001EA4		     2	LBRAC:						
 40001EA4 = 40001EA4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+1 AND 01FH)/CELLL		
 = 4001F274		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F274  40001EA4 R	     2		DD	 _CODE,_LINK			
	   4001F288 R
 4001F27C = 4001F27C	     2		_LINK	= $				
 4001F27C  81 5B	     2		DB	IMEDD+1,'['			
			     2	ORG	_CODE					
			     1		align	4
 40001EA4  48		     1		db	048h		
 40001EA5  21 FB	     1		db	021h,0fbh	
 40001EA7  25 FA	     1		db	025h,0fah	
 40001EA9  84		     1		db	084h		
 40001EAA  F0		     1		db	0f0h		
 40001EAB  30		     1		db	030h		
 40001EAC  F6		     1		db	0f6h		
 40001EAD  00 00 00	     1		db	0,0,0
 40001EB0  400001C0 R	     1		dd	DOLST
 40001EB4  400001A8 R				DD	DOLIT,INTER,TEVAL,STORE,EXIT
	   40001E40 R
	   400005AC R
	   40000254 R
	   400001D4 R

				;   .OK 	( -- )
				;		Display 'ok' only while interpreting.

						$COLON	3,'.OK',DOTOK
			     1		$CODE	3,'.OK',DOTOK
			     2		ALIGN	4				
 40001EC8		     2	DOTOK:						
 40001EC8 = 40001EC8	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F268		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F268  40001EC8 R	     2		DD	 _CODE,_LINK			
	   4001F27C R
 4001F270 = 4001F270	     2		_LINK	= $				
 4001F270  03 2E 4F 4B	     2		DB	3,'.OK'			
			     2	ORG	_CODE					
			     1		align	4
 40001EC8  48		     1		db	048h		
 40001EC9  21 FB	     1		db	021h,0fbh	
 40001ECB  25 FA	     1		db	025h,0fah	
 40001ECD  84		     1		db	084h		
 40001ECE  F0		     1		db	0f0h		
 40001ECF  30		     1		db	030h		
 40001ED0  F6		     1		db	0f6h		
 40001ED1  00 00 00	     1		db	0,0,0
 40001ED4  400001C0 R	     1		dd	DOLST
 40001ED8  400001A8 R				DD	DOLIT,INTER,TEVAL,AT,EQUAL
	   40001E40 R
	   400005AC R
	   40000270 R
	   40000818 R
 40001EEC  40000220 R				DD	QBRAN,DOTO1
	   40001EFC R
						D$	DOTQP,' ok'
 40001EF4  400015B4 R	     1		DD	DOTQP				
 40001EF8 = 40001EF8	     1		_LEN	= $				
 40001EF8  00 20 6F 6B	     1		DB	0,' ok' 			
 40001EFC = 40001EFC	     1		_CODE	= $				
			     1	ORG	_LEN					
 40001EF8  03		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 40001EFC 40001538 R		DOTO1:		DD	CR,EXIT
	   400001D4 R

				;   ?STACK	( -- )
				;		Abort if the data stack underflows.

						$COLON	6,'?STACK',QSTAC
			     1		$CODE	6,'?STACK',QSTAC
			     2		ALIGN	4				
 40001F04		     2	QSTAC:						
 40001F04 = 40001F04	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F258		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F258  40001F04 R	     2		DD	 _CODE,_LINK			
	   4001F270 R
 4001F260 = 4001F260	     2		_LINK	= $				
 4001F260  06 3F 53 54 41    2		DB	6,'?STACK'			
	   43 4B
			     2	ORG	_CODE					
			     1		align	4
 40001F04  48		     1		db	048h		
 40001F05  21 FB	     1		db	021h,0fbh	
 40001F07  25 FA	     1		db	025h,0fah	
 40001F09  84		     1		db	084h		
 40001F0A  F0		     1		db	0f0h		
 40001F0B  30		     1		db	030h		
 40001F0C  F6		     1		db	0f6h		
 40001F0D  00 00 00	     1		db	0,0,0
 40001F10  400001C0 R	     1		dd	DOLST
 40001F14  40000D2C R				DD	DEPTH,ZLESS		;check only for underflow
	   4000038C R
						D$	ABORQ,' underflow'
 40001F1C  40001E14 R	     1		DD	ABORQ				
 40001F20 = 40001F20	     1		_LEN	= $				
 40001F20  00 20 75 6E 64    1		DB	0,' underflow' 			
	   65 72 66 6C 6F
	   77
 40001F2B = 40001F2B	     1		_CODE	= $				
			     1	ORG	_LEN					
 40001F20  0A		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 40001F2C  400001D4 R				DD	EXIT

				;   EVAL	( -- )
				;		Interpret the input stream.

						$COLON	4,'EVAL',EVAL
			     1		$CODE	4,'EVAL',EVAL
			     2		ALIGN	4				
 40001F30		     2	EVAL:						
 40001F30 = 40001F30	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F248		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F248  40001F30 R	     2		DD	 _CODE,_LINK			
	   4001F260 R
 4001F250 = 4001F250	     2		_LINK	= $				
 4001F250  04 45 56 41 4C    2		DB	4,'EVAL'			
			     2	ORG	_CODE					
			     1		align	4
 40001F30  48		     1		db	048h		
 40001F31  21 FB	     1		db	021h,0fbh	
 40001F33  25 FA	     1		db	025h,0fah	
 40001F35  84		     1		db	084h		
 40001F36  F0		     1		db	0f0h		
 40001F37  30		     1		db	030h		
 40001F38  F6		     1		db	0f6h		
 40001F39  00 00 00	     1		db	0,0,0
 40001F3C  400001C0 R	     1		dd	DOLST
 40001F40 400018F0 R		EVAL1:		DD	TOKEN,DUPP,CAT		;?input stream empty
	   40000350 R
	   4000029C R
 40001F4C  40000220 R				DD	QBRAN,EVAL2
	   40001F68 R
 40001F54  400005AC R				DD	TEVAL,ATEXE,QSTAC	;evaluate input, check stack
	   40000E98 R
	   40001F04 R
 40001F60  40000244 R				DD	BRAN,EVAL1
	   40001F40 R
 40001F68 40000340 R		EVAL2:		DD	DROP,TPROM,ATEXE,EXIT	;prompt
	   40000504 R
	   40000E98 R
	   400001D4 R

				;; Shell

				;   PRESET	( -- )
				;		Reset data stack pointer and the terminal input buffer.

						$COLON	6,'PRESET',PRESE
			     1		$CODE	6,'PRESET',PRESE
			     2		ALIGN	4				
 40001F78		     2	PRESE:						
 40001F78 = 40001F78	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001F238		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F238  40001F78 R	     2		DD	 _CODE,_LINK			
	   4001F250 R
 4001F240 = 4001F240	     2		_LINK	= $				
 4001F240  06 50 52 45 53    2		DB	6,'PRESET'			
	   45 54
			     2	ORG	_CODE					
			     1		align	4
 40001F78  48		     1		db	048h		
 40001F79  21 FB	     1		db	021h,0fbh	
 40001F7B  25 FA	     1		db	025h,0fah	
 40001F7D  84		     1		db	084h		
 40001F7E  F0		     1		db	0f0h		
 40001F7F  30		     1		db	030h		
 40001F80  F6		     1		db	0f6h		
 40001F81  00 00 00	     1		db	0,0,0
 40001F84  400001C0 R	     1		dd	DOLST
 40001F88  4000045C R				DD	SZERO,AT,SPSTO
	   40000270 R
	   4000032C R
 40001F94  400001A8 R				DD	DOLIT,TIBB,NTIB,CELLP,STORE,EXIT
	   4001FE5C
	   4000057C R
	   40000C18 R
	   40000254 R
	   400001D4 R

				;   xio 	( a a a -- )
				;		Reset the I/O vectors 'EXPECT, 'TAP, 'ECHO and 'PROMPT.

						$COLON	COMPO+3,'xio',XIO
			     1		$CODE	COMPO+3,'xio',XIO
			     2		ALIGN	4				
 40001FAC		     2	XIO:						
 40001FAC = 40001FAC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (COMPO+3 AND 01FH)/CELLL		
 = 4001F22C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F22C  40001FAC R	     2		DD	 _CODE,_LINK			
	   4001F240 R
 4001F234 = 4001F234	     2		_LINK	= $				
 4001F234  43 78 69 6F	     2		DB	COMPO+3,'xio'			
			     2	ORG	_CODE					
			     1		align	4
 40001FAC  48		     1		db	048h		
 40001FAD  21 FB	     1		db	021h,0fbh	
 40001FAF  25 FA	     1		db	025h,0fah	
 40001FB1  84		     1		db	084h		
 40001FB2  F0		     1		db	0f0h		
 40001FB3  30		     1		db	030h		
 40001FB4  F6		     1		db	0f6h		
 40001FB5  00 00 00	     1		db	0,0,0
 40001FB8  400001C0 R	     1		dd	DOLST
 40001FBC  400001A8 R				DD	DOLIT,ACCEP,TEXPE,DSTOR
	   40001C60 R
	   400004BC R
	   40000DBC R
 40001FCC  400004EC R				DD	TECHO,DSTOR,EXIT
	   40000DBC R
	   400001D4 R

				;   FILE	( -- )
				;		Select I/O vectors for file download.

						$COLON	4,'FILE',FILE
			     1		$CODE	4,'FILE',FILE
			     2		ALIGN	4				
 40001FD8		     2	FILE:						
 40001FD8 = 40001FD8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F21C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F21C  40001FD8 R	     2		DD	 _CODE,_LINK			
	   4001F234 R
 4001F224 = 4001F224	     2		_LINK	= $				
 4001F224  04 46 49 4C 45    2		DB	4,'FILE'			
			     2	ORG	_CODE					
			     1		align	4
 40001FD8  48		     1		db	048h		
 40001FD9  21 FB	     1		db	021h,0fbh	
 40001FDB  25 FA	     1		db	025h,0fah	
 40001FDD  84		     1		db	084h		
 40001FDE  F0		     1		db	0f0h		
 40001FDF  30		     1		db	030h		
 40001FE0  F6		     1		db	0f6h		
 40001FE1  00 00 00	     1		db	0,0,0
 40001FE4  400001C0 R	     1		dd	DOLST
 40001FE8  400001A8 R				DD	DOLIT,PACE,DOLIT,DROP
	   40001480 R
	   400001A8 R
	   40000340 R
 40001FF8  400001A8 R				DD	DOLIT,KTAP,XIO,EXIT
	   40001BFC R
	   40001FAC R
	   400001D4 R

				;   HAND	( -- )
				;		Select I/O vectors for terminal interface.

						$COLON	4,'HAND',HAND
			     1		$CODE	4,'HAND',HAND
			     2		ALIGN	4				
 40002008		     2	HAND:						
 40002008 = 40002008	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F20C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F20C  40002008 R	     2		DD	 _CODE,_LINK			
	   4001F224 R
 4001F214 = 4001F214	     2		_LINK	= $				
 4001F214  04 48 41 4E 44    2		DB	4,'HAND'			
			     2	ORG	_CODE					
			     1		align	4
 40002008  48		     1		db	048h		
 40002009  21 FB	     1		db	021h,0fbh	
 4000200B  25 FA	     1		db	025h,0fah	
 4000200D  84		     1		db	084h		
 4000200E  F0		     1		db	0f0h		
 4000200F  30		     1		db	030h		
 40002010  F6		     1		db	0f6h		
 40002011  00 00 00	     1		db	0,0,0
 40002014  400001C0 R	     1		dd	DOLST
 40002018  400001A8 R				DD	DOLIT,DOTOK,DOLIT,EMIT
	   40001EC8 R
	   400001A8 R
	   4000142C R
 40002028  400001A8 R				DD	DOLIT,KTAP,XIO,EXIT
	   40001BFC R
	   40001FAC R
	   400001D4 R

				;   I/O 	( -- a )
				;		Array to store default I/O vectors.

						$COLON	3,'I/O',ISLO
			     1		$CODE	3,'I/O',ISLO
			     2		ALIGN	4				
 40002038		     2	ISLO:						
 40002038 = 40002038	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F200		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F200  40002038 R	     2		DD	 _CODE,_LINK			
	   4001F214 R
 4001F208 = 4001F208	     2		_LINK	= $				
 4001F208  03 49 2F 4F	     2		DB	3,'I/O'			
			     2	ORG	_CODE					
			     1		align	4
 40002038  48		     1		db	048h		
 40002039  21 FB	     1		db	021h,0fbh	
 4000203B  25 FA	     1		db	025h,0fah	
 4000203D  84		     1		db	084h		
 4000203E  F0		     1		db	0f0h		
 4000203F  30		     1		db	030h		
 40002040  F6		     1		db	0f6h		
 40002041  00 00 00	     1		db	0,0,0
 40002044  400001C0 R	     1		dd	DOLST
 40002048  40000404 R				DD	DOVAR			;emulate CREATE
 4000204C  40000108 R				DD	QRX,TXSTO		;default I/O vectors
	   40000140 R

				;   CONSOLE	( -- )
				;		Initiate terminal interface.

						$COLON	7,'CONSOLE',CONSO
			     1		$CODE	7,'CONSOLE',CONSO
			     2		ALIGN	4				
 40002054		     2	CONSO:						
 40002054 = 40002054	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F1F0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1F0  40002054 R	     2		DD	 _CODE,_LINK			
	   4001F208 R
 4001F1F8 = 4001F1F8	     2		_LINK	= $				
 4001F1F8  07 43 4F 4E 53    2		DB	7,'CONSOLE'			
	   4F 4C 45
			     2	ORG	_CODE					
			     1		align	4
 40002054  48		     1		db	048h		
 40002055  21 FB	     1		db	021h,0fbh	
 40002057  25 FA	     1		db	025h,0fah	
 40002059  84		     1		db	084h		
 4000205A  F0		     1		db	0f0h		
 4000205B  30		     1		db	030h		
 4000205C  F6		     1		db	0f6h		
 4000205D  00 00 00	     1		db	0,0,0
 40002060  400001C0 R	     1		dd	DOLST
 40002064  40002038 R				DD	ISLO,DAT,TQKEY,DSTOR	;restore default I/O device
	   40000DE4 R
	   4000048C R
	   40000DBC R
 40002074  40002008 R				DD	HAND,EXIT		;keyboard input
	   400001D4 R

				;   QUIT	( -- )
				;		Reset return stack pointer and start text interpreter.

						$COLON	4,'QUIT',QUIT
			     1		$CODE	4,'QUIT',QUIT
			     2		ALIGN	4				
 4000207C		     2	QUIT:						
 4000207C = 4000207C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001F1E0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1E0  4000207C R	     2		DD	 _CODE,_LINK			
	   4001F1F8 R
 4001F1E8 = 4001F1E8	     2		_LINK	= $				
 4001F1E8  04 51 55 49 54    2		DB	4,'QUIT'			
			     2	ORG	_CODE					
			     1		align	4
 4000207C  48		     1		db	048h		
 4000207D  21 FB	     1		db	021h,0fbh	
 4000207F  25 FA	     1		db	025h,0fah	
 40002081  84		     1		db	084h		
 40002082  F0		     1		db	0f0h		
 40002083  30		     1		db	030h		
 40002084  F6		     1		db	0f6h		
 40002085  00 00 00	     1		db	0,0,0
 40002088  400001C0 R	     1		dd	DOLST
 4000208C  40000474 R				DD	RZERO,AT,RPSTO		;reset return stack pointer
	   40000270 R
	   400002C0 R
 40002098 40001EA4 R		QUIT1:		DD	LBRAC			;start interpretation
 4000209C 40001D00 R		QUIT2:		DD	QUERY			;get input
 400020A0  400001A8 R				DD	DOLIT,EVAL,CATCH,QDUP	;evaluate input
	   40001F30 R
	   40001D44 R
	   400006C0 R
 400020B0  40000220 R				DD	QBRAN,QUIT2		;continue till error
	   4000209C R
 400020B8  40000504 R				DD	TPROM,AT,SWAP		;save input device
	   40000270 R
	   40000364 R
 400020C4  40002054 R				DD	CONSO,NULLS,OVER,XORR	;?display error message
	   40001DDC R
	   40000378 R
	   400003D4 R
 400020D4  40000220 R				DD	QBRAN,QUIT3
	   400020F0 R
 400020DC  400014A0 R				DD	SPACE,COUNT,TYPEE	;error message
	   40000E0C R
	   400014F4 R
						D$	DOTQP,' ? '             ;error prompt
 400020E8  400015B4 R	     1		DD	DOTQP				
 400020EC = 400020EC	     1		_LEN	= $				
 400020EC  00 20 3F 20	     1		DB	0,' ? ' 			
 400020F0 = 400020F0	     1		_CODE	= $				
			     1	ORG	_LEN					
 400020EC  03		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 400020F0 400001A8 R		QUIT3:		DD	DOLIT,DOTOK,XORR	;?file input
	   40001EC8 R
	   400003D4 R
 400020FC  40000220 R				DD	QBRAN,QUIT4
	   40002110 R
 40002104  400001A8 R				DD	DOLIT,ERRESC,EMIT	   ;file error, tell host
	   0000001B
	   4000142C R
 40002110 40001F78 R		QUIT4:		DD	PRESE			;some cleanup
 40002114  40000244 R				DD	BRAN,QUIT1
	   40002098 R

				;; The compiler

				;   '           ( -- ca )
				;		Search context vocabularies for the next word in input stream.

						$COLON	1,"'",TICK
			     1		$CODE	1,"'",TICK
			     2		ALIGN	4				
 4000211C		     2	TICK:						
 4000211C = 4000211C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F1D4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1D4  4000211C R	     2		DD	 _CODE,_LINK			
	   4001F1E8 R
 4001F1DC = 4001F1DC	     2		_LINK	= $				
 4001F1DC  01 27	     2		DB	1,"'"			
			     2	ORG	_CODE					
			     1		align	4
 4000211C  48		     1		db	048h		
 4000211D  21 FB	     1		db	021h,0fbh	
 4000211F  25 FA	     1		db	025h,0fah	
 40002121  84		     1		db	084h		
 40002122  F0		     1		db	0f0h		
 40002123  30		     1		db	030h		
 40002124  F6		     1		db	0f6h		
 40002125  00 00 00	     1		db	0,0,0
 40002128  400001C0 R	     1		dd	DOLST
 4000212C  400018F0 R				DD	TOKEN,NAMEQ		;?defined
	   40001ADC R
 40002134  40000220 R				DD	QBRAN,TICK1
	   40002140 R
 4000213C  400001D4 R				DD	EXIT			;yes, push code address
 40002140 40001D98 R		TICK1:		DD	THROW			;no, error

				;   ALLOT	( n -- )
				;		Allocate n bytes to the code dictionary.

						$COLON	5,'ALLOT',ALLOT
			     1		$CODE	5,'ALLOT',ALLOT
			     2		ALIGN	4				
 40002144		     2	ALLOT:						
 40002144 = 40002144	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F1C4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1C4  40002144 R	     2		DD	 _CODE,_LINK			
	   4001F1DC R
 4001F1CC = 4001F1CC	     2		_LINK	= $				
 4001F1CC  05 41 4C 4C 4F    2		DB	5,'ALLOT'			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40002144  48		     1		db	048h		
 40002145  21 FB	     1		db	021h,0fbh	
 40002147  25 FA	     1		db	025h,0fah	
 40002149  84		     1		db	084h		
 4000214A  F0		     1		db	0f0h		
 4000214B  30		     1		db	030h		
 4000214C  F6		     1		db	0f6h		
 4000214D  00 00 00	     1		db	0,0,0
 40002150  400001C0 R	     1		dd	DOLST
 40002154  4000063C R				DD	CP,PSTOR,EXIT		;adjust code pointer
	   40000D90 R
	   400001D4 R

				;   ,		( w -- )
				;		Compile an integer into the code dictionary.

						$COLON	1,',',COMMA
			     1		$CODE	1,',',COMMA
			     2		ALIGN	4				
 40002160		     2	COMMA:						
 40002160 = 40002160	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F1B8		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1B8  40002160 R	     2		DD	 _CODE,_LINK			
	   4001F1CC R
 4001F1C0 = 4001F1C0	     2		_LINK	= $				
 4001F1C0  01 2C	     2		DB	1,','			
			     2	ORG	_CODE					
			     1		align	4
 40002160  48		     1		db	048h		
 40002161  21 FB	     1		db	021h,0fbh	
 40002163  25 FA	     1		db	025h,0fah	
 40002165  84		     1		db	084h		
 40002166  F0		     1		db	0f0h		
 40002167  30		     1		db	030h		
 40002168  F6		     1		db	0f6h		
 40002169  00 00 00	     1		db	0,0,0
 4000216C  400001C0 R	     1		dd	DOLST
 40002170  40000E38 R				DD	HERE,DUPP,CELLP 	;cell boundary
	   40000350 R
	   40000C18 R
 4000217C  4000063C R				DD	CP,STORE,STORE,EXIT	;adjust code pointer, compile
	   40000254 R
	   40000254 R
	   400001D4 R

				;   [COMPILE]	( -- ; <string> )
				;		Compile the next immediate word into code dictionary.

						$COLON	IMEDD+9,'[COMPILE]',BCOMP
			     1		$CODE	IMEDD+9,'[COMPILE]',BCOMP
			     2		ALIGN	4				
 4000218C		     2	BCOMP:						
 4000218C = 4000218C	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (IMEDD+9 AND 01FH)/CELLL		
 = 4001F1A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F1A4  4000218C R	     2		DD	 _CODE,_LINK			
	   4001F1C0 R
 4001F1AC = 4001F1AC	     2		_LINK	= $				
 4001F1AC  89 5B 43 4F 4D    2		DB	IMEDD+9,'[COMPILE]'			
	   50 49 4C 45 5D
			     2	ORG	_CODE					
			     1		align	4
 4000218C  48		     1		db	048h		
 4000218D  21 FB	     1		db	021h,0fbh	
 4000218F  25 FA	     1		db	025h,0fah	
 40002191  84		     1		db	084h		
 40002192  F0		     1		db	0f0h		
 40002193  30		     1		db	030h		
 40002194  F6		     1		db	0f6h		
 40002195  00 00 00	     1		db	0,0,0
 40002198  400001C0 R	     1		dd	DOLST
 4000219C  4000211C R				DD	TICK,COMMA,EXIT
	   40002160 R
	   400001D4 R

				;   COMPILE	( -- )
				;		Compile the next address in colon list to code dictionary.

						$COLON	COMPO+7,'COMPILE',COMPI
			     1		$CODE	COMPO+7,'COMPILE',COMPI
			     2		ALIGN	4				
 400021A8		     2	COMPI:						
 400021A8 = 400021A8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (COMPO+7 AND 01FH)/CELLL		
 = 4001F194		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F194  400021A8 R	     2		DD	 _CODE,_LINK			
	   4001F1AC R
 4001F19C = 4001F19C	     2		_LINK	= $				
 4001F19C  47 43 4F 4D 50    2		DB	COMPO+7,'COMPILE'			
	   49 4C 45
			     2	ORG	_CODE					
			     1		align	4
 400021A8  48		     1		db	048h		
 400021A9  21 FB	     1		db	021h,0fbh	
 400021AB  25 FA	     1		db	025h,0fah	
 400021AD  84		     1		db	084h		
 400021AE  F0		     1		db	0f0h		
 400021AF  30		     1		db	030h		
 400021B0  F6		     1		db	0f6h		
 400021B1  00 00 00	     1		db	0,0,0
 400021B4  400001C0 R	     1		dd	DOLST
 400021B8  400002D4 R				DD	RFROM,DUPP,AT,COMMA	;compile address
	   40000350 R
	   40000270 R
	   40002160 R
 400021C8  40000C18 R				DD	CELLP,TOR,EXIT		;adjust return address
	   40000300 R
	   400001D4 R

				;   LITERAL	( w -- )
				;		Compile tos to code dictionary as an integer literal.

						$COLON	IMEDD+7,'LITERAL',LITER
			     1		$CODE	IMEDD+7,'LITERAL',LITER
			     2		ALIGN	4				
 400021D4		     2	LITER:						
 400021D4 = 400021D4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+7 AND 01FH)/CELLL		
 = 4001F184		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F184  400021D4 R	     2		DD	 _CODE,_LINK			
	   4001F19C R
 4001F18C = 4001F18C	     2		_LINK	= $				
 4001F18C  87 4C 49 54 45    2		DB	IMEDD+7,'LITERAL'			
	   52 41 4C
			     2	ORG	_CODE					
			     1		align	4
 400021D4  48		     1		db	048h		
 400021D5  21 FB	     1		db	021h,0fbh	
 400021D7  25 FA	     1		db	025h,0fah	
 400021D9  84		     1		db	084h		
 400021DA  F0		     1		db	0f0h		
 400021DB  30		     1		db	030h		
 400021DC  F6		     1		db	0f6h		
 400021DD  00 00 00	     1		db	0,0,0
 400021E0  400001C0 R	     1		dd	DOLST
 400021E4  400021A8 R				DD	COMPI,DOLIT,COMMA,EXIT
	   400001A8 R
	   40002160 R
	   400001D4 R

				;   $,"         ( -- )
				;		Compile a literal string up to next " .

						$COLON	3,'$,"',STRCQ
			     1		$CODE	3,'$,"',STRCQ
			     2		ALIGN	4				
 400021F4		     2	STRCQ:						
 400021F4 = 400021F4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F178		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F178  400021F4 R	     2		DD	 _CODE,_LINK			
	   4001F18C R
 4001F180 = 4001F180	     2		_LINK	= $				
 4001F180  03 24 2C 22	     2		DB	3,'$,"'			
			     2	ORG	_CODE					
			     1		align	4
 400021F4  48		     1		db	048h		
 400021F5  21 FB	     1		db	021h,0fbh	
 400021F7  25 FA	     1		db	025h,0fah	
 400021F9  84		     1		db	084h		
 400021FA  F0		     1		db	0f0h		
 400021FB  30		     1		db	030h		
 400021FC  F6		     1		db	0f6h		
 400021FD  00 00 00	     1		db	0,0,0
 40002200  400001C0 R	     1		dd	DOLST
 40002204  400001A8 R				DD	DOLIT,'"',WORDD         ;move string to code dictionary
	   00000022
	   40001930 R
 40002210  40000E0C R				DD	COUNT,PLUS,ALGND	;calculate aligned end of string
	   40000740 R
	   40000C78 R
 4000221C  4000063C R				DD	CP,STORE,EXIT		;adjust the code pointer
	   40000254 R
	   400001D4 R

				;   RECURSE	( -- )
				;		Make the current word available for compilation.

						$COLON	IMEDD+7,'RECURSE',RECUR
			     1		$CODE	IMEDD+7,'RECURSE',RECUR
			     2		ALIGN	4				
 40002228		     2	RECUR:						
 40002228 = 40002228	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+7 AND 01FH)/CELLL		
 = 4001F168		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F168  40002228 R	     2		DD	 _CODE,_LINK			
	   4001F180 R
 4001F170 = 4001F170	     2		_LINK	= $				
 4001F170  87 52 45 43 55    2		DB	IMEDD+7,'RECURSE'			
	   52 53 45
			     2	ORG	_CODE					
			     1		align	4
 40002228  48		     1		db	048h		
 40002229  21 FB	     1		db	021h,0fbh	
 4000222B  25 FA	     1		db	025h,0fah	
 4000222D  84		     1		db	084h		
 4000222E  F0		     1		db	0f0h		
 4000222F  30		     1		db	030h		
 40002230  F6		     1		db	0f6h		
 40002231  00 00 00	     1		db	0,0,0
 40002234  400001C0 R	     1		dd	DOLST
 40002238  4000066C R				DD	LAST,AT,NAMET,COMMA,EXIT
	   40000270 R
	   40001950 R
	   40002160 R
	   400001D4 R

				;; Structures

				;   FOR 	( -- a )
				;		Start a FOR-NEXT loop structure in a colon definition.

						$COLON	IMEDD+3,'FOR',FOR_
			     1		$CODE	IMEDD+3,'FOR',FOR_
			     2		ALIGN	4				
 4000224C		     2	FOR_:						
 4000224C = 4000224C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+3 AND 01FH)/CELLL		
 = 4001F15C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F15C  4000224C R	     2		DD	 _CODE,_LINK			
	   4001F170 R
 4001F164 = 4001F164	     2		_LINK	= $				
 4001F164  83 46 4F 52	     2		DB	IMEDD+3,'FOR'			
			     2	ORG	_CODE					
			     1		align	4
 4000224C  48		     1		db	048h		
 4000224D  21 FB	     1		db	021h,0fbh	
 4000224F  25 FA	     1		db	025h,0fah	
 40002251  84		     1		db	084h		
 40002252  F0		     1		db	0f0h		
 40002253  30		     1		db	030h		
 40002254  F6		     1		db	0f6h		
 40002255  00 00 00	     1		db	0,0,0
 40002258  400001C0 R	     1		dd	DOLST
 4000225C  400021A8 R				DD	COMPI,TOR,HERE,EXIT
	   40000300 R
	   40000E38 R
	   400001D4 R

				;   BEGIN	( -- a )
				;		Start an infinite or indefinite loop structure.

						$COLON	IMEDD+5,'BEGIN',BEGIN
			     1		$CODE	IMEDD+5,'BEGIN',BEGIN
			     2		ALIGN	4				
 4000226C		     2	BEGIN:						
 4000226C = 4000226C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+5 AND 01FH)/CELLL		
 = 4001F14C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F14C  4000226C R	     2		DD	 _CODE,_LINK			
	   4001F164 R
 4001F154 = 4001F154	     2		_LINK	= $				
 4001F154  85 42 45 47 49    2		DB	IMEDD+5,'BEGIN'			
	   4E
			     2	ORG	_CODE					
			     1		align	4
 4000226C  48		     1		db	048h		
 4000226D  21 FB	     1		db	021h,0fbh	
 4000226F  25 FA	     1		db	025h,0fah	
 40002271  84		     1		db	084h		
 40002272  F0		     1		db	0f0h		
 40002273  30		     1		db	030h		
 40002274  F6		     1		db	0f6h		
 40002275  00 00 00	     1		db	0,0,0
 40002278  400001C0 R	     1		dd	DOLST
 4000227C  40000E38 R				DD	HERE,EXIT
	   400001D4 R

				;   NEXT	( a -- )
				;		Terminate a FOR-NEXT loop structure.

						$COLON	IMEDD+4,'NEXT',NEXT
			     1		$CODE	IMEDD+4,'NEXT',NEXT
			     2		ALIGN	4				
 40002284		     2	NEXT:						
 40002284 = 40002284	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+4 AND 01FH)/CELLL		
 = 4001F13C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F13C  40002284 R	     2		DD	 _CODE,_LINK			
	   4001F154 R
 4001F144 = 4001F144	     2		_LINK	= $				
 4001F144  84 4E 45 58 54    2		DB	IMEDD+4,'NEXT'			
			     2	ORG	_CODE					
			     1		align	4
 40002284  48		     1		db	048h		
 40002285  21 FB	     1		db	021h,0fbh	
 40002287  25 FA	     1		db	025h,0fah	
 40002289  84		     1		db	084h		
 4000228A  F0		     1		db	0f0h		
 4000228B  30		     1		db	030h		
 4000228C  F6		     1		db	0f6h		
 4000228D  00 00 00	     1		db	0,0,0
 40002290  400001C0 R	     1		dd	DOLST
 40002294  400021A8 R				DD	COMPI,DONXT,COMMA,EXIT
	   400001F0 R
	   40002160 R
	   400001D4 R

				;   UNTIL	( a -- )
				;		Terminate a BEGIN-UNTIL indefinite loop structure.

						$COLON	IMEDD+5,'UNTIL',UNTIL
			     1		$CODE	IMEDD+5,'UNTIL',UNTIL
			     2		ALIGN	4				
 400022A4		     2	UNTIL:						
 400022A4 = 400022A4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+5 AND 01FH)/CELLL		
 = 4001F12C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F12C  400022A4 R	     2		DD	 _CODE,_LINK			
	   4001F144 R
 4001F134 = 4001F134	     2		_LINK	= $				
 4001F134  85 55 4E 54 49    2		DB	IMEDD+5,'UNTIL'			
	   4C
			     2	ORG	_CODE					
			     1		align	4
 400022A4  48		     1		db	048h		
 400022A5  21 FB	     1		db	021h,0fbh	
 400022A7  25 FA	     1		db	025h,0fah	
 400022A9  84		     1		db	084h		
 400022AA  F0		     1		db	0f0h		
 400022AB  30		     1		db	030h		
 400022AC  F6		     1		db	0f6h		
 400022AD  00 00 00	     1		db	0,0,0
 400022B0  400001C0 R	     1		dd	DOLST
 400022B4  400021A8 R				DD	COMPI,QBRAN,COMMA,EXIT
	   40000220 R
	   40002160 R
	   400001D4 R

				;   AGAIN	( a -- )
				;		Terminate a BEGIN-AGAIN infinite loop structure.

						$COLON	IMEDD+5,'AGAIN',AGAIN
			     1		$CODE	IMEDD+5,'AGAIN',AGAIN
			     2		ALIGN	4				
 400022C4		     2	AGAIN:						
 400022C4 = 400022C4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+5 AND 01FH)/CELLL		
 = 4001F11C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F11C  400022C4 R	     2		DD	 _CODE,_LINK			
	   4001F134 R
 4001F124 = 4001F124	     2		_LINK	= $				
 4001F124  85 41 47 41 49    2		DB	IMEDD+5,'AGAIN'			
	   4E
			     2	ORG	_CODE					
			     1		align	4
 400022C4  48		     1		db	048h		
 400022C5  21 FB	     1		db	021h,0fbh	
 400022C7  25 FA	     1		db	025h,0fah	
 400022C9  84		     1		db	084h		
 400022CA  F0		     1		db	0f0h		
 400022CB  30		     1		db	030h		
 400022CC  F6		     1		db	0f6h		
 400022CD  00 00 00	     1		db	0,0,0
 400022D0  400001C0 R	     1		dd	DOLST
 400022D4  400021A8 R				DD	COMPI,BRAN,COMMA,EXIT
	   40000244 R
	   40002160 R
	   400001D4 R

				;   IF		( -- A )
				;		Begin a conditional branch structure.

						$COLON	IMEDD+2,'IF',IFF
			     1		$CODE	IMEDD+2,'IF',IFF
			     2		ALIGN	4				
 400022E4		     2	IFF:						
 400022E4 = 400022E4	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+2 AND 01FH)/CELLL		
 = 4001F110		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F110  400022E4 R	     2		DD	 _CODE,_LINK			
	   4001F124 R
 4001F118 = 4001F118	     2		_LINK	= $				
 4001F118  82 49 46	     2		DB	IMEDD+2,'IF'			
			     2	ORG	_CODE					
			     1		align	4
 400022E4  48		     1		db	048h		
 400022E5  21 FB	     1		db	021h,0fbh	
 400022E7  25 FA	     1		db	025h,0fah	
 400022E9  84		     1		db	084h		
 400022EA  F0		     1		db	0f0h		
 400022EB  30		     1		db	030h		
 400022EC  F6		     1		db	0f6h		
 400022ED  00 00 00	     1		db	0,0,0
 400022F0  400001C0 R	     1		dd	DOLST
 400022F4  400021A8 R				DD	COMPI,QBRAN,HERE
	   40000220 R
	   40000E38 R
 40002300  400001A8 R				DD	DOLIT,0,COMMA,EXIT
	   00000000
	   40002160 R
	   400001D4 R

				;   AHEAD	( -- A )
				;		Compile a forward branch instruction.

						$COLON	IMEDD+5,'AHEAD',AHEAD
			     1		$CODE	IMEDD+5,'AHEAD',AHEAD
			     2		ALIGN	4				
 40002310		     2	AHEAD:						
 40002310 = 40002310	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+5 AND 01FH)/CELLL		
 = 4001F100		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F100  40002310 R	     2		DD	 _CODE,_LINK			
	   4001F118 R
 4001F108 = 4001F108	     2		_LINK	= $				
 4001F108  85 41 48 45 41    2		DB	IMEDD+5,'AHEAD'			
	   44
			     2	ORG	_CODE					
			     1		align	4
 40002310  48		     1		db	048h		
 40002311  21 FB	     1		db	021h,0fbh	
 40002313  25 FA	     1		db	025h,0fah	
 40002315  84		     1		db	084h		
 40002316  F0		     1		db	0f0h		
 40002317  30		     1		db	030h		
 40002318  F6		     1		db	0f6h		
 40002319  00 00 00	     1		db	0,0,0
 4000231C  400001C0 R	     1		dd	DOLST
 40002320  400021A8 R				DD	COMPI,BRAN,HERE,DOLIT,0,COMMA,EXIT
	   40000244 R
	   40000E38 R
	   400001A8 R
	   00000000
	   40002160 R
	   400001D4 R

				;   REPEAT	( A a -- )
				;		Terminate a BEGIN-WHILE-REPEAT indefinite loop.

						$COLON	IMEDD+6,'REPEAT',REPEA
			     1		$CODE	IMEDD+6,'REPEAT',REPEA
			     2		ALIGN	4				
 4000233C		     2	REPEA:						
 4000233C = 4000233C	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+6 AND 01FH)/CELLL		
 = 4001F0F0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0F0  4000233C R	     2		DD	 _CODE,_LINK			
	   4001F108 R
 4001F0F8 = 4001F0F8	     2		_LINK	= $				
 4001F0F8  86 52 45 50 45    2		DB	IMEDD+6,'REPEAT'			
	   41 54
			     2	ORG	_CODE					
			     1		align	4
 4000233C  48		     1		db	048h		
 4000233D  21 FB	     1		db	021h,0fbh	
 4000233F  25 FA	     1		db	025h,0fah	
 40002341  84		     1		db	084h		
 40002342  F0		     1		db	0f0h		
 40002343  30		     1		db	030h		
 40002344  F6		     1		db	0f6h		
 40002345  00 00 00	     1		db	0,0,0
 40002348  400001C0 R	     1		dd	DOLST
 4000234C  400022C4 R				DD	AGAIN,HERE,SWAP,STORE,EXIT
	   40000E38 R
	   40000364 R
	   40000254 R
	   400001D4 R

				;   THEN	( A -- )
				;		Terminate a conditional branch structure.

						$COLON	IMEDD+4,'THEN',THENN
			     1		$CODE	IMEDD+4,'THEN',THENN
			     2		ALIGN	4				
 40002360		     2	THENN:						
 40002360 = 40002360	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+4 AND 01FH)/CELLL		
 = 4001F0E0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0E0  40002360 R	     2		DD	 _CODE,_LINK			
	   4001F0F8 R
 4001F0E8 = 4001F0E8	     2		_LINK	= $				
 4001F0E8  84 54 48 45 4E    2		DB	IMEDD+4,'THEN'			
			     2	ORG	_CODE					
			     1		align	4
 40002360  48		     1		db	048h		
 40002361  21 FB	     1		db	021h,0fbh	
 40002363  25 FA	     1		db	025h,0fah	
 40002365  84		     1		db	084h		
 40002366  F0		     1		db	0f0h		
 40002367  30		     1		db	030h		
 40002368  F6		     1		db	0f6h		
 40002369  00 00 00	     1		db	0,0,0
 4000236C  400001C0 R	     1		dd	DOLST
 40002370  40000E38 R				DD	HERE,SWAP,STORE,EXIT
	   40000364 R
	   40000254 R
	   400001D4 R

				;   AFT 	( a -- a A )
				;		Jump to THEN in a FOR-AFT-THEN-NEXT loop the first time through.

						$COLON	IMEDD+3,'AFT',AFT
			     1		$CODE	IMEDD+3,'AFT',AFT
			     2		ALIGN	4				
 40002380		     2	AFT:						
 40002380 = 40002380	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+3 AND 01FH)/CELLL		
 = 4001F0D4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0D4  40002380 R	     2		DD	 _CODE,_LINK			
	   4001F0E8 R
 4001F0DC = 4001F0DC	     2		_LINK	= $				
 4001F0DC  83 41 46 54	     2		DB	IMEDD+3,'AFT'			
			     2	ORG	_CODE					
			     1		align	4
 40002380  48		     1		db	048h		
 40002381  21 FB	     1		db	021h,0fbh	
 40002383  25 FA	     1		db	025h,0fah	
 40002385  84		     1		db	084h		
 40002386  F0		     1		db	0f0h		
 40002387  30		     1		db	030h		
 40002388  F6		     1		db	0f6h		
 40002389  00 00 00	     1		db	0,0,0
 4000238C  400001C0 R	     1		dd	DOLST
 40002390  40000340 R				DD	DROP,AHEAD,BEGIN,SWAP,EXIT
	   40002310 R
	   4000226C R
	   40000364 R
	   400001D4 R

				;   ELSE	( A -- A )
				;		Start the false clause in an IF-ELSE-THEN structure.

						$COLON	IMEDD+4,'ELSE',ELSEE
			     1		$CODE	IMEDD+4,'ELSE',ELSEE
			     2		ALIGN	4				
 400023A4		     2	ELSEE:						
 400023A4 = 400023A4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+4 AND 01FH)/CELLL		
 = 4001F0C4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0C4  400023A4 R	     2		DD	 _CODE,_LINK			
	   4001F0DC R
 4001F0CC = 4001F0CC	     2		_LINK	= $				
 4001F0CC  84 45 4C 53 45    2		DB	IMEDD+4,'ELSE'			
			     2	ORG	_CODE					
			     1		align	4
 400023A4  48		     1		db	048h		
 400023A5  21 FB	     1		db	021h,0fbh	
 400023A7  25 FA	     1		db	025h,0fah	
 400023A9  84		     1		db	084h		
 400023AA  F0		     1		db	0f0h		
 400023AB  30		     1		db	030h		
 400023AC  F6		     1		db	0f6h		
 400023AD  00 00 00	     1		db	0,0,0
 400023B0  400001C0 R	     1		dd	DOLST
 400023B4  40002310 R				DD	AHEAD,SWAP,THENN,EXIT
	   40000364 R
	   40002360 R
	   400001D4 R

				;   WHILE	( a -- A a )
				;		Conditional branch out of a BEGIN-WHILE-REPEAT loop.

						$COLON	IMEDD+5,'WHILE',WHILE_
			     1		$CODE	IMEDD+5,'WHILE',WHILE_
			     2		ALIGN	4				
 400023C4		     2	WHILE_:						
 400023C4 = 400023C4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+5 AND 01FH)/CELLL		
 = 4001F0B4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0B4  400023C4 R	     2		DD	 _CODE,_LINK			
	   4001F0CC R
 4001F0BC = 4001F0BC	     2		_LINK	= $				
 4001F0BC  85 57 48 49 4C    2		DB	IMEDD+5,'WHILE'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 400023C4  48		     1		db	048h		
 400023C5  21 FB	     1		db	021h,0fbh	
 400023C7  25 FA	     1		db	025h,0fah	
 400023C9  84		     1		db	084h		
 400023CA  F0		     1		db	0f0h		
 400023CB  30		     1		db	030h		
 400023CC  F6		     1		db	0f6h		
 400023CD  00 00 00	     1		db	0,0,0
 400023D0  400001C0 R	     1		dd	DOLST
 400023D4  400022E4 R				DD	IFF,SWAP,EXIT
	   40000364 R
	   400001D4 R

				;   ABORT"      ( -- ; <string> )
				;		Conditional abort with an error message.

						$COLON	IMEDD+6,'ABORT"',ABRTQ
			     1		$CODE	IMEDD+6,'ABORT"',ABRTQ
			     2		ALIGN	4				
 400023E0		     2	ABRTQ:						
 400023E0 = 400023E0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (IMEDD+6 AND 01FH)/CELLL		
 = 4001F0A4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F0A4  400023E0 R	     2		DD	 _CODE,_LINK			
	   4001F0BC R
 4001F0AC = 4001F0AC	     2		_LINK	= $				
 4001F0AC  86 41 42 4F 52    2		DB	IMEDD+6,'ABORT"'			
	   54 22
			     2	ORG	_CODE					
			     1		align	4
 400023E0  48		     1		db	048h		
 400023E1  21 FB	     1		db	021h,0fbh	
 400023E3  25 FA	     1		db	025h,0fah	
 400023E5  84		     1		db	084h		
 400023E6  F0		     1		db	0f0h		
 400023E7  30		     1		db	030h		
 400023E8  F6		     1		db	0f6h		
 400023E9  00 00 00	     1		db	0,0,0
 400023EC  400001C0 R	     1		dd	DOLST
 400023F0  400021A8 R				DD	COMPI,ABORQ,STRCQ,EXIT
	   40001E14 R
	   400021F4 R
	   400001D4 R

				;   $"          ( -- ; <string> )
				;		Compile an inline string literal.

						$COLON	IMEDD+2,'$"',STRQ
			     1		$CODE	IMEDD+2,'$"',STRQ
			     2		ALIGN	4				
 40002400		     2	STRQ:						
 40002400 = 40002400	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+2 AND 01FH)/CELLL		
 = 4001F098		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F098  40002400 R	     2		DD	 _CODE,_LINK			
	   4001F0AC R
 4001F0A0 = 4001F0A0	     2		_LINK	= $				
 4001F0A0  82 24 22	     2		DB	IMEDD+2,'$"'			
			     2	ORG	_CODE					
			     1		align	4
 40002400  48		     1		db	048h		
 40002401  21 FB	     1		db	021h,0fbh	
 40002403  25 FA	     1		db	025h,0fah	
 40002405  84		     1		db	084h		
 40002406  F0		     1		db	0f0h		
 40002407  30		     1		db	030h		
 40002408  F6		     1		db	0f6h		
 40002409  00 00 00	     1		db	0,0,0
 4000240C  400001C0 R	     1		dd	DOLST
 40002410  400021A8 R				DD	COMPI,STRQP,STRCQ,EXIT
	   4000159C R
	   400021F4 R
	   400001D4 R

				;   ."          ( -- ; <string> )
				;		Compile an inline string literal to be typed out at run time.

						$COLON	IMEDD+2,'."',DOTQ
			     1		$CODE	IMEDD+2,'."',DOTQ
			     2		ALIGN	4				
 40002420		     2	DOTQ:						
 40002420 = 40002420	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+2 AND 01FH)/CELLL		
 = 4001F08C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F08C  40002420 R	     2		DD	 _CODE,_LINK			
	   4001F0A0 R
 4001F094 = 4001F094	     2		_LINK	= $				
 4001F094  82 2E 22	     2		DB	IMEDD+2,'."'			
			     2	ORG	_CODE					
			     1		align	4
 40002420  48		     1		db	048h		
 40002421  21 FB	     1		db	021h,0fbh	
 40002423  25 FA	     1		db	025h,0fah	
 40002425  84		     1		db	084h		
 40002426  F0		     1		db	0f0h		
 40002427  30		     1		db	030h		
 40002428  F6		     1		db	0f6h		
 40002429  00 00 00	     1		db	0,0,0
 4000242C  400001C0 R	     1		dd	DOLST
 40002430  400021A8 R				DD	COMPI,DOTQP,STRCQ,EXIT
	   400015B4 R
	   400021F4 R
	   400001D4 R

				;; Name compiler

				;   ?UNIQUE	( a -- a )
				;		Display a warning message if the word already exists.

						$COLON	7,'?UNIQUE',UNIQU
			     1		$CODE	7,'?UNIQUE',UNIQU
			     2		ALIGN	4				
 40002440		     2	UNIQU:						
 40002440 = 40002440	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (7 AND 01FH)/CELLL		
 = 4001F07C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F07C  40002440 R	     2		DD	 _CODE,_LINK			
	   4001F094 R
 4001F084 = 4001F084	     2		_LINK	= $				
 4001F084  07 3F 55 4E 49    2		DB	7,'?UNIQUE'			
	   51 55 45
			     2	ORG	_CODE					
			     1		align	4
 40002440  48		     1		db	048h		
 40002441  21 FB	     1		db	021h,0fbh	
 40002443  25 FA	     1		db	025h,0fah	
 40002445  84		     1		db	084h		
 40002446  F0		     1		db	0f0h		
 40002447  30		     1		db	030h		
 40002448  F6		     1		db	0f6h		
 40002449  00 00 00	     1		db	0,0,0
 4000244C  400001C0 R	     1		dd	DOLST
 40002450  40000350 R				DD	DUPP,NAMEQ		;?name exists
	   40001ADC R
 40002458  40000220 R				DD	QBRAN,UNIQ1		;redefinitions are OK
	   40002478 R
						D$	DOTQP,' reDef '         ;but warn the user
 40002460  400015B4 R	     1		DD	DOTQP				
 40002464 = 40002464	     1		_LEN	= $				
 40002464  00 20 72 65 44    1		DB	0,' reDef ' 			
	   65 66 20
 4000246C = 4000246C	     1		_CODE	= $				
			     1	ORG	_LEN					
 40002464  07		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 4000246C  40000378 R				DD	OVER,COUNT,TYPEE	;just in case its not planned
	   40000E0C R
	   400014F4 R
 40002478 40000340 R		UNIQ1:		DD	DROP,EXIT
	   400001D4 R

				;   $,n 	( na -- )
				;		Build a new dictionary name using the string at na.

						$COLON	3,'$,n',SNAME
			     1		$CODE	3,'$,n',SNAME
			     2		ALIGN	4				
 40002480		     2	SNAME:						
 40002480 = 40002480	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001F070		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F070  40002480 R	     2		DD	 _CODE,_LINK			
	   4001F084 R
 4001F078 = 4001F078	     2		_LINK	= $				
 4001F078  03 24 2C 6E	     2		DB	3,'$,n'			
			     2	ORG	_CODE					
			     1		align	4
 40002480  48		     1		db	048h		
 40002481  21 FB	     1		db	021h,0fbh	
 40002483  25 FA	     1		db	025h,0fah	
 40002485  84		     1		db	084h		
 40002486  F0		     1		db	0f0h		
 40002487  30		     1		db	030h		
 40002488  F6		     1		db	0f6h		
 40002489  00 00 00	     1		db	0,0,0
 4000248C  400001C0 R	     1		dd	DOLST
 40002490  40000350 R				DD	DUPP,CAT		;?null input
	   4000029C R
 40002498  40000220 R				DD	QBRAN,PNAM1
	   400024EC R
 400024A0  40002440 R				DD	UNIQU			;?redefinition
 400024A4  40000350 R				DD	DUPP,LAST,STORE 	;save na for vocabulary link
	   4000066C R
	   40000254 R
 400024B0  40000E38 R				DD	HERE,ALGND,SWAP 	;align code address
	   40000C78 R
	   40000364 R
 400024BC  40000C38 R				DD	CELLM			;link address
 400024C0  40000624 R				DD	CRRNT,AT,AT,OVER,STORE
	   40000270 R
	   40000270 R
	   40000378 R
	   40000254 R
 400024D4  40000C38 R				DD	CELLM,DUPP,NP,STORE	;adjust name pointer
	   40000350 R
	   40000654 R
	   40000254 R
 400024E4  40000254 R				DD	STORE,EXIT		;save code pointer
	   400001D4 R
 400024EC			PNAM1:		D$	STRQP,' name'           ;null input
 400024EC  4000159C R	     1		DD	STRQP				
 400024F0 = 400024F0	     1		_LEN	= $				
 400024F0  00 20 6E 61 6D    1		DB	0,' name' 			
	   65
 400024F6 = 400024F6	     1		_CODE	= $				
			     1	ORG	_LEN					
 400024F0  05		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 400024F8  40001D98 R				DD	THROW

				;; FORTH compiler

				;   $COMPILE	( a -- )
				;		Compile next word to code dictionary as a token or literal.

						$COLON	8,'$COMPILE',SCOMP
			     1		$CODE	8,'$COMPILE',SCOMP
			     2		ALIGN	4				
 400024FC		     2	SCOMP:						
 400024FC = 400024FC	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (8 AND 01FH)/CELLL		
 = 4001F05C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F05C  400024FC R	     2		DD	 _CODE,_LINK			
	   4001F078 R
 4001F064 = 4001F064	     2		_LINK	= $				
 4001F064  08 24 43 4F 4D    2		DB	8,'$COMPILE'			
	   50 49 4C 45
			     2	ORG	_CODE					
			     1		align	4
 400024FC  48		     1		db	048h		
 400024FD  21 FB	     1		db	021h,0fbh	
 400024FF  25 FA	     1		db	025h,0fah	
 40002501  84		     1		db	084h		
 40002502  F0		     1		db	0f0h		
 40002503  30		     1		db	030h		
 40002504  F6		     1		db	0f6h		
 40002505  00 00 00	     1		db	0,0,0
 40002508  400001C0 R	     1		dd	DOLST
 4000250C  40001ADC R				DD	NAMEQ,QDUP		;?defined
	   400006C0 R
 40002514  40000220 R				DD	QBRAN,SCOM2
	   40002544 R
 4000251C  40000270 R				DD	AT,DOLIT,IMEDD,ANDD	;?immediate
	   400001A8 R
	   00000080
	   400003A4 R
 4000252C  40000220 R				DD	QBRAN,SCOM1
	   4000253C R
 40002534  400001E8 R				DD	EXECU,EXIT		;its immediate, execute
	   400001D4 R
 4000253C 40002160 R		SCOM1:		DD	COMMA,EXIT		;its not immediate, compile
	   400001D4 R
 40002544 400005C4 R		SCOM2:		DD	TNUMB,ATEXE		;try to convert to number
	   40000E98 R
 4000254C  40000220 R				DD	QBRAN,SCOM3
	   4000255C R
 40002554  400021D4 R				DD	LITER,EXIT		;compile number as integer
	   400001D4 R
 4000255C 40001D98 R		SCOM3:		DD	THROW			;error

				;   OVERT	( -- )
				;		Link a new word into the current vocabulary.

						$COLON	5,'OVERT',OVERT
			     1		$CODE	5,'OVERT',OVERT
			     2		ALIGN	4				
 40002560		     2	OVERT:						
 40002560 = 40002560	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F04C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F04C  40002560 R	     2		DD	 _CODE,_LINK			
	   4001F064 R
 4001F054 = 4001F054	     2		_LINK	= $				
 4001F054  05 4F 56 45 52    2		DB	5,'OVERT'			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40002560  48		     1		db	048h		
 40002561  21 FB	     1		db	021h,0fbh	
 40002563  25 FA	     1		db	025h,0fah	
 40002565  84		     1		db	084h		
 40002566  F0		     1		db	0f0h		
 40002567  30		     1		db	030h		
 40002568  F6		     1		db	0f6h		
 40002569  00 00 00	     1		db	0,0,0
 4000256C  400001C0 R	     1		dd	DOLST
 40002570  4000066C R				DD	LAST,AT,CRRNT,AT,STORE,EXIT
	   40000270 R
	   40000624 R
	   40000270 R
	   40000254 R
	   400001D4 R

				;   ;		( -- )
				;		Terminate a colon definition.

						$COLON	IMEDD+COMPO+1,';',SEMIS
			     1		$CODE	IMEDD+COMPO+1,';',SEMIS
			     2		ALIGN	4				
 40002588		     2	SEMIS:						
 40002588 = 40002588	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (IMEDD+COMPO+1 AND 01FH)/CELLL		
 = 4001F040		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F040  40002588 R	     2		DD	 _CODE,_LINK			
	   4001F054 R
 4001F048 = 4001F048	     2		_LINK	= $				
 4001F048  C1 3B	     2		DB	IMEDD+COMPO+1,';'			
			     2	ORG	_CODE					
			     1		align	4
 40002588  48		     1		db	048h		
 40002589  21 FB	     1		db	021h,0fbh	
 4000258B  25 FA	     1		db	025h,0fah	
 4000258D  84		     1		db	084h		
 4000258E  F0		     1		db	0f0h		
 4000258F  30		     1		db	030h		
 40002590  F6		     1		db	0f6h		
 40002591  00 00 00	     1		db	0,0,0
 40002594  400001C0 R	     1		dd	DOLST
 40002598  400021A8 R				DD	COMPI,EXIT,LBRAC,OVERT,EXIT
	   400001D4 R
	   40001EA4 R
	   40002560 R
	   400001D4 R

				;   ]		( -- )
				;		Start compiling the words in the input stream.

						$COLON	1,']',RBRAC
			     1		$CODE	1,']',RBRAC
			     2		ALIGN	4				
 400025AC		     2	RBRAC:						
 400025AC = 400025AC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F034		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F034  400025AC R	     2		DD	 _CODE,_LINK			
	   4001F048 R
 4001F03C = 4001F03C	     2		_LINK	= $				
 4001F03C  01 5D	     2		DB	1,']'			
			     2	ORG	_CODE					
			     1		align	4
 400025AC  48		     1		db	048h		
 400025AD  21 FB	     1		db	021h,0fbh	
 400025AF  25 FA	     1		db	025h,0fah	
 400025B1  84		     1		db	084h		
 400025B2  F0		     1		db	0f0h		
 400025B3  30		     1		db	030h		
 400025B4  F6		     1		db	0f6h		
 400025B5  00 00 00	     1		db	0,0,0
 400025B8  400001C0 R	     1		dd	DOLST
 400025BC  400001A8 R				DD	DOLIT,SCOMP,TEVAL,STORE,EXIT
	   400024FC R
	   400005AC R
	   40000254 R
	   400001D4 R

				;   call,	( ca -- )
				;		Assemble a call instruction to ca.

						$COLON	5,'call,',CALLC
			     1		$CODE	5,'call,',CALLC
			     2		ALIGN	4				
 400025D0		     2	CALLC:						
 400025D0 = 400025D0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001F024		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F024  400025D0 R	     2		DD	 _CODE,_LINK			
	   4001F03C R
 4001F02C = 4001F02C	     2		_LINK	= $				
 4001F02C  05 63 61 6C 6C    2		DB	5,'call,'			
	   2C
			     2	ORG	_CODE					
			     1		align	4
 400025D0  48		     1		db	048h		
 400025D1  21 FB	     1		db	021h,0fbh	
 400025D3  25 FA	     1		db	025h,0fah	
 400025D5  84		     1		db	084h		
 400025D6  F0		     1		db	0f0h		
 400025D7  30		     1		db	030h		
 400025D8  F6		     1		db	0f6h		
 400025D9  00 00 00	     1		db	0,0,0
 400025DC  400001C0 R	     1		dd	DOLST
				;		 DD	 DOLIT,CALLL,COMMA,HERE  ;Direct Threaded Code
				;		 DD	 CELLP,SUBB,COMMA	 ;DTC 8086 relative call
 400025E0  400001A8 R				dd	dolit,entry1,comma	; transputer abs call
	   25FB2148
	   40002160 R
 400025EC  400001A8 R				dd	dolit,entry2,comma
	   30F084FA
	   40002160 R
 400025F8  400001A8 R				dd	dolit,entry3,comma
	   000000F6
	   40002160 R
 40002604  40002160 R				dd	comma			; compile in the target addr
 40002608  400001D4 R				DD	EXIT

				;   :		( -- ; <string> )
				;		Start a new colon definition using next word as its name.

						$COLON	1,':',COLON
			     1		$CODE	1,':',COLON
			     2		ALIGN	4				
 4000260C		     2	COLON:						
 4000260C = 4000260C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (1 AND 01FH)/CELLL		
 = 4001F018		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F018  4000260C R	     2		DD	 _CODE,_LINK			
	   4001F02C R
 4001F020 = 4001F020	     2		_LINK	= $				
 4001F020  01 3A	     2		DB	1,':'			
			     2	ORG	_CODE					
			     1		align	4
 4000260C  48		     1		db	048h		
 4000260D  21 FB	     1		db	021h,0fbh	
 4000260F  25 FA	     1		db	025h,0fah	
 40002611  84		     1		db	084h		
 40002612  F0		     1		db	0f0h		
 40002613  30		     1		db	030h		
 40002614  F6		     1		db	0f6h		
 40002615  00 00 00	     1		db	0,0,0
 40002618  400001C0 R	     1		dd	DOLST
 4000261C  400018F0 R				DD	TOKEN,SNAME,DOLIT,DOLST
	   40002480 R
	   400001A8 R
	   400001C0 R
 4000262C  400025D0 R				DD	CALLC,RBRAC,EXIT
	   400025AC R
	   400001D4 R

				;   IMMEDIATE	( -- )
				;		Make the last compiled word an immediate word.

						$COLON	9,'IMMEDIATE',IMMED
			     1		$CODE	9,'IMMEDIATE',IMMED
			     2		ALIGN	4				
 40002638		     2	IMMED:						
 40002638 = 40002638	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (9 AND 01FH)/CELLL		
 = 4001F004		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001F004  40002638 R	     2		DD	 _CODE,_LINK			
	   4001F020 R
 4001F00C = 4001F00C	     2		_LINK	= $				
 4001F00C  09 49 4D 4D 45    2		DB	9,'IMMEDIATE'			
	   44 49 41 54 45
			     2	ORG	_CODE					
			     1		align	4
 40002638  48		     1		db	048h		
 40002639  21 FB	     1		db	021h,0fbh	
 4000263B  25 FA	     1		db	025h,0fah	
 4000263D  84		     1		db	084h		
 4000263E  F0		     1		db	0f0h		
 4000263F  30		     1		db	030h		
 40002640  F6		     1		db	0f6h		
 40002641  00 00 00	     1		db	0,0,0
 40002644  400001C0 R	     1		dd	DOLST
 40002648  400001A8 R				DD	DOLIT,IMEDD,LAST,AT,AT,ORR
	   00000080
	   4000066C R
	   40000270 R
	   40000270 R
	   400003BC R
 40002660  4000066C R				DD	LAST,AT,STORE,EXIT
	   40000270 R
	   40000254 R
	   400001D4 R

				;; Defining words

				;   USER	( u -- ; <string> )
				;		Compile a new user variable.

						$COLON	4,'USER',USER
			     1		$CODE	4,'USER',USER
			     2		ALIGN	4				
 40002670		     2	USER:						
 40002670 = 40002670	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001EFF4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFF4  40002670 R	     2		DD	 _CODE,_LINK			
	   4001F00C R
 4001EFFC = 4001EFFC	     2		_LINK	= $				
 4001EFFC  04 55 53 45 52    2		DB	4,'USER'			
			     2	ORG	_CODE					
			     1		align	4
 40002670  48		     1		db	048h		
 40002671  21 FB	     1		db	021h,0fbh	
 40002673  25 FA	     1		db	025h,0fah	
 40002675  84		     1		db	084h		
 40002676  F0		     1		db	0f0h		
 40002677  30		     1		db	030h		
 40002678  F6		     1		db	0f6h		
 40002679  00 00 00	     1		db	0,0,0
 4000267C  400001C0 R	     1		dd	DOLST
 40002680  400018F0 R				DD	TOKEN,SNAME,OVERT
	   40002480 R
	   40002560 R
 4000268C  400001A8 R				DD	DOLIT,DOLST,CALLC
	   400001C0 R
	   400025D0 R
 40002698  400021A8 R				DD	COMPI,DOUSE,COMMA,EXIT
	   40000434 R
	   40002160 R
	   400001D4 R

				;   CREATE	( -- ; <string> )
				;		Compile a new array entry without allocating code space.

						$COLON	6,'CREATE',CREAT
			     1		$CODE	6,'CREATE',CREAT
			     2		ALIGN	4				
 400026A8		     2	CREAT:						
 400026A8 = 400026A8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (6 AND 01FH)/CELLL		
 = 4001EFE4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFE4  400026A8 R	     2		DD	 _CODE,_LINK			
	   4001EFFC R
 4001EFEC = 4001EFEC	     2		_LINK	= $				
 4001EFEC  06 43 52 45 41    2		DB	6,'CREATE'			
	   54 45
			     2	ORG	_CODE					
			     1		align	4
 400026A8  48		     1		db	048h		
 400026A9  21 FB	     1		db	021h,0fbh	
 400026AB  25 FA	     1		db	025h,0fah	
 400026AD  84		     1		db	084h		
 400026AE  F0		     1		db	0f0h		
 400026AF  30		     1		db	030h		
 400026B0  F6		     1		db	0f6h		
 400026B1  00 00 00	     1		db	0,0,0
 400026B4  400001C0 R	     1		dd	DOLST
 400026B8  400018F0 R				DD	TOKEN,SNAME,OVERT
	   40002480 R
	   40002560 R
 400026C4  400001A8 R				DD	DOLIT,DOLST,CALLC
	   400001C0 R
	   400025D0 R
 400026D0  400021A8 R				DD	COMPI,DOVAR,EXIT
	   40000404 R
	   400001D4 R

				;   VARIABLE	( -- ; <string> )
				;		Compile a new variable initialized to 0.

						$COLON	8,'VARIABLE',VARIA
			     1		$CODE	8,'VARIABLE',VARIA
			     2		ALIGN	4				
 400026DC		     2	VARIA:						
 400026DC = 400026DC	     2		_CODE	= $				
 = 00000002		     2		_LEN	= (8 AND 01FH)/CELLL		
 = 4001EFD0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFD0  400026DC R	     2		DD	 _CODE,_LINK			
	   4001EFEC R
 4001EFD8 = 4001EFD8	     2		_LINK	= $				
 4001EFD8  08 56 41 52 49    2		DB	8,'VARIABLE'			
	   41 42 4C 45
			     2	ORG	_CODE					
			     1		align	4
 400026DC  48		     1		db	048h		
 400026DD  21 FB	     1		db	021h,0fbh	
 400026DF  25 FA	     1		db	025h,0fah	
 400026E1  84		     1		db	084h		
 400026E2  F0		     1		db	0f0h		
 400026E3  30		     1		db	030h		
 400026E4  F6		     1		db	0f6h		
 400026E5  00 00 00	     1		db	0,0,0
 400026E8  400001C0 R	     1		dd	DOLST
 400026EC  400026A8 R				DD	CREAT,DOLIT,0,COMMA,EXIT
	   400001A8 R
	   00000000
	   40002160 R
	   400001D4 R

				;; Tools

				;   _TYPE	( b u -- )
				;		Display a string. Filter non-printing characters.

						$COLON	5,'_TYPE',UTYPE
			     1		$CODE	5,'_TYPE',UTYPE
			     2		ALIGN	4				
 40002700		     2	UTYPE:						
 40002700 = 40002700	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001EFC0		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFC0  40002700 R	     2		DD	 _CODE,_LINK			
	   4001EFD8 R
 4001EFC8 = 4001EFC8	     2		_LINK	= $				
 4001EFC8  05 5F 54 59 50    2		DB	5,'_TYPE'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 40002700  48		     1		db	048h		
 40002701  21 FB	     1		db	021h,0fbh	
 40002703  25 FA	     1		db	025h,0fah	
 40002705  84		     1		db	084h		
 40002706  F0		     1		db	0f0h		
 40002707  30		     1		db	030h		
 40002708  F6		     1		db	0f6h		
 40002709  00 00 00	     1		db	0,0,0
 4000270C  400001C0 R	     1		dd	DOLST
 40002710  40000300 R				DD	TOR			;start count down loop
 40002714  40000244 R				DD	BRAN,UTYP2		;skip first pass
	   40002738 R
 4000271C 40000350 R		UTYP1:		DD	DUPP,CAT,TCHAR,EMIT	;display only printable
	   4000029C R
	   40000CE4 R
	   4000142C R
 4000272C  400001A8 R				DD	DOLIT,1,PLUS		;increment address
	   00000001
	   40000740 R
 40002738 400001F0 R		UTYP2:		DD	DONXT,UTYP1		;loop till done
	   4000271C R
 40002740  40000340 R				DD	DROP,EXIT
	   400001D4 R

				;   dm+ 	( a u -- a )
				;		Dump u bytes from , leaving a+u on the stack.

						$COLON	3,'dm+',DMP
			     1		$CODE	3,'dm+',DMP
			     2		ALIGN	4				
 40002748		     2	DMP:						
 40002748 = 40002748	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001EFB4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFB4  40002748 R	     2		DD	 _CODE,_LINK			
	   4001EFC8 R
 4001EFBC = 4001EFBC	     2		_LINK	= $				
 4001EFBC  03 64 6D 2B	     2		DB	3,'dm+'			
			     2	ORG	_CODE					
			     1		align	4
 40002748  48		     1		db	048h		
 40002749  21 FB	     1		db	021h,0fbh	
 4000274B  25 FA	     1		db	025h,0fah	
 4000274D  84		     1		db	084h		
 4000274E  F0		     1		db	0f0h		
 4000274F  30		     1		db	030h		
 40002750  F6		     1		db	0f6h		
 40002751  00 00 00	     1		db	0,0,0
 40002754  400001C0 R	     1		dd	DOLST
 40002758  40000378 R				DD	OVER,DOLIT,4,UDOTR	;display address
	   400001A8 R
	   00000004
	   40001604 R
 40002768  400014A0 R				DD	SPACE,TOR		;start count down loop
	   40000300 R
 40002770  40000244 R				DD	BRAN,PDUM2		;skip first pass
	   40002798 R
 40002778 40000350 R		PDUM1:		DD	DUPP,CAT,DOLIT,3,UDOTR	;display numeric data
	   4000029C R
	   400001A8 R
	   00000003
	   40001604 R
 4000278C  400001A8 R				DD	DOLIT,1,PLUS		;increment address
	   00000001
	   40000740 R
 40002798 400001F0 R		PDUM2:		DD	DONXT,PDUM1		;loop till done
	   40002778 R
 400027A0  400001D4 R				DD	EXIT

				;   DUMP	( a u -- )
				;		Dump u bytes from a, in a formatted manner.

						$COLON	4,'DUMP',DUMP
			     1		$CODE	4,'DUMP',DUMP
			     2		ALIGN	4				
 400027A4		     2	DUMP:						
 400027A4 = 400027A4	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001EFA4		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EFA4  400027A4 R	     2		DD	 _CODE,_LINK			
	   4001EFBC R
 4001EFAC = 4001EFAC	     2		_LINK	= $				
 4001EFAC  04 44 55 4D 50    2		DB	4,'DUMP'			
			     2	ORG	_CODE					
			     1		align	4
 400027A4  48		     1		db	048h		
 400027A5  21 FB	     1		db	021h,0fbh	
 400027A7  25 FA	     1		db	025h,0fah	
 400027A9  84		     1		db	084h		
 400027AA  F0		     1		db	0f0h		
 400027AB  30		     1		db	030h		
 400027AC  F6		     1		db	0f6h		
 400027AD  00 00 00	     1		db	0,0,0
 400027B0  400001C0 R	     1		dd	DOLST
 400027B4  4000051C R				DD	BASE,AT,TOR,HEX 	;save radix, set hex
	   40000270 R
	   40000300 R
	   400011E4 R
 400027C4  400001A8 R				DD	DOLIT,16,SLASH		;change count to lines
	   00000010
	   40000AD8 R
 400027D0  40000300 R				DD	TOR			;start count down loop
 400027D4 40001538 R		DUMP1:		DD	CR,DOLIT,16,DDUP,DMP	;display numeric
	   400001A8 R
	   00000010
	   40000724 R
	   40002748 R
 400027E8  400006E4 R				DD	ROT,ROT
	   400006E4 R
 400027F0  400014A0 R				DD	SPACE,SPACE,UTYPE	;display printable characters
	   400014A0 R
	   40002700 R
 400027FC  40001448 R				DD	NUFQ,INVER		;user control
	   4000075C R
 40002804  40000220 R				DD	QBRAN,DUMP2
	   4000281C R
 4000280C  400001F0 R				DD	DONXT,DUMP1		;loop till done
	   400027D4 R
 40002814  40000244 R				DD	BRAN,DUMP3
	   40002824 R
 4000281C 400002D4 R		DUMP2:		DD	RFROM,DROP		;cleanup loop stack, early exit
	   40000340 R
 40002824 40000340 R		DUMP3:		DD	DROP,RFROM,BASE,STORE	;restore radix
	   400002D4 R
	   4000051C R
	   40000254 R
 40002834  400001D4 R				DD	EXIT

				;   .S		( ... -- ... )
				;		Display the contents of the data stack.

						$COLON	2,'.S',DOTS
			     1		$CODE	2,'.S',DOTS
			     2		ALIGN	4				
 40002838		     2	DOTS:						
 40002838 = 40002838	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001EF98		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF98  40002838 R	     2		DD	 _CODE,_LINK			
	   4001EFAC R
 4001EFA0 = 4001EFA0	     2		_LINK	= $				
 4001EFA0  02 2E 53	     2		DB	2,'.S'			
			     2	ORG	_CODE					
			     1		align	4
 40002838  48		     1		db	048h		
 40002839  21 FB	     1		db	021h,0fbh	
 4000283B  25 FA	     1		db	025h,0fah	
 4000283D  84		     1		db	084h		
 4000283E  F0		     1		db	0f0h		
 4000283F  30		     1		db	030h		
 40002840  F6		     1		db	0f6h		
 40002841  00 00 00	     1		db	0,0,0
 40002844  400001C0 R	     1		dd	DOLST
 40002848  40001538 R				DD	CR,DEPTH		;stack depth
	   40000D2C R
 40002850  40000300 R				DD	TOR			;start count down loop
 40002854  40000244 R				DD	BRAN,DOTS2		;skip first pass
	   40002868 R
 4000285C 400002EC R		DOTS1:		DD	RAT,PICK,DOT		;index stack, display contents
	   40000D60 R
	   40001664 R
 40002868 400001F0 R		DOTS2:		DD	DONXT,DOTS1		;loop till done
	   4000285C R
						D$	DOTQP,' <sp'
 40002870  400015B4 R	     1		DD	DOTQP				
 40002874 = 40002874	     1		_LEN	= $				
 40002874  00 20 3C 73 70    1		DB	0,' <sp' 			
 40002879 = 40002879	     1		_CODE	= $				
			     1	ORG	_LEN					
 40002874  04		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 4000287C  400001D4 R				DD	EXIT

				;   !CSP	( -- )
				;		Save stack pointer in CSP for error checking.

						$COLON	4,'!CSP',STCSP
			     1		$CODE	4,'!CSP',STCSP
			     2		ALIGN	4				
 40002880		     2	STCSP:						
 40002880 = 40002880	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001EF88		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF88  40002880 R	     2		DD	 _CODE,_LINK			
	   4001EFA0 R
 4001EF90 = 4001EF90	     2		_LINK	= $				
 4001EF90  04 21 43 53 50    2		DB	4,'!CSP'			
			     2	ORG	_CODE					
			     1		align	4
 40002880  48		     1		db	048h		
 40002881  21 FB	     1		db	021h,0fbh	
 40002883  25 FA	     1		db	025h,0fah	
 40002885  84		     1		db	084h		
 40002886  F0		     1		db	0f0h		
 40002887  30		     1		db	030h		
 40002888  F6		     1		db	0f6h		
 40002889  00 00 00	     1		db	0,0,0
 4000288C  400001C0 R	     1		dd	DOLST
 40002890  40000318 R				DD	SPAT,CSP,STORE,EXIT	;save pointer
	   40000594 R
	   40000254 R
	   400001D4 R

				;   ?CSP	( -- )
				;		Abort if stack pointer differs from that saved in CSP.

						$COLON	4,'?CSP',QCSP
			     1		$CODE	4,'?CSP',QCSP
			     2		ALIGN	4				
 400028A0		     2	QCSP:						
 400028A0 = 400028A0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001EF78		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF78  400028A0 R	     2		DD	 _CODE,_LINK			
	   4001EF90 R
 4001EF80 = 4001EF80	     2		_LINK	= $				
 4001EF80  04 3F 43 53 50    2		DB	4,'?CSP'			
			     2	ORG	_CODE					
			     1		align	4
 400028A0  48		     1		db	048h		
 400028A1  21 FB	     1		db	021h,0fbh	
 400028A3  25 FA	     1		db	025h,0fah	
 400028A5  84		     1		db	084h		
 400028A6  F0		     1		db	0f0h		
 400028A7  30		     1		db	030h		
 400028A8  F6		     1		db	0f6h		
 400028A9  00 00 00	     1		db	0,0,0
 400028AC  400001C0 R	     1		dd	DOLST
 400028B0  40000318 R				DD	SPAT,CSP,AT,XORR	;compare pointers
	   40000594 R
	   40000270 R
	   400003D4 R
						D$	ABORQ,'stacks'          ;abort if different
 400028C0  40001E14 R	     1		DD	ABORQ				
 400028C4 = 400028C4	     1		_LEN	= $				
 400028C4  00 73 74 61 63    1		DB	0,'stacks' 			
	   6B 73
 400028CB = 400028CB	     1		_CODE	= $				
			     1	ORG	_LEN					
 400028C4  06		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 400028CC  400001D4 R				DD	EXIT

				;   >NAME	( ca -- na | F )
				;		Convert code address to a name address.

						$COLON	5,'>NAME',TNAME
			     1		$CODE	5,'>NAME',TNAME
			     2		ALIGN	4				
 400028D0		     2	TNAME:						
 400028D0 = 400028D0	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001EF68		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF68  400028D0 R	     2		DD	 _CODE,_LINK			
	   4001EF80 R
 4001EF70 = 4001EF70	     2		_LINK	= $				
 4001EF70  05 3E 4E 41 4D    2		DB	5,'>NAME'			
	   45
			     2	ORG	_CODE					
			     1		align	4
 400028D0  48		     1		db	048h		
 400028D1  21 FB	     1		db	021h,0fbh	
 400028D3  25 FA	     1		db	025h,0fah	
 400028D5  84		     1		db	084h		
 400028D6  F0		     1		db	0f0h		
 400028D7  30		     1		db	030h		
 400028D8  F6		     1		db	0f6h		
 400028D9  00 00 00	     1		db	0,0,0
 400028DC  400001C0 R	     1		dd	DOLST
 400028E0  40000624 R				DD	CRRNT			;vocabulary link
 400028E4 40000C18 R		TNAM1:		DD	CELLP,AT,QDUP		;check all vocabularies
	   40000270 R
	   400006C0 R
 400028F0  40000220 R				DD	QBRAN,TNAM4
	   40002954 R
 400028F8  40000724 R				DD	DDUP
 400028FC 40000270 R		TNAM2:		DD	AT,DUPP 		;?last word in a vocabulary
	   40000350 R
 40002904  40000220 R				DD	QBRAN,TNAM3
	   4000292C R
 4000290C  40000724 R				DD	DDUP,NAMET,XORR 	;compare
	   40001950 R
	   400003D4 R
 40002918  40000220 R				DD	QBRAN,TNAM3
	   4000292C R
 40002920  40000C38 R				DD	CELLM			;continue with next word
 40002924  40000244 R				DD	BRAN,TNAM2
	   400028FC R
 4000292C 40000364 R		TNAM3:		DD	SWAP,DROP,QDUP
	   40000340 R
	   400006C0 R
 40002938  40000220 R				DD	QBRAN,TNAM1
	   400028E4 R
 40002940  40000364 R				DD	SWAP,DROP,SWAP,DROP,EXIT
	   40000340 R
	   40000364 R
	   40000340 R
	   400001D4 R
 40002954 40000340 R		TNAM4:		DD	DROP,DOLIT,0,EXIT	;false flag
	   400001A8 R
	   00000000
	   400001D4 R

				;   .ID 	( na -- )
				;		Display the name at address.

						$COLON	3,'.ID',DOTID
			     1		$CODE	3,'.ID',DOTID
			     2		ALIGN	4				
 40002964		     2	DOTID:						
 40002964 = 40002964	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001EF5C		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF5C  40002964 R	     2		DD	 _CODE,_LINK			
	   4001EF70 R
 4001EF64 = 4001EF64	     2		_LINK	= $				
 4001EF64  03 2E 49 44	     2		DB	3,'.ID'			
			     2	ORG	_CODE					
			     1		align	4
 40002964  48		     1		db	048h		
 40002965  21 FB	     1		db	021h,0fbh	
 40002967  25 FA	     1		db	025h,0fah	
 40002969  84		     1		db	084h		
 4000296A  F0		     1		db	0f0h		
 4000296B  30		     1		db	030h		
 4000296C  F6		     1		db	0f6h		
 4000296D  00 00 00	     1		db	0,0,0
 40002970  400001C0 R	     1		dd	DOLST
 40002974  400006C0 R				DD	QDUP			;if zero no name
 40002978  40000220 R				DD	QBRAN,DOTI1
	   40002998 R
 40002980  40000E0C R				DD	COUNT,DOLIT,01FH,ANDD	;mask lexicon bits
	   400001A8 R
	   0000001F
	   400003A4 R
 40002990  40002700 R				DD	UTYPE,EXIT		;display name string
	   400001D4 R
 40002998			DOTI1:		D$	DOTQP,' {noName}'
 40002998  400015B4 R	     1		DD	DOTQP				
 4000299C = 4000299C	     1		_LEN	= $				
 4000299C  00 20 7B 6E 6F    1		DB	0,' {noName}' 			
	   4E 61 6D 65 7D
 400029A6 = 400029A6	     1		_CODE	= $				
			     1	ORG	_LEN					
 4000299C  09		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 400029A8  400001D4 R				DD	EXIT

				;   SEE 	( -- ; <string> )
				;		A simple decompiler.

						$COLON	3,'SEE',SEE
			     1		$CODE	3,'SEE',SEE
			     2		ALIGN	4				
 400029AC		     2	SEE:						
 400029AC = 400029AC	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001EF50		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF50  400029AC R	     2		DD	 _CODE,_LINK			
	   4001EF64 R
 4001EF58 = 4001EF58	     2		_LINK	= $				
 4001EF58  03 53 45 45	     2		DB	3,'SEE'			
			     2	ORG	_CODE					
			     1		align	4
 400029AC  48		     1		db	048h		
 400029AD  21 FB	     1		db	021h,0fbh	
 400029AF  25 FA	     1		db	025h,0fah	
 400029B1  84		     1		db	084h		
 400029B2  F0		     1		db	0f0h		
 400029B3  30		     1		db	030h		
 400029B4  F6		     1		db	0f6h		
 400029B5  00 00 00	     1		db	0,0,0
 400029B8  400001C0 R	     1		dd	DOLST
 400029BC  4000211C R				DD	TICK			;starting address
 400029C0  40001538 R				DD	CR,CELLP
	   40000C18 R
 400029C8 40000C18 R		SEE1:		DD	CELLP,DUPP,AT,DUPP	;?does it contain a zero
	   40000350 R
	   40000270 R
	   40000350 R
 400029D8  40000220 R				DD	QBRAN,SEE2
	   400029E4 R
 400029E0  400028D0 R				DD	TNAME			;?is it a name
 400029E4 400006C0 R		SEE2:		DD	QDUP			;name address or zero
 400029E8  40000220 R				DD	QBRAN,SEE3
	   40002A00 R
 400029F0  400014A0 R				DD	SPACE,DOTID		;display name
	   40002964 R
 400029F8  40000244 R				DD	BRAN,SEE4
	   40002A0C R
 40002A00 40000350 R		SEE3:		DD	DUPP,AT,UDOT		;display number
	   40000270 R
	   4000163C R
 40002A0C 40001448 R		SEE4:		DD	NUFQ			;user control
 40002A10  40000220 R				DD	QBRAN,SEE1
	   400029C8 R
 40002A18  40000340 R				DD	DROP,EXIT
	   400001D4 R

				;   WORDS	( -- )
				;		Display the names in the context vocabulary.

						$COLON	5,'WORDS',WORDS
			     1		$CODE	5,'WORDS',WORDS
			     2		ALIGN	4				
 40002A20		     2	WORDS:						
 40002A20 = 40002A20	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001EF40		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF40  40002A20 R	     2		DD	 _CODE,_LINK			
	   4001EF58 R
 4001EF48 = 4001EF48	     2		_LINK	= $				
 4001EF48  05 57 4F 52 44    2		DB	5,'WORDS'			
	   53
			     2	ORG	_CODE					
			     1		align	4
 40002A20  48		     1		db	048h		
 40002A21  21 FB	     1		db	021h,0fbh	
 40002A23  25 FA	     1		db	025h,0fah	
 40002A25  84		     1		db	084h		
 40002A26  F0		     1		db	0f0h		
 40002A27  30		     1		db	030h		
 40002A28  F6		     1		db	0f6h		
 40002A29  00 00 00	     1		db	0,0,0
 40002A2C  400001C0 R	     1		dd	DOLST
 40002A30  40001538 R				DD	CR,CNTXT,AT		;only in context
	   4000060C R
	   40000270 R
 40002A3C 40000270 R		WORS1:		DD	AT,QDUP 		;?at end of list
	   400006C0 R
 40002A44  40000220 R				DD	QBRAN,WORS2
	   40002A6C R
 40002A4C  40000350 R				DD	DUPP,SPACE,DOTID	;display a name
	   400014A0 R
	   40002964 R
 40002A58  40000C38 R				DD	CELLM,NUFQ		;user control
	   40001448 R
 40002A60  40000220 R				DD	QBRAN,WORS1
	   40002A3C R
 40002A68  40000340 R				DD	DROP
 40002A6C 400001D4 R		WORS2:		DD	EXIT

				;; Hardware reset

				;   VER 	( -- n )
				;		Return the version number of this implementation.

						$COLON	3,'VER',VERSN
			     1		$CODE	3,'VER',VERSN
			     2		ALIGN	4				
 40002A70		     2	VERSN:						
 40002A70 = 40002A70	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (3 AND 01FH)/CELLL		
 = 4001EF34		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF34  40002A70 R	     2		DD	 _CODE,_LINK			
	   4001EF48 R
 4001EF3C = 4001EF3C	     2		_LINK	= $				
 4001EF3C  03 56 45 52	     2		DB	3,'VER'			
			     2	ORG	_CODE					
			     1		align	4
 40002A70  48		     1		db	048h		
 40002A71  21 FB	     1		db	021h,0fbh	
 40002A73  25 FA	     1		db	025h,0fah	
 40002A75  84		     1		db	084h		
 40002A76  F0		     1		db	0f0h		
 40002A77  30		     1		db	030h		
 40002A78  F6		     1		db	0f6h		
 40002A79  00 00 00	     1		db	0,0,0
 40002A7C  400001C0 R	     1		dd	DOLST
 40002A80  400001A8 R				DD	DOLIT,VER*256+EXT,EXIT
	   00000101
	   400001D4 R

				;   hi		( -- )
				;		Display the sign-on message of eForth.

						$COLON	2,'hi',HI
			     1		$CODE	2,'hi',HI
			     2		ALIGN	4				
 40002A8C		     2	HI:						
 40002A8C = 40002A8C	     2		_CODE	= $				
 = 00000000		     2		_LEN	= (2 AND 01FH)/CELLL		
 = 4001EF28		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF28  40002A8C R	     2		DD	 _CODE,_LINK			
	   4001EF3C R
 4001EF30 = 4001EF30	     2		_LINK	= $				
 4001EF30  02 68 69	     2		DB	2,'hi'			
			     2	ORG	_CODE					
			     1		align	4
 40002A8C  48		     1		db	048h		
 40002A8D  21 FB	     1		db	021h,0fbh	
 40002A8F  25 FA	     1		db	025h,0fah	
 40002A91  84		     1		db	084h		
 40002A92  F0		     1		db	0f0h		
 40002A93  30		     1		db	030h		
 40002A94  F6		     1		db	0f6h		
 40002A95  00 00 00	     1		db	0,0,0
 40002A98  400001C0 R	     1		dd	DOLST
 40002A9C  40000158 R				DD	STOIO,CR		;initialize I/O
	   40001538 R
						D$	DOTQP,'eForth v'        ;model
 40002AA4  400015B4 R	     1		DD	DOTQP				
 40002AA8 = 40002AA8	     1		_LEN	= $				
 40002AA8  00 65 46 6F 72    1		DB	0,'eForth v' 			
	   74 68 20 76
 40002AB1 = 40002AB1	     1		_CODE	= $				
			     1	ORG	_LEN					
 40002AA8  08		     1		DB	_CODE-_LEN-1			
			     1	ORG	_CODE					
			     1		ALIGN	4
 40002AB4  4000051C R				DD	BASE,AT,HEX		;save radix
	   40000270 R
	   400011E4 R
 40002AC0  40002A70 R				DD	VERSN,BDIGS,DIG,DIG
	   400010B0 R
	   40001108 R
	   40001108 R
 40002AD0  400001A8 R				DD	DOLIT,'.',HOLD
	   0000002E
	   400010D0 R
 40002ADC  4000112C R				DD	DIGS,EDIGS,TYPEE	;format version number
	   40001184 R
	   400014F4 R
 40002AE8  4000051C R				DD	BASE,STORE,CR,EXIT	;restore radix
	   40000254 R
	   40001538 R
	   400001D4 R

				;   'BOOT       ( -- a )
				;		The application startup vector.

						$COLON	5,"'BOOT",TBOOT
			     1		$CODE	5,"'BOOT",TBOOT
			     2		ALIGN	4				
 40002AF8		     2	TBOOT:						
 40002AF8 = 40002AF8	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (5 AND 01FH)/CELLL		
 = 4001EF18		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF18  40002AF8 R	     2		DD	 _CODE,_LINK			
	   4001EF30 R
 4001EF20 = 4001EF20	     2		_LINK	= $				
 4001EF20  05 27 42 4F 4F    2		DB	5,"'BOOT"			
	   54
			     2	ORG	_CODE					
			     1		align	4
 40002AF8  48		     1		db	048h		
 40002AF9  21 FB	     1		db	021h,0fbh	
 40002AFB  25 FA	     1		db	025h,0fah	
 40002AFD  84		     1		db	084h		
 40002AFE  F0		     1		db	0f0h		
 40002AFF  30		     1		db	030h		
 40002B00  F6		     1		db	0f6h		
 40002B01  00 00 00	     1		db	0,0,0
 40002B04  400001C0 R	     1		dd	DOLST
 40002B08  40000404 R				DD	DOVAR
 40002B0C  40002A8C R				DD	HI			;application to boot

				;   COLD	( -- )
				;		The hilevel cold start sequence.

						$COLON	4,'COLD',COLD
			     1		$CODE	4,'COLD',COLD
			     2		ALIGN	4				
 40002B10		     2	COLD:						
 40002B10 = 40002B10	     2		_CODE	= $				
 = 00000001		     2		_LEN	= (4 AND 01FH)/CELLL		
 = 4001EF08		     2		_NAME	= _NAME-((_LEN+3)*CELLL)	
			     2	ORG	_NAME					
 4001EF08  40002B10 R	     2		DD	 _CODE,_LINK			
	   4001EF20 R
 4001EF10 = 4001EF10	     2		_LINK	= $				
 4001EF10  04 43 4F 4C 44    2		DB	4,'COLD'			
			     2	ORG	_CODE					
			     1		align	4
 40002B10  48		     1		db	048h		
 40002B11  21 FB	     1		db	021h,0fbh	
 40002B13  25 FA	     1		db	025h,0fah	
 40002B15  84		     1		db	084h		
 40002B16  F0		     1		db	0f0h		
 40002B17  30		     1		db	030h		
 40002B18  F6		     1		db	0f6h		
 40002B19  00 00 00	     1		db	0,0,0
 40002B1C  400001C0 R	     1		dd	DOLST
 40002B20 400001A8 R		COLD1:		DD	DOLIT,UZERO,DOLIT,UPP
	   40000074 R
	   400001A8 R
	   4001FB7C
 40002B30  400001A8 R				DD	DOLIT,ULAST-UZERO,CMOVE ;initialize user area
	   00000094
	   40000EC0 R
 40002B3C  40001F78 R				DD	PRESE			;initialize stack and TIB
 40002B40  40002AF8 R				DD	TBOOT,ATEXE		;application boot
	   40000E98 R
 40002B48  400006A4 R				DD	FORTH,CNTXT,AT,DUPP	;initialize search order
	   4000060C R
	   40000270 R
	   40000350 R
 40002B58  40000624 R				DD	CRRNT,DSTOR,OVERT
	   40000DBC R
	   40002560 R
 40002B64  4000207C R				DD	QUIT			;start interpretation
 40002B68  40000244 R				DD	BRAN,COLD1		;just in case
	   40002B20 R

				;===============================================================

 = 4001EF0C			LASTN		EQU	_NAME+4 		;last name address


 = 4001EF08			NTOP	EQU	_NAME-0 	;next available memory in name dictionary
 40002B70 = 40002B70		CTOP	EQU	$+0		;next available memory in code dictionary

					org	4000ff80h		; vector start from top of rom

 4000FF80  27 2F 2F 2F			db	27h,2fh,2fh,2fh
 4000FF84  20 20 20 40			db	20h,20h,20h,40h 	; from start of rom
 4000FF88  24 20 20 20			db	24h,20h,20h,20h
 4000FF8C  20 20 20 40			db	20h,20h,20h,40h 	; to start of ram
 4000FF90  28 20 20 40			db	28h,20h,20h,40h 	; for 32k bytes
					move				; do the move
 4000FF94  24 FA	     1		db	024h,0fah
 4000FF96  27 2F 2F 2F			db	27h,2fh,2fh,2fh
 4000FF9A  28 20 20 40			db	28h,20h,20h,40h 	; from middle of rom
 4000FF9E  24 20 20 21			db	24h,20h,20h,21h
 4000FFA2  28 20 20 40			db	28h,20h,20h,40h 	; to end of ram
 4000FFA6  28 20 20 40			db	28h,20h,20h,40h 	; for 32k bytes
					move				; do the move
 4000FFAA  24 FA	     1		db	024h,0fah
 4000FFAC  24 20 20 20			db	24h,20h,20h,20h 	; set for jump
 4000FFB0  20 20 20 40			db	20h,20h,20h,40h 	; to start of ram
					gcall				; do the jump
 4000FFB4  F6		     1		db	0f6h

					org	4000fffeh
 4000FFFE  67 00			db	67h,00h 		; rel jump back 80h locations

 40010000			MAIN	ENDS
				END	ORIG

				;===============================================================

Microsoft (R) Macro Assembler Version 6.15.8803		    04/17/18 18:43:46
InMos Transputer 32-bit eForth				     Symbols 2 - 1




Macros:

                N a m e                 Type

$CODE  . . . . . . . . . . . . .	Proc
$COLON . . . . . . . . . . . . .	Proc
$NEXT  . . . . . . . . . . . . .	Proc
$USER  . . . . . . . . . . . . .	Proc
D$ . . . . . . . . . . . . . . .	Proc
adcx . . . . . . . . . . . . . .	Proc
andx . . . . . . . . . . . . . .	Proc
celldn . . . . . . . . . . . . .	Proc
dupx . . . . . . . . . . . . . .	Proc
eqc  . . . . . . . . . . . . . .	Proc
gcall  . . . . . . . . . . . . .	Proc
jzx  . . . . . . . . . . . . . .	Proc
lb . . . . . . . . . . . . . . .	Proc
ldc  . . . . . . . . . . . . . .	Proc
ldl  . . . . . . . . . . . . . .	Proc
ldnl . . . . . . . . . . . . . .	Proc
mint . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . .	Proc
notx . . . . . . . . . . . . . .	Proc
orx  . . . . . . . . . . . . . .	Proc
popx . . . . . . . . . . . . . .	Proc
prfx . . . . . . . . . . . . . .	Proc
pushx  . . . . . . . . . . . . .	Proc
rev  . . . . . . . . . . . . . .	Proc
sb . . . . . . . . . . . . . . .	Proc
stl  . . . . . . . . . . . . . .	Proc
stnl . . . . . . . . . . . . . .	Proc
uwait  . . . . . . . . . . . . .	Proc
xorx . . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

MAIN . . . . . . . . . . . . . .	32 Bit	 4001FB5C Para	  Private 


Symbols:

                N a m e                 Type     Value    Attr

ABOR1  . . . . . . . . . . . . .	L Near	 40001E34 MAIN	
ABORQ  . . . . . . . . . . . . .	L Near	 40001E14 MAIN	
ABORT  . . . . . . . . . . . . .	L Near	 40001DFC MAIN	
ABRTQ  . . . . . . . . . . . . .	L Near	 400023E0 MAIN	
ABS1 . . . . . . . . . . . . . .	L Near	 40000814 MAIN	
ABSS . . . . . . . . . . . . . .	L Near	 400007F0 MAIN	
ACCEP  . . . . . . . . . . . . .	L Near	 40001C60 MAIN	
ACCP1  . . . . . . . . . . . . .	L Near	 40001C7C MAIN	
ACCP2  . . . . . . . . . . . . .	L Near	 40001CB8 MAIN	
ACCP3  . . . . . . . . . . . . .	L Near	 40001CC0 MAIN	
ACCP4  . . . . . . . . . . . . .	L Near	 40001CC8 MAIN	
AFT  . . . . . . . . . . . . . .	L Near	 40002380 MAIN	
AGAIN  . . . . . . . . . . . . .	L Near	 400022C4 MAIN	
AHEAD  . . . . . . . . . . . . .	L Near	 40002310 MAIN	
ALGN1  . . . . . . . . . . . . .	L Near	 40000CC0 MAIN	
ALGND  . . . . . . . . . . . . .	L Near	 40000C78 MAIN	
ALLOT  . . . . . . . . . . . . .	L Near	 40002144 MAIN	
ANDD . . . . . . . . . . . . . .	L Near	 400003A4 MAIN	
ATEXE  . . . . . . . . . . . . .	L Near	 40000E98 MAIN	
AT . . . . . . . . . . . . . . .	L Near	 40000270 MAIN	
BACK1  . . . . . . . . . . . . .	L Near	 40001BC4 MAIN	
BASEE  . . . . . . . . . . . . .	Number	 000Ah	 
BASE . . . . . . . . . . . . . .	L Near	 4000051C MAIN	
BCOMP  . . . . . . . . . . . . .	L Near	 4000218C MAIN	
BDIGS  . . . . . . . . . . . . .	L Near	 400010B0 MAIN	
BEGIN  . . . . . . . . . . . . .	L Near	 4000226C MAIN	
BKSLA  . . . . . . . . . . . . .	L Near	 400018A8 MAIN	
BKSPP  . . . . . . . . . . . . .	Number	 0008h	 
BKSP . . . . . . . . . . . . . .	L Near	 40001B5C MAIN	
BLANK  . . . . . . . . . . . . .	L Near	 40000CC8 MAIN	
BRAN1  . . . . . . . . . . . . .	L Near	 40000235 MAIN	
BRAN . . . . . . . . . . . . . .	L Near	 40000244 MAIN	
CALLC  . . . . . . . . . . . . .	L Near	 400025D0 MAIN	
CALLL  . . . . . . . . . . . . .	Number	 0000h	 
CATCH  . . . . . . . . . . . . .	L Near	 40001D44 MAIN	
CAT  . . . . . . . . . . . . . .	L Near	 4000029C MAIN	
CELLL  . . . . . . . . . . . . .	Number	 0004h	 
CELLM  . . . . . . . . . . . . .	L Near	 40000C38 MAIN	
CELLP  . . . . . . . . . . . . .	L Near	 40000C18 MAIN	
CELLS  . . . . . . . . . . . . .	L Near	 40000C58 MAIN	
CHAR1  . . . . . . . . . . . . .	L Near	 400014E4 MAIN	
CHAR2  . . . . . . . . . . . . .	L Near	 400014E8 MAIN	
CHAR . . . . . . . . . . . . . .	L Near	 400018CC MAIN	
CMOV1  . . . . . . . . . . . . .	L Near	 40000EDC MAIN	
CMOV2  . . . . . . . . . . . . .	L Near	 40000F0C MAIN	
CMOVE  . . . . . . . . . . . . .	L Near	 40000EC0 MAIN	
CNTXT  . . . . . . . . . . . . .	L Near	 4000060C MAIN	
CODEE  . . . . . . . . . . . . .	Number	 40000100h   
COLD1  . . . . . . . . . . . . .	L Near	 40002B20 MAIN	
COLDD  . . . . . . . . . . . . .	Number	 40000000h   
COLD . . . . . . . . . . . . . .	L Near	 40002B10 MAIN	
COLON  . . . . . . . . . . . . .	L Near	 4000260C MAIN	
COMMA  . . . . . . . . . . . . .	L Near	 40002160 MAIN	
COMPI  . . . . . . . . . . . . .	L Near	 400021A8 MAIN	
COMPO  . . . . . . . . . . . . .	Number	 0040h	 
CONSO  . . . . . . . . . . . . .	L Near	 40002054 MAIN	
COUNT  . . . . . . . . . . . . .	L Near	 40000E0C MAIN	
CP . . . . . . . . . . . . . . .	L Near	 4000063C MAIN	
CREAT  . . . . . . . . . . . . .	L Near	 400026A8 MAIN	
CRRNT  . . . . . . . . . . . . .	L Near	 40000624 MAIN	
CRR  . . . . . . . . . . . . . .	Number	 000Dh	 
CR . . . . . . . . . . . . . . .	L Near	 40001538 MAIN	
CSP  . . . . . . . . . . . . . .	L Near	 40000594 MAIN	
CSTOR  . . . . . . . . . . . . .	L Near	 40000280 MAIN	
CTOP . . . . . . . . . . . . . .	Number	 40002B70h   
DAT  . . . . . . . . . . . . . .	L Near	 40000DE4 MAIN	
DDROP  . . . . . . . . . . . . .	L Near	 40000708 MAIN	
DDUP . . . . . . . . . . . . . .	L Near	 40000724 MAIN	
DECIM  . . . . . . . . . . . . .	L Near	 40001208 MAIN	
DEPTH  . . . . . . . . . . . . .	L Near	 40000D2C MAIN	
DGTQ1  . . . . . . . . . . . . .	L Near	 40001284 MAIN	
DIGIT  . . . . . . . . . . . . .	L Near	 40001044 MAIN	
DIGS1  . . . . . . . . . . . . .	L Near	 4000113C MAIN	
DIGS2  . . . . . . . . . . . . .	L Near	 40001154 MAIN	
DIGS . . . . . . . . . . . . . .	L Near	 4000112C MAIN	
DIGTQ  . . . . . . . . . . . . .	L Near	 4000122C MAIN	
DIG  . . . . . . . . . . . . . .	L Near	 40001108 MAIN	
DMP  . . . . . . . . . . . . . .	L Near	 40002748 MAIN	
DNEGA  . . . . . . . . . . . . .	L Near	 400007A0 MAIN	
DOLIT  . . . . . . . . . . . . .	L Near	 400001A8 MAIN	
DOLST  . . . . . . . . . . . . .	L Near	 400001C0 MAIN	
DONXT  . . . . . . . . . . . . .	L Near	 400001F0 MAIN	
DOSTR  . . . . . . . . . . . . .	L Near	 40001564 MAIN	
DOT1 . . . . . . . . . . . . . .	L Near	 40001698 MAIN	
DOTI1  . . . . . . . . . . . . .	L Near	 40002998 MAIN	
DOTID  . . . . . . . . . . . . .	L Near	 40002964 MAIN	
DOTO1  . . . . . . . . . . . . .	L Near	 40001EFC MAIN	
DOTOK  . . . . . . . . . . . . .	L Near	 40001EC8 MAIN	
DOTPR  . . . . . . . . . . . . .	L Near	 40001860 MAIN	
DOTQP  . . . . . . . . . . . . .	L Near	 400015B4 MAIN	
DOTQ . . . . . . . . . . . . . .	L Near	 40002420 MAIN	
DOTR . . . . . . . . . . . . . .	L Near	 400015D4 MAIN	
DOTS1  . . . . . . . . . . . . .	L Near	 4000285C MAIN	
DOTS2  . . . . . . . . . . . . .	L Near	 40002868 MAIN	
DOTS . . . . . . . . . . . . . .	L Near	 40002838 MAIN	
DOT  . . . . . . . . . . . . . .	L Near	 40001664 MAIN	
DOUSE  . . . . . . . . . . . . .	L Near	 40000434 MAIN	
DOVAR  . . . . . . . . . . . . .	L Near	 40000404 MAIN	
DOVOC  . . . . . . . . . . . . .	L Near	 40000684 MAIN	
DROP . . . . . . . . . . . . . .	L Near	 40000340 MAIN	
DSTOR  . . . . . . . . . . . . .	L Near	 40000DBC MAIN	
DTRA1  . . . . . . . . . . . . .	L Near	 40000F80 MAIN	
DTRA2  . . . . . . . . . . . . .	L Near	 40000FB4 MAIN	
DTRAI  . . . . . . . . . . . . .	L Near	 40000F64 MAIN	
DUMP1  . . . . . . . . . . . . .	L Near	 400027D4 MAIN	
DUMP2  . . . . . . . . . . . . .	L Near	 4000281C MAIN	
DUMP3  . . . . . . . . . . . . .	L Near	 40002824 MAIN	
DUMP . . . . . . . . . . . . . .	L Near	 400027A4 MAIN	
DUPP . . . . . . . . . . . . . .	L Near	 40000350 MAIN	
EDIGS  . . . . . . . . . . . . .	L Near	 40001184 MAIN	
ELSEE  . . . . . . . . . . . . .	L Near	 400023A4 MAIN	
EMIT . . . . . . . . . . . . . .	L Near	 4000142C MAIN	
EM . . . . . . . . . . . . . . .	Number	 4001FF7Ch   
EQU1 . . . . . . . . . . . . . .	L Near	 40000840 MAIN	
EQUAL  . . . . . . . . . . . . .	L Near	 40000818 MAIN	
ERRESC . . . . . . . . . . . . .	Number	 001Bh	 
EVAL1  . . . . . . . . . . . . .	L Near	 40001F40 MAIN	
EVAL2  . . . . . . . . . . . . .	L Near	 40001F68 MAIN	
EVAL . . . . . . . . . . . . . .	L Near	 40001F30 MAIN	
EXE1 . . . . . . . . . . . . . .	L Near	 40000EBC MAIN	
EXECU  . . . . . . . . . . . . .	L Near	 400001E8 MAIN	
EXIT . . . . . . . . . . . . . .	L Near	 400001D4 MAIN	
EXPEC  . . . . . . . . . . . . .	L Near	 40001CD8 MAIN	
EXTRC  . . . . . . . . . . . . .	L Near	 40001084 MAIN	
EXT  . . . . . . . . . . . . . .	Number	 0001h	 
FILE . . . . . . . . . . . . . .	L Near	 40001FD8 MAIN	
FILL1  . . . . . . . . . . . . .	L Near	 40000F40 MAIN	
FILL2  . . . . . . . . . . . . .	L Near	 40000F54 MAIN	
FILL . . . . . . . . . . . . . .	L Near	 40000F1C MAIN	
FIND1  . . . . . . . . . . . . .	L Near	 40001A28 MAIN	
FIND2  . . . . . . . . . . . . .	L Near	 40001A70 MAIN	
FIND3  . . . . . . . . . . . . .	L Near	 40001A80 MAIN	
FIND4  . . . . . . . . . . . . .	L Near	 40001AA0 MAIN	
FIND5  . . . . . . . . . . . . .	L Near	 40001AB8 MAIN	
FIND6  . . . . . . . . . . . . .	L Near	 40001A88 MAIN	
FIND . . . . . . . . . . . . . .	L Near	 400019E4 MAIN	
FORTH  . . . . . . . . . . . . .	L Near	 400006A4 MAIN	
FOR_ . . . . . . . . . . . . . .	L Near	 4000224C MAIN	
HANDL  . . . . . . . . . . . . .	L Near	 400005F4 MAIN	
HAND . . . . . . . . . . . . . .	L Near	 40002008 MAIN	
HERE . . . . . . . . . . . . . .	L Near	 40000E38 MAIN	
HEX  . . . . . . . . . . . . . .	L Near	 400011E4 MAIN	
HI . . . . . . . . . . . . . . .	L Near	 40002A8C MAIN	
HLD  . . . . . . . . . . . . . .	L Near	 400005DC MAIN	
HOLD . . . . . . . . . . . . . .	L Near	 400010D0 MAIN	
IFF  . . . . . . . . . . . . . .	L Near	 400022E4 MAIN	
IMEDD  . . . . . . . . . . . . .	Number	 0080h	 
IMMED  . . . . . . . . . . . . .	L Near	 40002638 MAIN	
INN  . . . . . . . . . . . . . .	L Near	 40000564 MAIN	
INTE1  . . . . . . . . . . . . .	L Near	 40001E8C MAIN	
INTE2  . . . . . . . . . . . . .	L Near	 40001EA0 MAIN	
INTER  . . . . . . . . . . . . .	L Near	 40001E40 MAIN	
INVER  . . . . . . . . . . . . .	L Near	 4000075C MAIN	
ISLO . . . . . . . . . . . . . .	L Near	 40002038 MAIN	
KEY1 . . . . . . . . . . . . . .	L Near	 4000141C MAIN	
KEY  . . . . . . . . . . . . . .	L Near	 4000140C MAIN	
KTAP1  . . . . . . . . . . . . .	L Near	 40001C44 MAIN	
KTAP2  . . . . . . . . . . . . .	L Near	 40001C4C MAIN	
KTAP . . . . . . . . . . . . . .	L Near	 40001BFC MAIN	
LASTN  . . . . . . . . . . . . .	Number	 4001EF0Ch   
LAST . . . . . . . . . . . . . .	L Near	 4000066C MAIN	
LBRAC  . . . . . . . . . . . . .	L Near	 40001EA4 MAIN	
LESS1  . . . . . . . . . . . . .	L Near	 400008BC MAIN	
LESS . . . . . . . . . . . . . .	L Near	 4000088C MAIN	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LITER  . . . . . . . . . . . . .	L Near	 400021D4 MAIN	
MASKK  . . . . . . . . . . . . .	Number	 7F1Fh	 
MAX1 . . . . . . . . . . . . . .	L Near	 400008EC MAIN	
MAX  . . . . . . . . . . . . . .	L Near	 400008C8 MAIN	
MIN1 . . . . . . . . . . . . . .	L Near	 4000091C MAIN	
MIN  . . . . . . . . . . . . . .	L Near	 400008F4 MAIN	
MMOD1  . . . . . . . . . . . . .	L Near	 40000A58 MAIN	
MMOD2  . . . . . . . . . . . . .	L Near	 40000A74 MAIN	
MMOD3  . . . . . . . . . . . . .	L Near	 40000A94 MAIN	
MODD . . . . . . . . . . . . . .	L Near	 40000ABC MAIN	
MSMOD  . . . . . . . . . . . . .	L Near	 40000A20 MAIN	
MSTA1  . . . . . . . . . . . . .	L Near	 40000BD0 MAIN	
MSTAR  . . . . . . . . . . . . .	L Near	 40000B90 MAIN	
NAMEE  . . . . . . . . . . . . .	Number	 4001FB5Ch   
NAMEQ  . . . . . . . . . . . . .	L Near	 40001ADC MAIN	
NAMET  . . . . . . . . . . . . .	L Near	 40001950 MAIN	
NAMQ1  . . . . . . . . . . . . .	L Near	 40001B08 MAIN	
NAMQ2  . . . . . . . . . . . . .	L Near	 40001B0C MAIN	
NAMQ3  . . . . . . . . . . . . .	L Near	 40001B48 MAIN	
NEGAT  . . . . . . . . . . . . .	L Near	 4000077C MAIN	
NEXT1  . . . . . . . . . . . . .	L Near	 4000020C MAIN	
NEXT . . . . . . . . . . . . . .	L Near	 40002284 MAIN	
NP . . . . . . . . . . . . . . .	L Near	 40000654 MAIN	
NTIB . . . . . . . . . . . . . .	L Near	 4000057C MAIN	
NTOP . . . . . . . . . . . . . .	Number	 4001EF08h   
NUFQ1  . . . . . . . . . . . . .	L Near	 4000147C MAIN	
NUFQ . . . . . . . . . . . . . .	L Near	 40001448 MAIN	
NULLS  . . . . . . . . . . . . .	L Near	 40001DDC MAIN	
NUMBQ  . . . . . . . . . . . . .	L Near	 40001294 MAIN	
NUMQ1  . . . . . . . . . . . . .	L Near	 40001300 MAIN	
NUMQ2  . . . . . . . . . . . . .	L Near	 4000134C MAIN	
NUMQ3  . . . . . . . . . . . . .	L Near	 400013B0 MAIN	
NUMQ4  . . . . . . . . . . . . .	L Near	 400013BC MAIN	
NUMQ5  . . . . . . . . . . . . .	L Near	 400013D4 MAIN	
NUMQ6  . . . . . . . . . . . . .	L Near	 400013D8 MAIN	
ORIG . . . . . . . . . . . . . .	L Near	 40000000 MAIN	
ORR  . . . . . . . . . . . . . .	L Near	 400003BC MAIN	
OVERT  . . . . . . . . . . . . .	L Near	 40002560 MAIN	
OVER . . . . . . . . . . . . . .	L Near	 40000378 MAIN	
PACE . . . . . . . . . . . . . .	L Near	 40001480 MAIN	
PACKS  . . . . . . . . . . . . .	L Near	 40000FC8 MAIN	
PAD  . . . . . . . . . . . . . .	L Near	 40000E54 MAIN	
PAREN  . . . . . . . . . . . . .	L Near	 40001884 MAIN	
PARS1  . . . . . . . . . . . . .	L Near	 40001718 MAIN	
PARS2  . . . . . . . . . . . . .	L Near	 40001764 MAIN	
PARS3  . . . . . . . . . . . . .	L Near	 40001768 MAIN	
PARS4  . . . . . . . . . . . . .	L Near	 40001774 MAIN	
PARS5  . . . . . . . . . . . . .	L Near	 400017A4 MAIN	
PARS6  . . . . . . . . . . . . .	L Near	 400017D0 MAIN	
PARS7  . . . . . . . . . . . . .	L Near	 400017EC MAIN	
PARS8  . . . . . . . . . . . . .	L Near	 40001804 MAIN	
PARSE  . . . . . . . . . . . . .	L Near	 40001814 MAIN	
PARS . . . . . . . . . . . . . .	L Near	 400016C4 MAIN	
PDUM1  . . . . . . . . . . . . .	L Near	 40002778 MAIN	
PDUM2  . . . . . . . . . . . . .	L Near	 40002798 MAIN	
PICK . . . . . . . . . . . . . .	L Near	 40000D60 MAIN	
PLUS . . . . . . . . . . . . . .	L Near	 40000740 MAIN	
PNAM1  . . . . . . . . . . . . .	L Near	 400024EC MAIN	
PRESE  . . . . . . . . . . . . .	L Near	 40001F78 MAIN	
PSTOR  . . . . . . . . . . . . .	L Near	 40000D90 MAIN	
QBRAN  . . . . . . . . . . . . .	L Near	 40000220 MAIN	
QCSP . . . . . . . . . . . . . .	L Near	 400028A0 MAIN	
QDUP1  . . . . . . . . . . . . .	L Near	 400006E0 MAIN	
QDUP . . . . . . . . . . . . . .	L Near	 400006C0 MAIN	
QKEY . . . . . . . . . . . . . .	L Near	 400013F0 MAIN	
QRX  . . . . . . . . . . . . . .	L Near	 40000108 MAIN	
QSTAC  . . . . . . . . . . . . .	L Near	 40001F04 MAIN	
QUERY  . . . . . . . . . . . . .	L Near	 40001D00 MAIN	
QUEST  . . . . . . . . . . . . .	L Near	 400016A8 MAIN	
QUIT1  . . . . . . . . . . . . .	L Near	 40002098 MAIN	
QUIT2  . . . . . . . . . . . . .	L Near	 4000209C MAIN	
QUIT3  . . . . . . . . . . . . .	L Near	 400020F0 MAIN	
QUIT4  . . . . . . . . . . . . .	L Near	 40002110 MAIN	
QUIT . . . . . . . . . . . . . .	L Near	 4000207C MAIN	
RAT  . . . . . . . . . . . . . .	L Near	 400002EC MAIN	
RBRAC  . . . . . . . . . . . . .	L Near	 400025AC MAIN	
RECUR  . . . . . . . . . . . . .	L Near	 40002228 MAIN	
REPEA  . . . . . . . . . . . . .	L Near	 4000233C MAIN	
RFROM  . . . . . . . . . . . . .	L Near	 400002D4 MAIN	
ROT  . . . . . . . . . . . . . .	L Near	 400006E4 MAIN	
RPAT . . . . . . . . . . . . . .	L Near	 400002AC MAIN	
RPP  . . . . . . . . . . . . . .	Number	 4001FF5Ch   
RPSTO  . . . . . . . . . . . . .	L Near	 400002C0 MAIN	
RTS  . . . . . . . . . . . . . .	Number	 0100h	 
RZERO  . . . . . . . . . . . . .	L Near	 40000474 MAIN	
SAME1  . . . . . . . . . . . . .	L Near	 4000198C MAIN	
SAME2  . . . . . . . . . . . . .	L Near	 400019D0 MAIN	
SAMEQ  . . . . . . . . . . . . .	L Near	 40001970 MAIN	
SCOM1  . . . . . . . . . . . . .	L Near	 4000253C MAIN	
SCOM2  . . . . . . . . . . . . .	L Near	 40002544 MAIN	
SCOM3  . . . . . . . . . . . . .	L Near	 4000255C MAIN	
SCOMP  . . . . . . . . . . . . .	L Near	 400024FC MAIN	
SEE1 . . . . . . . . . . . . . .	L Near	 400029C8 MAIN	
SEE2 . . . . . . . . . . . . . .	L Near	 400029E4 MAIN	
SEE3 . . . . . . . . . . . . . .	L Near	 40002A00 MAIN	
SEE4 . . . . . . . . . . . . . .	L Near	 40002A0C MAIN	
SEE  . . . . . . . . . . . . . .	L Near	 400029AC MAIN	
SEMIS  . . . . . . . . . . . . .	L Near	 40002588 MAIN	
SIGN1  . . . . . . . . . . . . .	L Near	 40001180 MAIN	
SIGN . . . . . . . . . . . . . .	L Near	 40001158 MAIN	
SLASH  . . . . . . . . . . . . .	L Near	 40000AD8 MAIN	
SLMOD  . . . . . . . . . . . . .	L Near	 40000A98 MAIN	
SNAME  . . . . . . . . . . . . .	L Near	 40002480 MAIN	
SPACE  . . . . . . . . . . . . .	L Near	 400014A0 MAIN	
SPACS  . . . . . . . . . . . . .	L Near	 400014BC MAIN	
SPAN . . . . . . . . . . . . . .	L Near	 4000054C MAIN	
SPAT . . . . . . . . . . . . . .	L Near	 40000318 MAIN	
SPP  . . . . . . . . . . . . . .	Number	 4001FE3Ch   
SPSTO  . . . . . . . . . . . . .	L Near	 4000032C MAIN	
SSMOD  . . . . . . . . . . . . .	L Near	 40000BD4 MAIN	
STAR . . . . . . . . . . . . . .	L Near	 40000B74 MAIN	
STASL  . . . . . . . . . . . . .	L Near	 40000BF8 MAIN	
STCSP  . . . . . . . . . . . . .	L Near	 40002880 MAIN	
STOIO  . . . . . . . . . . . . .	L Near	 40000158 MAIN	
STORE  . . . . . . . . . . . . .	L Near	 40000254 MAIN	
STRCQ  . . . . . . . . . . . . .	L Near	 400021F4 MAIN	
STRN . . . . . . . . . . . . . .	L Near	 400011B0 MAIN	
STRQP  . . . . . . . . . . . . .	L Near	 4000159C MAIN	
STRQ . . . . . . . . . . . . . .	L Near	 40002400 MAIN	
SUBB . . . . . . . . . . . . . .	L Near	 400007D4 MAIN	
SWAP . . . . . . . . . . . . . .	L Near	 40000364 MAIN	
SZERO  . . . . . . . . . . . . .	L Near	 4000045C MAIN	
TAP  . . . . . . . . . . . . . .	L Near	 40001BC8 MAIN	
TBOOT  . . . . . . . . . . . . .	L Near	 40002AF8 MAIN	
TCHA1  . . . . . . . . . . . . .	L Near	 40000D28 MAIN	
TCHAR  . . . . . . . . . . . . .	L Near	 40000CE4 MAIN	
TECHO  . . . . . . . . . . . . .	L Near	 400004EC MAIN	
TEMIT  . . . . . . . . . . . . .	L Near	 400004A4 MAIN	
TEMP . . . . . . . . . . . . . .	L Near	 40000534 MAIN	
TEVAL  . . . . . . . . . . . . .	L Near	 400005AC MAIN	
TEXPE  . . . . . . . . . . . . .	L Near	 400004BC MAIN	
THENN  . . . . . . . . . . . . .	L Near	 40002360 MAIN	
THROW  . . . . . . . . . . . . .	L Near	 40001D98 MAIN	
TIBB . . . . . . . . . . . . . .	Number	 4001FE5Ch   
TIB  . . . . . . . . . . . . . .	L Near	 40000E78 MAIN	
TICK1  . . . . . . . . . . . . .	L Near	 40002140 MAIN	
TICK . . . . . . . . . . . . . .	L Near	 4000211C MAIN	
TIC  . . . . . . . . . . . . . .	Number	 0027h	 
TNAM1  . . . . . . . . . . . . .	L Near	 400028E4 MAIN	
TNAM2  . . . . . . . . . . . . .	L Near	 400028FC MAIN	
TNAM3  . . . . . . . . . . . . .	L Near	 4000292C MAIN	
TNAM4  . . . . . . . . . . . . .	L Near	 40002954 MAIN	
TNAME  . . . . . . . . . . . . .	L Near	 400028D0 MAIN	
TNUMB  . . . . . . . . . . . . .	L Near	 400005C4 MAIN	
TOKEN  . . . . . . . . . . . . .	L Near	 400018F0 MAIN	
TOR  . . . . . . . . . . . . . .	L Near	 40000300 MAIN	
TPROM  . . . . . . . . . . . . .	L Near	 40000504 MAIN	
TQKEY  . . . . . . . . . . . . .	L Near	 4000048C MAIN	
TTAP . . . . . . . . . . . . . .	L Near	 400004D4 MAIN	
TXSTO  . . . . . . . . . . . . .	L Near	 40000140 MAIN	
TYPE1  . . . . . . . . . . . . .	L Near	 40001510 MAIN	
TYPE2  . . . . . . . . . . . . .	L Near	 40001528 MAIN	
TYPEE  . . . . . . . . . . . . .	L Near	 400014F4 MAIN	
UDOTR  . . . . . . . . . . . . .	L Near	 40001604 MAIN	
UDOT . . . . . . . . . . . . . .	L Near	 4000163C MAIN	
ULAST  . . . . . . . . . . . . .	L Near	 40000108 MAIN	
ULES1  . . . . . . . . . . . . .	L Near	 40000880 MAIN	
ULESS  . . . . . . . . . . . . .	L Near	 4000084C MAIN	
UMM1 . . . . . . . . . . . . . .	L Near	 40000980 MAIN	
UMM2 . . . . . . . . . . . . . .	L Near	 400009EC MAIN	
UMM3 . . . . . . . . . . . . . .	L Near	 400009F0 MAIN	
UMM4 . . . . . . . . . . . . . .	L Near	 40000A08 MAIN	
UMMOD  . . . . . . . . . . . . .	L Near	 40000950 MAIN	
UMST1  . . . . . . . . . . . . .	L Near	 40000B20 MAIN	
UMST2  . . . . . . . . . . . . .	L Near	 40000B60 MAIN	
UMSTA  . . . . . . . . . . . . .	L Near	 40000AF8 MAIN	
UNIQ1  . . . . . . . . . . . . .	L Near	 40002478 MAIN	
UNIQU  . . . . . . . . . . . . .	L Near	 40002440 MAIN	
UNTIL  . . . . . . . . . . . . .	L Near	 400022A4 MAIN	
UPLUS  . . . . . . . . . . . . .	L Near	 400003EC MAIN	
UPP  . . . . . . . . . . . . . .	Number	 4001FB7Ch   
UP . . . . . . . . . . . . . . .	L Near	 4000041C MAIN	
USER . . . . . . . . . . . . . .	L Near	 40002670 MAIN	
US . . . . . . . . . . . . . . .	Number	 0100h	 
UTYP1  . . . . . . . . . . . . .	L Near	 4000271C MAIN	
UTYP2  . . . . . . . . . . . . .	L Near	 40002738 MAIN	
UTYPE  . . . . . . . . . . . . .	L Near	 40002700 MAIN	
UZERO  . . . . . . . . . . . . .	L Near	 40000074 MAIN	
VARIA  . . . . . . . . . . . . .	L Near	 400026DC MAIN	
VERSN  . . . . . . . . . . . . .	L Near	 40002A70 MAIN	
VER  . . . . . . . . . . . . . .	Number	 0001h	 
VOCSS  . . . . . . . . . . . . .	Number	 0008h	 
WHILE_ . . . . . . . . . . . . .	L Near	 400023C4 MAIN	
WITHI  . . . . . . . . . . . . .	L Near	 40000924 MAIN	
WORDD  . . . . . . . . . . . . .	L Near	 40001930 MAIN	
WORDS  . . . . . . . . . . . . .	L Near	 40002A20 MAIN	
WORS1  . . . . . . . . . . . . .	L Near	 40002A3C MAIN	
WORS2  . . . . . . . . . . . . .	L Near	 40002A6C MAIN	
XIO  . . . . . . . . . . . . . .	L Near	 40001FAC MAIN	
XORR . . . . . . . . . . . . . .	L Near	 400003D4 MAIN	
ZLESS  . . . . . . . . . . . . .	L Near	 4000038C MAIN	
_CODE  . . . . . . . . . . . . .	Number	 40002B10h   
_LEN . . . . . . . . . . . . . .	Number	 0001h	 
_LINK  . . . . . . . . . . . . .	Number	 4001EF10h   
_NAME  . . . . . . . . . . . . .	Number	 4001EF08h   
_USER  . . . . . . . . . . . . .	Number	 0094h	 
charin . . . . . . . . . . . . .	Number	 0001h	 
cra  . . . . . . . . . . . . . .	Number	 0002h	 
csra . . . . . . . . . . . . . .	Number	 0001h	 
datain . . . . . . . . . . . . .	Number	 000Ch	 
dataout  . . . . . . . . . . . .	Number	 000Ch	 
dist . . . . . . . . . . . . . .	Text   	 (rx1-from1)
entry1 . . . . . . . . . . . . .	Number	 25FB2148h   
entry2 . . . . . . . . . . . . .	Number	 30F084FAh   
entry3 . . . . . . . . . . . . .	Number	 00F6h	 
from1  . . . . . . . . . . . . .	L Near	 40000111 MAIN	
ip . . . . . . . . . . . . . . .	Number	 0006h	 
mr1a . . . . . . . . . . . . . .	Number	 0000h	 
mr2a . . . . . . . . . . . . . .	Number	 0000h	 
rp . . . . . . . . . . . . . . .	Number	 0007h	 
rx1  . . . . . . . . . . . . . .	L Near	 4000012E MAIN	
scratch  . . . . . . . . . . . .	Number	 000Fh	 
spx  . . . . . . . . . . . . . .	Number	 0005h	 
temp1  . . . . . . . . . . . . .	Text   	 urdcode
uartbase . . . . . . . . . . . .	Number	 28000000h   
uart . . . . . . . . . . . . . .	Number	 0002h	 
urdcode  . . . . . . . . . . . .	L Near	 40000100 MAIN	
uread  . . . . . . . . . . . . .	Number	 0001h	 
ustat  . . . . . . . . . . . . .	Number	 0004h	 
w  . . . . . . . . . . . . . . .	Number	 0004h	 

	   0 Warnings
	   0 Errors
